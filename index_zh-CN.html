<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="keywords" content="Apple, Combine, ReactiveX, SwiftUI">
<meta name="author" content="Joseph Heck">
<meta name="copyright" content="Joseph Heck 2019-2021">
<title>Using Combine</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Using Combine</h1>
<div class="details">
<span id="author" class="author">Joseph Heck</span><br>
<span id="revnumber">version 1.2.1,</span>
<span id="revdate">2021-12-21</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#aboutthisbook">关于本书</a>
<ul class="sectlevel2">
<li><a href="#支持作者">支持作者</a></li>
<li><a href="#致谢">致谢</a></li>
<li><a href="#作者简介">作者简介</a></li>
<li><a href="#译者简介">译者简介</a></li>
<li><a href="#翻译术语表">翻译术语表</a></li>
<li><a href="#从哪获取这本书">从哪获取这本书</a>
<ul class="sectlevel3">
<li><a href="#下载项目">下载项目</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#introduction">Combine 简介</a>
<ul class="sectlevel2">
<li><a href="#函数响应式编程">函数响应式编程</a></li>
<li><a href="#combine-的特性">Combine 的特性</a></li>
<li><a href="#什么情况使用-combine">什么情况使用 Combine</a></li>
<li><a href="#introduction-appledocs">Apple 官方提供的 Combine 文档</a>
<ul class="sectlevel3">
<li><a href="#wwdc-2019-内容">WWDC 2019 内容</a></li>
</ul>
</li>
<li><a href="#其他线上的-combine-资源">其他线上的 Combine 资源</a></li>
</ul>
</li>
<li><a href="#coreconcepts">核心概念</a>
<ul class="sectlevel2">
<li><a href="#coreconcepts-publisher-subscriber">Publisher and Subscriber</a></li>
<li><a href="#coreconcepts-marblediagram">用弹珠图描述管道</a>
<ul class="sectlevel3">
<li><a href="#怎么看懂弹珠图">怎么看懂弹珠图:</a></li>
<li><a href="#用弹珠图描述-combine">用弹珠图描述 Combine</a></li>
</ul>
</li>
<li><a href="#coreconcepts-backpressure">Back pressure</a></li>
<li><a href="#coreconcepts-lifecycle">发布者和订阅者的生命周期</a></li>
<li><a href="#coreconcepts-publishers">发布者</a></li>
<li><a href="#coreconcepts-operators">操作符</a></li>
<li><a href="#coreconcepts-subjects">Subjects</a></li>
<li><a href="#coreconcepts-subscribers">订阅者</a></li>
</ul>
</li>
<li><a href="#developingwith">使用 Combine 进行开发</a>
<ul class="sectlevel2">
<li><a href="#关于管道运用的思考">关于管道运用的思考</a></li>
<li><a href="#developingwith-types">Combine 发布者和订阅者涉及到的 Swift 类型</a></li>
<li><a href="#developingwith-threads">管道和线程</a></li>
<li><a href="#把-combine-运用到你的开发中">把 Combine 运用到你的开发中</a></li>
</ul>
</li>
<li><a href="#patterns">常用模式和方法</a>
<ul class="sectlevel2">
<li><a href="#patterns-sink-subscriber">使用 sink 创建一个订阅者</a></li>
<li><a href="#patterns-assign-subscriber">使用 assign 创建一个订阅者</a></li>
<li><a href="#patterns-datataskpublisher-decode">使用 dataTaskPublisher 发起网络请求</a></li>
<li><a href="#patterns-datataskpublisher-trymap">使用 dataTaskPublisher 进行更严格的请求处理</a>
<ul class="sectlevel3">
<li><a href="#标准化-datataskpublisher-返回的错误">标准化 dataTaskPublisher 返回的错误</a></li>
</ul>
</li>
<li><a href="#patterns-future">用 Future 来封装异步请求以创建一次性的发布者</a></li>
<li><a href="#patterns-sequencing-operations">有序的异步操作</a></li>
<li><a href="#patterns-general-error-handling">错误处理</a>
<ul class="sectlevel3">
<li><a href="#patterns-assertnofailure">使用 assertNoFailure 验证未发生失败</a></li>
<li><a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a></li>
<li><a href="#patterns-retry">在发生暂时失败时重试</a></li>
<li><a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a></li>
<li><a href="#patterns-constrained-network">网络受限时从备用 URL 请求数据</a></li>
</ul>
</li>
<li><a href="#patterns-uikit-integration">和 UIKit 或 AppKit 集成</a>
<ul class="sectlevel3">
<li><a href="#patterns-update-interface-userinput">通过用户输入更新声明式 UI</a></li>
<li><a href="#patterns-cascading-update-interface">级联多个 UI 更新，包括网络请求</a></li>
<li><a href="#patterns-merging-streams-interface">合并多个管道以更新 UI 元素</a></li>
<li><a href="#patterns-delegate-publisher-subject">通过包装基于 delegate 的 API 创建重复发布者</a></li>
<li><a href="#patterns-notificationcenter">响应 NotificationCenter 的更新</a></li>
</ul>
</li>
<li><a href="#patterns-swiftui-integration">和 SwiftUI 集成</a>
<ul class="sectlevel3">
<li><a href="#pattern-observableobject">使用 ObservableObject 与 SwiftUI 模型作为发布源</a></li>
</ul>
</li>
<li><a href="#patterns-testing-and-debugging">测试和调试</a>
<ul class="sectlevel3">
<li><a href="#patterns-testing-publisher">使用 XCTestExpectation 测试发布者</a></li>
<li><a href="#patterns-testing-subscriber">使用 PassthroughSubject 测试订阅者</a></li>
<li><a href="#patterns-testing-subscriber-scheduled">使用从 PassthroughSubject 预定好的发送的事件测试订阅者</a></li>
<li><a href="#patterns-testable-publisher-subscriber">使用 EntwineTest 创建可测试的发布器和订阅者</a></li>
<li><a href="#patterns-debugging-print">使用 print 操作符调试管道</a></li>
<li><a href="#patterns-debugging-handleevents">使用 handleEvents 操作符调试管道</a></li>
<li><a href="#patterns-debugging-breakpoint">使用调试器调试管道</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#reference-publishers">Publishers</a>
<ul class="sectlevel3">
<li><a href="#reference-just">Just</a></li>
<li><a href="#reference-future">Future</a></li>
<li><a href="#reference-empty">Empty</a></li>
<li><a href="#reference-fail">Fail</a></li>
<li><a href="#reference-sequence">Publishers.Sequence</a></li>
<li><a href="#reference-record">Record</a></li>
<li><a href="#reference-deferred">Deferred</a></li>
<li><a href="#reference-makeconnectable">MakeConnectable</a></li>
<li><a href="#reference-swiftui">SwiftUI</a>
<ul class="sectlevel4">
<li><a href="#binding">Binding</a></li>
<li><a href="#swiftui-and-combine">SwiftUI and Combine</a></li>
</ul>
</li>
<li><a href="#reference-observableobject">ObservableObject</a></li>
<li><a href="#reference-published">@Published</a></li>
<li><a href="#reference-foundation">Foundation</a></li>
<li><a href="#reference-notificationcenter">NotificationCenter</a></li>
<li><a href="#reference-timer">Timer</a></li>
<li><a href="#reference-kvo-publisher">publisher from a KeyValueObserving instance</a></li>
<li><a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a></li>
<li><a href="#reference-result">Result</a></li>
<li><a href="#reference-realitykit">RealityKit</a></li>
</ul>
</li>
<li><a href="#reference-operators">Operators</a>
<ul class="sectlevel3">
<li><a href="#reference-operators-mapping">Mapping elements</a>
<ul class="sectlevel4">
<li><a href="#reference-scan">scan</a></li>
<li><a href="#reference-tryscan">tryScan</a></li>
<li><a href="#reference-map">map</a></li>
<li><a href="#reference-trymap">tryMap</a></li>
<li><a href="#reference-flatmap">flatMap</a></li>
<li><a href="#reference-setfailuretype">setFailureType</a></li>
</ul>
</li>
<li><a href="#reference-operators-filtering">Filtering elements</a>
<ul class="sectlevel4">
<li><a href="#reference-compactmap">compactMap</a></li>
<li><a href="#reference-trycompactmap">tryCompactMap</a></li>
<li><a href="#reference-filter">filter</a></li>
<li><a href="#reference-tryfilter">tryFilter</a></li>
<li><a href="#reference-removeduplicates">removeDuplicates</a></li>
<li><a href="#reference-tryremoveduplicates">tryRemoveDuplicates</a></li>
<li><a href="#reference-replaceempty">replaceEmpty</a></li>
<li><a href="#reference-replaceerror">replaceError</a></li>
<li><a href="#reference-replacenil">replaceNil</a></li>
</ul>
</li>
<li><a href="#reference-operators-reducing">Reducing elements</a>
<ul class="sectlevel4">
<li><a href="#reference-collect">collect</a></li>
<li><a href="#reference-ignoreoutput">ignoreOutput</a></li>
<li><a href="#reference-reduce">reduce</a></li>
<li><a href="#reference-tryreduce">tryReduce</a></li>
</ul>
</li>
<li><a href="#reference-operators-mathematical">Mathematic operations on elements</a>
<ul class="sectlevel4">
<li><a href="#reference-max">max</a></li>
<li><a href="#reference-trymax">tryMax</a></li>
<li><a href="#reference-min">min</a></li>
<li><a href="#reference-trymin">tryMin</a></li>
<li><a href="#reference-count">count</a></li>
</ul>
</li>
<li><a href="#reference-operators-criteria">Applying matching criteria to elements</a>
<ul class="sectlevel4">
<li><a href="#reference-allsatisfy">allSatisfy</a></li>
<li><a href="#reference-tryallsatisfy">tryAllSatisfy</a></li>
<li><a href="#reference-contains">contains</a></li>
<li><a href="#reference-containswhere">containsWhere</a></li>
<li><a href="#reference-trycontainswhere">tryContainsWhere</a></li>
</ul>
</li>
<li><a href="#reference-operators-sequence">Applying sequence operations to elements</a>
<ul class="sectlevel4">
<li><a href="#reference-first">first</a></li>
<li><a href="#reference-firstwhere">firstWhere</a></li>
<li><a href="#reference-tryfirstwhere">tryFirstWhere</a></li>
<li><a href="#reference-last">last</a></li>
<li><a href="#reference-lastwhere">lastWhere</a></li>
<li><a href="#reference-trylastwhere">tryLastWhere</a></li>
<li><a href="#reference-dropuntiloutput">dropUntilOutput</a></li>
<li><a href="#reference-dropwhile">dropWhile</a></li>
<li><a href="#reference-trydropwhile">tryDropWhile</a></li>
<li><a href="#reference-prepend">prepend</a></li>
<li><a href="#reference-drop">drop</a></li>
<li><a href="#reference-prefixuntiloutput">prefixUntilOutput</a></li>
<li><a href="#reference-prefixwhile">prefixWhile</a></li>
<li><a href="#reference-tryprefixwhile">tryPrefixWhile</a></li>
<li><a href="#reference-output">output</a></li>
</ul>
</li>
<li><a href="#reference-operators-combinepublishers">Mixing elements from multiple publishers</a>
<ul class="sectlevel4">
<li><a href="#reference-combinelatest">combineLatest</a></li>
<li><a href="#reference-merge">merge</a></li>
<li><a href="#reference-Publishers">MergeMany</a></li>
<li><a href="#reference-zip">zip</a></li>
</ul>
</li>
<li><a href="#reference-operators-handlingerrors">Error Handling</a>
<ul class="sectlevel4">
<li><a href="#reference-catch">catch</a></li>
<li><a href="#reference-trycatch">tryCatch</a></li>
<li><a href="#reference-assertnofailure">assertNoFailure</a></li>
<li><a href="#reference-retry">retry</a></li>
<li><a href="#reference-maperror">mapError</a></li>
</ul>
</li>
<li><a href="#reference-operators-adaptingtypes">Adapting publisher types</a>
<ul class="sectlevel4">
<li><a href="#reference-switchtolatest">switchToLatest</a></li>
</ul>
</li>
<li><a href="#reference-operators-timing">Controlling timing</a>
<ul class="sectlevel4">
<li><a href="#reference-debounce">debounce</a></li>
<li><a href="#reference-delay">delay</a></li>
<li><a href="#reference-measureinterval">measureInterval</a></li>
<li><a href="#reference-throttle">throttle</a></li>
<li><a href="#reference-timeout">timeout</a></li>
</ul>
</li>
<li><a href="#reference-operators-coding">Encoding and decoding</a>
<ul class="sectlevel4">
<li><a href="#reference-encode">encode</a></li>
<li><a href="#reference-decode">decode</a></li>
</ul>
</li>
<li><a href="#reference-operators-multiplesubscribers">Working with multiple subscribers</a>
<ul class="sectlevel4">
<li><a href="#reference-share">share</a></li>
<li><a href="#reference-multicast">multicast</a></li>
</ul>
</li>
<li><a href="#reference-operators-debugging">Debugging</a>
<ul class="sectlevel4">
<li><a href="#reference-breakpoint">breakpoint</a></li>
<li><a href="#reference-breakpointonerror">breakpointOnError</a></li>
<li><a href="#reference-handleevents">handleEvents</a></li>
<li><a href="#reference-print">print</a></li>
</ul>
</li>
<li><a href="#scheduler-and-thread-handling-operators">Scheduler and Thread handling operators</a>
<ul class="sectlevel4">
<li><a href="#reference-receive">receive</a></li>
<li><a href="#reference-subscribe">subscribe</a></li>
</ul>
</li>
<li><a href="#type-erasure-operators">Type erasure operators</a>
<ul class="sectlevel4">
<li><a href="#reference-erasetoanypublisher">eraseToAnyPublisher</a></li>
<li><a href="#reference-anysubscriber">AnySubscriber</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference-subjects">Subjects</a>
<ul class="sectlevel3">
<li><a href="#reference-currentvaluesubject">currentValueSubject</a></li>
<li><a href="#reference-passthroughsubject">PassthroughSubject</a></li>
</ul>
</li>
<li><a href="#reference-subscribers">Subscribers</a>
<ul class="sectlevel3">
<li><a href="#reference-assign">assign</a></li>
<li><a href="#reference-sink">sink</a></li>
<li><a href="#reference-onreceive">onReceive</a></li>
<li><a href="#reference-anycancellable">AnyCancellable</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="aboutthisbook">关于本书</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(<a href="./index.html">english</a>) (<a href="./index_zh-CN.html">普通话</a>)</p>
</div>
<div class="paragraph">
<p>版本号: 1.2.1</p>
</div>
<div class="paragraph">
<p>该版日期: 2021-12-21</p>
</div>
<div class="paragraph">
<p>这是一本中高级难度的书，主要关注在如何使用 Combine 框架。
你需要对 Swift 及其中的引用和值类型、协议有透彻的理解，并且能够熟练使用 Foundation 框架中的常用元素，才能阅读本书和其中的示例。</p>
</div>
<div class="paragraph">
<p>如果你刚开始学习 Swift， <a href="https://developer.apple.com/swift/resources/">Apple 提供了一些资源</a> 可以用来学习，
还有一些作者写了非常棒的教程和入门书籍， 例如 Daniel Steinberg 写的 <a href="https://gumroad.com/l/swift-kickstart">A Swift Kickstart</a> 和 Paul Hudson 写的 <a href="https://www.hackingwithswift.com">Hacking with Swift</a>。</p>
</div>
<div class="paragraph">
<p>这本书提供了对函数响应式编程概念的 <a href="#introduction">简短介绍</a>， 这正是 Combine 所要提供的编程方式。</p>
</div>
<div class="sect2">
<h3 id="支持作者">支持作者</h3>
<div class="paragraph">
<p><strong><em>如果您觉得内容有用，可购买没有数字版权管理英文原版的 PDF 或 ePub 版本 <a href="http://gumroad.com/l/usingcombine" class="bare">http://gumroad.com/l/usingcombine</a>.</em></strong></p>
</div>
<div class="paragraph">
<p>这本书提供免费的 <a href="https://heckj.github.io/swiftui-notes/">线上英文原版</a> 和 <a href="https://zhiying.space/using-combine/">中文翻译版</a>。</p>
</div>
<div class="paragraph">
<p>如果发现中文翻译版有拼写、语法或者技术错误想要指出，可以 fork 这个仓库，更新或者纠正之后创建一个 <a href="https://github.com/zhiying-fan/using-combine/pulls">pull requests</a> 给我。</p>
</div>
<div class="paragraph">
<p>如果发现英文原版有拼写、语法或者技术错误想要指出，请在 GitHub <a href="https://github.com/heckj/swiftui-notes/issues/new/choose">新建一个 issue</a>。
如果你愿意的话，也可以 fork 英文原版的仓库，更新或者纠正之后创建一个 <a href="https://github.com/heckj/swiftui-notes/compare?expand=1">pull requests</a> 给作者。</p>
</div>
</div>
<div class="sect2">
<h3 id="致谢">致谢</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">感谢</div>
<div class="paragraph">
<p>Michael Critz 设计并提供封面。</p>
</div>
<div class="paragraph">
<p>以下人员的检查、指正和更新:</p>
</div>
<div class="paragraph">
<p>Benjamin Barnard,
Mycroft Canner,
Max Desiatov,
Tim Ekl,
Malcolm Hall,
Arthur Hammer,
Nanu Jogi,
Serhii Kyrylenko,
Brett Markowitz,
Matt Massicotte,
Michel Mohrmann,
John Mueller,
Lee O&#8217;Mara,
Kai Özer,
Martin Pfundmair,
Zachary Recolan,
Dave Reed,
Dean Scarff,
Andrius Shiaulis,
Antoine Weber,
Paul Wood III,
Federico Zanetello</p>
</div>
<div class="paragraph">
<p>中文版翻译：
樊志颖，
卫林霄</p>
</div>
</div>
</div>
<div class="paragraph">
<p>谢谢你们所有人花费时间和精力提交 pull request，使这本书变得更好！</p>
</div>
</div>
<div class="sect2">
<h3 id="作者简介">作者简介</h3>
<div class="paragraph">
<p>Joe Heck 在初创公司和大型公司中拥有广泛的软件工程开发和管理经验。
他为架构、开发、验证、部署和操作这所有阶段提供解决方案。</p>
</div>
<div class="paragraph">
<p>Joe 开发了从移动和桌面应用程序开发的项目到基于云的分布式系统。
他建立了团队、开发流程、CI 和 CD 流水线，并制定了验证和运营自动化。
Joe 还指导人们学习、构建、验证、部署和运行软件服务和基础架构。</p>
</div>
<div class="paragraph">
<p>Joe 广泛的贡献和参与到各种开源项目的工作中。
他在网站 <a href="https://rhonabwy.com/" class="bare">https://rhonabwy.com/</a> 上撰写了各种主题的文章。</p>
</div>
<table class="tableblock frame-none grid-none" style="width: 50%;">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><a href="https://github.com/heckj"><span class="icon"><i class="fa fa-github fa-2x"></i></span></a></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><a href="https://www.linkedin.com/in/josephheck/"><span class="icon"><i class="fa fa-linkedin fa-2x"></i></span></a></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><a href="http://twitter.com/heckj"><span class="icon"><i class="fa fa-twitter fa-2x"></i></span></a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="译者简介">译者简介</h3>
<div class="paragraph">
<p>樊志颖，专注于 iOS 开发。</p>
</div>
<div class="paragraph">
<p>个人网站: <a href="https://zhiying.space" class="bare">https://zhiying.space</a></p>
</div>
<div class="paragraph">
<p>Github: <a href="https://github.com/zhiying-fan" class="bare">https://github.com/zhiying-fan</a></p>
</div>
<div class="paragraph">
<p>卫林霄，iOS 开发。</p>
</div>
<div class="paragraph">
<p>GitHub: <a href="https://github.com/yeland" class="bare">https://github.com/yeland</a></p>
</div>
</div>
<div class="sect2">
<h3 id="翻译术语表">翻译术语表</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Framework</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">框架</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Pipeline</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">管道</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Functional programming</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">函数式编程</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Functional reactive programming</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">函数响应式编程</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Publisher</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">发布者</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Subscriber</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">订阅者</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Operator</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">操作符</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="从哪获取这本书">从哪获取这本书</h3>
<div class="paragraph">
<p>本书的线上版本以 HTML 的形式免费提供， <a href="https://heckj.github.io/swiftui-notes/">英文原版</a> 和 <a href="https://zhiying.space/using-combine/">中文翻译版</a>。</p>
</div>
<div class="paragraph">
<p>没有数字版权管理英文原版的 PDF 或 ePub 版本可以在 <a href="http://gumroad.com/l/usingcombine" class="bare">http://gumroad.com/l/usingcombine</a> 购买。</p>
</div>
<div class="paragraph">
<p>随着开发的继续，将对线上版本的内容持续更新。
更大的更新和宣告也会通过 <a href="https://gumroad.com/heckj">作者在 Gumroad 的简介</a> 进行提供。</p>
</div>
<div class="paragraph">
<p>本书的内容包括示例代码和测试，都放在 GitHub 的仓库中: <a href="https://github.com/heckj/swiftui-notes" class="bare">https://github.com/heckj/swiftui-notes</a> 。</p>
</div>
<div class="sect3">
<h4 id="下载项目">下载项目</h4>
<div class="paragraph">
<p>本书的内容以及本书引用的示例代码和单元测试，都被链接到了一个 Xcode 的项目中（<code>swiftui-notes.xcodeproj</code>）。
该 Xcode 项目包括完全可实操的示例代码，展示了 Combine 与 Uikit 和 SwiftUI 集成的示例。
该项目还包括运用此框架的大量单元测试，以说明框架组件的行为。</p>
</div>
<div class="paragraph">
<p>与本书关联的项目需要 Xcode 11 和 Macos 10.14 或更高版本。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/welcomeToXcode.png" alt="Welcome to Xcode" width="406" height="388">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>从 Welcome to Xcode 窗口，选择 <strong>Clone an existing project</strong></p>
</li>
<li>
<p>输入 <code><a href="https://github.com/heckj/swiftui-notes.git" class="bare">https://github.com/heckj/swiftui-notes.git</a></code> 然后点击 <code>Clone</code></p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/cloneRepository.png" alt="clone Repository" width="463" height="263">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>选择 <code>master</code> 分支检出</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">Combine 简介</h2>
<div class="sectionbody">
<div class="paragraph">
<p>用 Apple 官方的话来说，Combine 是:</p>
</div>
<div class="quoteblock">
<blockquote>
a declarative Swift API for processing values over time.
</blockquote>
</div>
<div class="paragraph">
<p>Combine 是 Apple 用来实现函数响应式编程的库， 类似于 <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>。
RxSwift 是 <a href="http://reactivex.io">ReactiveX</a> 对 Swift 语言的实现。
Combine 使用了许多可以在其他语言和库中找到的相同的函数响应式概念，并将 Swift 的静态类型特性应用其中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你已经熟悉 RxSwift 了，这里有 <a href="https://github.com/CombineCommunity/rxswift-to-combine-cheatsheet">一份整理好的表单</a> 可以让你把 RxSwift 的概念和 API 对应到 Combine 上。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="函数响应式编程">函数响应式编程</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">函数响应式编程</a>， 也称为数据流编程, 建立在 <a href="https://en.wikipedia.org/wiki/Functional_programming">函数式编程</a> 的概念上。
其中函数式编程适用于元素列表，函数响应式编程应用于元素流。
函数式编程中的各种函数，例如 <code>map</code>, <code>filter</code>, 和 <code>reduce</code> 也有可以应用于流的类似函数。
除了函数式编程原本的能力外，函数响应式编程还包括用于分割和合并流的函数。
像函数式编程一样，你可以对在流中的数据进行转换。</p>
</div>
<div class="paragraph">
<p>在我们编程的系统中有许多部分可以被视为异步信息流 - 事件、对象或数据。
观察者模式监听单个对象，在其更改变化时提供通知事件。
如果你随着时间的推移查看这些通知，它们会构成一个对象流。
函数响应式编程 Combine，允许你创建代码，来描述在流中获取到数据时发生的事情。</p>
</div>
<div class="paragraph">
<p>你可能希望创建逻辑以监听多个元素的改变。
你可能还希望包含有异步操作的逻辑，其中一些可能会失败。
您可能想要根据时序更改数据流的内容，或更改内容的时序。
处理这些事件流的流程、时序、发生的错误以及协调系统如何响应所有这些事件是函数响应式编程的核心。</p>
</div>
<div class="paragraph">
<p>基于函数响应式编程的解决方案在开发用户界面时特别有效。
它也更通常用于创建流水线，用来处理从外部源或异步 API 返回的数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="combine-的特性">Combine 的特性</h3>
<div class="paragraph">
<p>将这些概念应用于像 Swift 这样的强类型语言是 Apple 在 Combine 中所创造的一部分。
Combine 通过嵌入 back-pressure 来扩展函数响应式编程。
Back-pressure 是指订阅者应该控制它一次获得多少信息以及需要处理多少信息。
这带来了高效的数据操作，并且通过流处理的数据量是可控和可取消的。</p>
</div>
<div class="paragraph">
<p>Combine 的元素被设置为组合式的，这有利于逐步地集成于现有的代码以采用它。</p>
</div>
<div class="paragraph">
<p>Apple 的其他一些框架利用了Combine。
SwiftUI 是最受关注的明显示例，同时包含订阅者和发布者。
RealityKit 也具有可用于对事件做出反应的发布者。
Foundation 有许多 Combine 特定的附加功能，包括作为发布者的 NotificationCenter、URLSession 和 Timer。</p>
</div>
<div class="paragraph">
<p>任何异步 API <em>都可以</em> 与 Combine 一起使用。
例如，你可以使用 Vision 框架中的一些 API，通过利用 Combine 组合流入和流出的数据。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>在这本书中，我将把 Combine 中的一系列组合操作称作 <strong>管道</strong>。
管道 也许不是 Apple 在其文档中使用的术语。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="什么情况使用-combine">什么情况使用 Combine</h3>
<div class="paragraph">
<p>当你想要设置对各种输入做出反应时，Combine 最合适，
用户界面也非常适合这种模式。</p>
</div>
<div class="paragraph">
<p>在用户界面中使用函数响应式编程的经典示例是表单验证，其中用户事件如更改文本字段、点击或鼠标点击 UI 元素构成正在流式传输的数据。
Combine 更进一步，支持监听属性、绑定到对象、从 UI 控件发送和接收更高级别的事件，并支持与几乎所有 Apple 现有 API 生态系统的集成。</p>
</div>
<div class="paragraph">
<p>你可以使用 Combine 执行的一些操作包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>你可以设置管道以仅在字段中输入的值有效时启用提交按钮。</p>
</li>
<li>
<p>管道还可以执行异步操作（例如检查网络服务）并使用返回的值来选择在视图中更新的方式和内容。</p>
</li>
<li>
<p>管道还可用于对用户在文本字段中动态输入做出反应，并根据他们输入的内容更新用户界面视图。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Combine 不限于用户界面。
任何异步操作序列都可以被作为管道，尤其是当每个步骤的结果流向下一步时。
此类示例可能是一系列网络服务请求，然后对结果进行解码。</p>
</div>
<div class="paragraph">
<p>Combine 也可用于定义如何处理异步操作中的错误。
通过设置管道并将它们合并在一起，Combine 支持这样做。
Apple 使用 Combine 的示例之一是在本地网络受限时退而求其次地从网络服务获取较低分辨率图像的管道。</p>
</div>
<div class="paragraph">
<p>你使用 Combine 创建的许多管道都只有少量操作。
即使只进行少量操作，Combine 仍然可以让你更轻松地查看和理解在组合管道时发生的情况。
Combine 的管道是一种声明性方式，用于定义随着时间的推移对数据流中值进行的处理。</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect2">
<h3 id="introduction-appledocs">Apple 官方提供的 Combine 文档</h3>
<div class="paragraph">
<p><span class="icon"><i class="fa fa-apple fa-2x"></i></span></p>
</div>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/combine">Combine 的在线文档</a> 可以在 <a href="https://developer.apple.com/documentation/combine" class="bare">https://developer.apple.com/documentation/combine</a> 找到。
Apple 的开发者文档托管在 <a href="https://developer.apple.com/documentation/" class="bare">https://developer.apple.com/documentation/</a> 。</p>
</div>
<div class="sect3">
<h4 id="wwdc-2019-内容">WWDC 2019 内容</h4>
<div class="paragraph">
<p>Apple 在其开发者大会中提供了视频、幻灯片和一些示例代码。
关于 Combine 的详细信息主要来自 <a href="https://developer.apple.com/videos/play/wwdc2019">WWDC 2019</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>自从在 WWDC 2019 上首次发布以来，Combine 一直在发展。
这些演示文稿中的一些内容现在略有过时或与当前存在的内容有所不同。
这些内容中的大部分对于介绍或了解 Combine 是什么以及可以做什么仍然非常有价值。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其中一些介绍并深入讲解了 Combine：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/videos/play/wwdc2019/722/">Introducing Combine</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2019/722l6blhn0efespfgx/722/722_introducing_combine.pdf?dl=1">PDF of presentation notes</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://developer.apple.com/videos/play/wwdc2019/721/">Combine in Practice</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2019/721ga0kflgr4ypfx/721/721_combine_in_practice.pdf?dl=1">PDF of presentation notes</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>许多其他 WWDC19 会议提到了 Combine：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/videos/play/wwdc2019/415/">Modern Swift API Design</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/videos/play/wwdc2019/226">Data Flow Through SwiftUI</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/videos/play/wwdc2019/711">Introducing Combine and Advances in Foundation</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/videos/play/wwdc2019/712/">Advances in Networking, Part 1</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/videos/play/wwdc2019/610/">Building Collaborative AR Experiences</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/videos/play/wwdc2019/223/">Expanding the Sensory Experience with Core Haptics</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="其他线上的-combine-资源">其他线上的 Combine 资源</h3>
<div class="paragraph">
<p>除了 Apple 的文档之外，还有许多其他在线资源，你可以在其中找到有关 Combine 运作方式的问题、答案、讨论和说明。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://forums.swift.org/">Swift 论坛</a>（托管于 <a href="https://swift.org/">swift 开源项目</a>）有一个 <a href="https://forums.swift.org/tags/combine">combine tag</a> 有许多有趣讨论。虽然 Combine 框架 <strong>不是</strong> 开源的，但在这些论坛中有它的一些实现和细节的讨论。</p>
</li>
<li>
<p><a href="https://stackoverflow.com">Stackoverflow</a> 也有大量（并且还在不断增加）的 <a href="https://stackoverflow.com/questions/tagged/combine">Combine 相关问答</a>。</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coreconcepts">核心概念</h2>
<div class="sectionbody">
<div class="paragraph">
<p>你只需要了解几个核心概念，就能使用好 Combine，但理解它们非常重要。
这些概念中的每一个都通过通用协议反映在框架中，以将概念转化为预期的功能。</p>
</div>
<div class="paragraph">
<p>这些核心概念是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#coreconcepts-publisher-subscriber">Publisher and Subscriber</a></p>
</li>
<li>
<p><a href="#coreconcepts-operators">操作符</a></p>
</li>
<li>
<p><a href="#coreconcepts-subjects">Subjects</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="coreconcepts-publisher-subscriber">Publisher and Subscriber</h3>
<div class="paragraph">
<p>两个关键概念， <a href="https://developer.apple.com/documentation/combine/publisher"><strong>publisher</strong></a> 和 <a href="https://developer.apple.com/documentation/combine/subscriber"><strong>subscriber</strong></a>，在 Swift 中被描述为协议。</p>
</div>
<div class="paragraph">
<p>当你谈论编程（尤其是 Swift 和 Combine）时，很多都使用类型描述。
当你说一个函数或方法返回一个值时，该值通常被描述为“此类型之一”。</p>
</div>
<div class="paragraph">
<p>Combine 就是定义随着时间的推移使用许多可能的值进行操作的过程。
Combine 还不仅仅是定义结果，它还定义了我们如何处理失败。
它不仅讨论可以返回的类型，还讨论可能发生的失败。</p>
</div>
<div class="paragraph">
<p>现在我们要引入的第一个核心概念是发布者。
当其被订阅之后，根据请求会提供数据，
没有任何订阅请求的发布者不会提供任何数据。
当你描述一个 Combine 的发布者时，应该用两种相关的类型来描述它：一种用于输出，一种用于失败。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagrams/basic_types.svg" alt="basic types">
</div>
</div>
<div class="paragraph">
<p>这些通常使用泛型语法编写，该语法在描述类型的文本周围使用 <code>&lt;</code> 和 <code>&gt;</code> 符号。
这表示我们正在谈论这种类型的值的通用实例。
例如，如果发布者返回了一个 <code>String</code> 类型的实例，并且可能以 <code>URLError</code> 实例的形式返回失败，那么发布者可能会用 <code>&lt;String, URLError&gt;</code> 来描述。</p>
</div>
<div class="paragraph">
<p>与发布者匹配的对应概念是订阅者，是第二个要介绍的核心概念。</p>
</div>
<div class="paragraph">
<p>订阅者负责请求数据并接受发布者提供的数据（和可能的失败）。
订阅者同样被描述为两种关联类型，一种用于输入，一种用于失败。
订阅者发起数据请求，并控制它接收的数据量。
它可以被认为是在 Combine 中起“驱动作用”的，因为如果没有订阅者，其他组件将保持闲置状态，没有数据会流动起来。</p>
</div>
<div class="paragraph">
<p>发布者和订阅者是相互连接的，它们构成了 Combine 的核心。
当你将订阅者连接到发布者时，两种类型都必须匹配：发布者的输出和订阅者的输入以及它们的失败类型。
将其可视化的一种方法是对两种类型进行一系列并行操作，其中两种类型都需要匹配才能将组件插入在一起。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagrams/input_output.svg" alt="publisher output to subscriber input">
</div>
</div>
<div class="paragraph">
<p>第三个核心概念是操作符——一个既像订阅者又像发布者的对象。
操作符是同时实现了 <a href="https://developer.apple.com/documentation/combine/subscriber">订阅者协议</a> 和 <a href="https://developer.apple.com/documentation/combine/publisher">发布者协议</a> 的类。
它们支持订阅发布者，并将结果发送给任何订阅者。</p>
</div>
<div class="paragraph">
<p>你可以用这些创建成链，用于处理和转换发布者提供的数据和订阅者请求的数据。</p>
</div>
<div class="paragraph">
<p>我称这些组合序列为<strong>管道</strong>。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagrams/pipeline.svg" alt="pipeline">
</div>
</div>
<div class="paragraph">
<p>操作符可用于转换值或类型 - 输出和失败类型都可以。
操作符还可以拆分或复制流，或将流合并在一起。
操作符必须始终按输出/失败这样的类型组合对齐。
编译器将强制执行匹配类型，因此类型错误将导致编译器错误（如果幸运的话，会有一个有用的 <em>fixit</em> 片段建议给你解决方案）。</p>
</div>
<div class="paragraph">
<p>用 swift 编写的简单的 Combine 管道如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="kt">Just</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">in</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="c1">// do something with the incoming value here</span>
        <span class="c1">// and return a string</span>
        <span class="k">return</span> <span class="s">"a string"</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">receivedValue</span> <span class="k">in</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="c1">// sink is the subscriber and terminates the pipeline</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"The end result was </span><span class="se">\(</span><span class="n">receivedValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>管道从发布者 <code>Just</code> 开始，它用它定义的值（在本例中为整数 <code>5</code>）进行响应。输出类型为 <code>&lt;Integer&gt;</code>，失败类型为 <code>&lt;Never&gt;</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>然后管道有一个 <code>map</code> 操作符，它在转换值及其类型。
在此示例中，它忽略了发布者发出的输入并返回了一个字符串。
这也将输出类型转换为 <code>&lt;String&gt;</code>，并将失败类型仍然保持为 <code>&lt;Never&gt;</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>然后管道以 <code>sink</code> 订阅者结束。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当你去尝试理解管道时，你可以将其视为由输出和失败类型链接的一系列操作。
当你开始构建自己的管道时，这种模式就会派上用场。
创建管道时，你可以选择操作符来帮助你转换数据、类型或两者同时使用以实现最终目的。
最终目标可能是启用或禁用用户界面的某个元素，或者可能是得到某些数据用来显示。
许多 Combine 的操作符专门设计用来做这些转换。</p>
</div>
<div class="paragraph">
<p>有许多操作符是以 <code>try</code> 为前缀的，这表示它们返回一个 <code>&lt;Error&gt;</code> 的失败类型。
例如 <a href="#reference-map">map</a> 和 <a href="#reference-trymap">tryMap</a>。
<code>map</code> 操作符可以转换输出和失败类型的任意组合。
<code>tryMap</code> 接受任何输入和失败类型，并允许输出任何类型，但始终会输出 <code>&lt;Error&gt;</code> 的失败类型。</p>
</div>
<div class="paragraph">
<p>像 <code>map</code> 这样的操作符，你在定义返回的输出类型时，允许你基于提供给操作符的闭包中返回的内容推断输出类型。
在上面的例子中，<code>map</code> 操作符返回一个 <code>String</code> 的输出类型，因为这正是闭包返回的类型。</p>
</div>
<div class="paragraph">
<p>为了更具体地说明更改类型的示例，我们扩展了值在传输过程中的转换逻辑。此示例仍然以提供类型 <code>&lt;Int, Never&gt;</code> 的发布者开始，并以类型为 <code>&lt;String, Never&gt;</code> 的订阅结束。</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/SwiftUI-NotesTests/CombinePatternTests.swift">SwiftUI-NotesTests/CombinePatternTests.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="kt">Just</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">in</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">switch</span> <span class="n">value</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"none"</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"one"</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"couple"</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"few"</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"many"</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"some"</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">receivedValue</span> <span class="k">in</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="nf">print</span><span class="p">(</span><span class="s">"The end result was </span><span class="se">\(</span><span class="n">receivedValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Just 是创建一个 <code>&lt;Int, Never&gt;</code> 类型组合的发布者，提供单个值然后完成。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>提供给 <code>.map()</code> 函数的闭包接受一个 <code>&lt;Int&gt;</code> 并将其转换为一个 <code>&lt;String&gt;</code>。由于 <code>&lt;Never&gt;</code> 的失败类型没有被改变，所以就直接输出了。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>sink</code> 作为订阅者，接受 <code>&lt;String, Never&gt;</code> 类型的组合数据。</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当你在 Xcode 中创建管道，类型不匹配时，Xcode 中的错误消息可能包含一个有用的修复建议 <em>fixit</em>。
在某些情况下，例如上个例子，当提供给 <code>map</code> 的闭包中不指定特定的返回类型时，编译器就无法推断其返回值类型。
Xcode (11 beta 2 and beta 3) 显示此为错误消息： <code>Unable to infer complex closure return type; add explicit type to disambiguate</code>。
在上面示例中，我们用 <code>value &#8594; String in</code> 明确指定了返回的类型。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可以将 Combine 的发布者、操作符和订阅者视为具有两种需要对齐的平行类型 —— 一种用于成功的有用值，另一种用于错误处理。
设计管道时经常会选择如何转换其中一种或两种类型以及与之相关的数据。</p>
</div>
<div style="page-break-after: always;"></div>
</div>
<div class="sect2">
<h3 id="coreconcepts-marblediagram">用弹珠图描述管道</h3>
<div class="paragraph">
<p>函数响应式编程的管道可能难以理解。
发布者生成和发送数据，操作符对该数据做出响应并有可能更改它，订阅者请求并接收这些数据。
这本身就很复杂，但 Combine 的一些操作符还可能改变事件发生的时序 —— 引入延迟、将多个值合并成一个值等等。
由于这些比较复杂可能难以理解，因此函数响应式编程社区使用一种称为 <strong>弹珠图</strong> 的视觉描述来说明这些变化。</p>
</div>
<div class="paragraph">
<p>在探索 Combine 背后的概念时，你可能会发现自己正在查看其他函数响应式编程系统，如 RxSwift 或 ReactiveExtensions。
与这些系统相关的文档通常使用弹珠图。</p>
</div>
<div class="paragraph">
<p>弹珠图侧重于描述特定的管道如何更改数据流。
它显示数据是如何随着时间的变化而变化的，以及这些变化的时序。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagrams/marble_diagram.svg" alt="marble diagram">
</div>
<div class="title">Figure 1. 一个弹珠图的示例</div>
</div>
<div class="sect3">
<h4 id="怎么看懂弹珠图">怎么看懂弹珠图:</h4>
<div class="ulist">
<ul>
<li>
<p>不管周围描述的是什么元素，在该例子的图上，中心是一个操作符。
具体的操作符的名称通常位于中心块上。</p>
</li>
<li>
<p>上面和下面的线表示随着时间移动的数据，
由左到右。
线上的符号表示离散着的数据。</p>
</li>
<li>
<p>我们通常假定数据正在向下流动。
在这种情况下，顶线表示对操作符的输入，底线表示输出。</p>
</li>
<li>
<p>在某些图表中，顶线上的符号可能与底线上的符号不同，
这时图表通常意味着输出的类型与输入的类型不同。</p>
</li>
<li>
<p>在有些图中，你也可能在时间线上看到竖线 “｜” 或 “ X ” 或终结时间线，
这用于表示数据流的结束。
时间线末端的竖线意味着数据流已正常终止。
“X” 表示抛出了错误或异常。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些图表有意忽略管道的配置，而倾向于关注一个元素来描述该元素的工作原理。</p>
</div>
</div>
<div class="sect3">
<h4 id="用弹珠图描述-combine">用弹珠图描述 Combine</h4>
<div class="paragraph">
<p>这本书对基本的弹珠图做了扩展并稍作修改，用来突出 Combine 的一些细节。
最显著的区别是输入和输出是两条线。
由于 Combine 明确了输入和失败类型，因此它们在图表中也被分开来单独表示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagrams/combine_marble_diagram.svg" alt="combine marble diagram">
</div>
<div class="title">Figure 2. 一个为 Combine 进行了扩展的特殊弹珠图</div>
</div>
<div class="paragraph">
<p>发布者的输出和失败类型，用上面的两条线来表示，然后数据经过操作符之后会流向下方。
操作符同时作为订阅者和发布者，处在中间，
订阅者接收的数据和失败类型，用下面的两条线来表示。</p>
</div>
<div class="paragraph">
<p>为了说明这些图表与代码的关系，让我们来看一个简单的示例。
在这个例子中，我们将关注 <code>map</code> 操作符以及如何用此图表描述它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="kt">Just</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">switch</span> <span class="n">value</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"none"</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"one"</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"couple"</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"few"</span>
        <span class="k">case</span> <span class="n">_</span> <span class="k">where</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"many"</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"some"</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">receivedValue</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"The end result was </span><span class="se">\(</span><span class="n">receivedValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>提供给 “.map()” 函数的闭包接收一个 <code>&lt;Int&gt;</code> 类型的值，并将其转换为 <code>&lt;String&gt;</code> 类型。
由于失败类型 <code>&lt;Never&gt;</code> 没有改变，因此直接输出它。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下图表表示了此代码片段。
此图描述了更详细的内容：它在图表中展示了闭包中的代码，以显示其关联性。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagrams/example_map_operator.svg" alt="map operator">
</div>
<div class="title">Figure 3. 上面代码中的 map 操作符示例</div>
</div>
<div class="paragraph">
<p>许多 Combine 的操作符都由你用一个闭包来配置。
大多数图表都不会将它包含在其中。
这意味着你通过 Combine 中的闭包提供的任何代码都将被简化成一个框，而不是详细的描述它。</p>
</div>
<div class="paragraph">
<p>此 <code>map</code> 操作符的输入类型为 <code>&lt;Int&gt;</code>，在最上面的线上用通用的语法进行表示。
传递给该操作符的失败类型为 <code>&lt;Never&gt;</code>，在输入类型的正下方用同一语法中表示。</p>
</div>
<div class="paragraph">
<p><code>map</code> 操作符没有更改或影响失败类型，只是将其进行了传递。
为了表示这一点，上面输入和下面输出的失败类型都用虚线来表示，以弱化它。</p>
</div>
<div class="paragraph">
<p>最上面的线上展示了单一输入值（<code>5</code>），
在这个例子中，它在线上的具体位置是没有意义的，仅表示它是单一值。
如果线上有多个值，则左侧的值将优于在右侧的任意值被发送给 <code>map</code> 操作符。</p>
</div>
<div class="paragraph">
<p>当值到达操作符时，值 <code>5</code> 作为变量的 <code>值</code> 传递给闭包。
这个例子中，闭包的返回类型（本例中为 <code>&lt;String&gt;</code> ）定义了当闭包中的代码完成并返回其值时 <code>map</code> 操作符的输出类型。
在这个例子中，输入了 <code>5</code> 然后返回了字符串 <code>some</code>。
字符串 <code>some</code> 展示在输入值正下方的输出线上，这意味着没有明显的延迟。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本书中的大多数图表不会像这个例子那样复杂或详细。
这些图表大多将侧重于描述操作符。
此图更复杂，是为了说明如何解释图表以及它们与你的代码之间的关系。</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect2">
<h3 id="coreconcepts-backpressure">Back pressure</h3>
<div class="paragraph">
<p>Combine 的设计使订阅者控制数据流，因此它也控制着在管道中处理数据的内容和时间。
这是一个在 Combine 中被叫做 <strong>back-pressure</strong> 的特性。</p>
</div>
<div class="paragraph">
<p>这意味着由订阅者通过提供其想要或能够接受多少信息量来推动管道内数据的处理。
当订阅者连接到发布者时，它会基于特定的 <a href="https://developer.apple.com/documentation/combine/subscribers/demand">需求</a> 去请求数据。</p>
</div>
<div class="paragraph">
<p>特定需求的请求通过组成管道进行传递。
每个操作符依次接受数据请求，然后请求与之相连的发布者提供信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 Combine 框架的第一个版本中（ iOS 13.3 和 macOS 10.15.2 之前），当订阅者请求具有特定需求的数据时，该请求是异步发生的。
由于此过程中是充当触发器的订阅者，去触发其连接的操作符，并最终触发发布者去请求数据，因此这意味着在某些情况下存在数据丢失的可能性。
因此，在 iOS 13.3 和以后的 Combine 版本中，请求的过程被改成了同步/阻塞线程的。
实际上，这意味着在发布者收到发送数据的请求之前，你可以更确信后序的管道已经完全准备好处理接下来的数据了。</p>
</div>
<div class="paragraph">
<p>如果你有兴趣阅读相关的更新历史，在 Swift 论坛上由关于此主题的 <a href="https://forums.swift.org/t/combine-receive-on-runloop-main-loses-sent-value-how-can-i-make-it-work/28631/39">延伸讨论</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有了订阅者驱动数据流这个特性，它允许 Combine 去取消这个过程。
订阅者均遵循 <a href="https://developer.apple.com/documentation/combine/cancellable">Cancellable</a> 协议。
这意味着它们都有一个 <code>cancel()</code> 函数，可以调用该函数来终止管道并停止所有相关处理。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当管道被取消时，管道是不期望被重新启动的。
相比于重启一个被取消的管道，开发者更应该去创建一个新的管道。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="coreconcepts-lifecycle">发布者和订阅者的生命周期</h3>
<div class="paragraph">
<p>订阅者和发布者以明确定义的顺序进行通信，因此使得它们具有从开始到结束的生命周期：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diagrams/combine_lifecycle_diagram.svg" alt="combine lifecycle diagram">
</div>
<div class="title">Figure 4. 一个 Combine 管道的生命周期</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>当调用 <code>.subscribe(_: Subscriber)</code> 时，订阅者被连接到了发布者。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>发布者随后调用 <code>receive(subscription: Subscription)</code> 来确认该订阅。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在订阅被确认后，订阅者请求 <em>N</em> 个值，此时调用 <code>request(_: Demand)</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>发布者可能随后（当它有值时）发送 <em>N</em> 个或者更少的值，通过调用 <code>receive(_: Input)</code>。
发布者不会发送<strong>超过</strong>需求量的值。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>订阅确认后的任何时间，订阅者都可能调用 <code>.cancel()</code> 来发送 <a href="https://developer.apple.com/documentation/combine/subscribers/completion">cancellation</a></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>发布者可以选择性地发送 <a href="https://developer.apple.com/documentation/combine/subscribers/completion">completion</a>：<code>receive(completion:)</code>。
完成可以是正常终止，也可以是通过 <code>.failure</code> 完成，可选地传递一个错误类型。
已取消的管道不会发送任何完成事件。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在上述图表中包含了一组堆积起来的弹珠图，
这是为了突出 Combine 的弹珠图在管道的整体生命周期中的重点。
通常，图表推断所有的连接配置都已完成并已发送了数据请求。
Combine 的弹珠图的核心是从请求数据到触发任何完成或取消之间的一系列事件。</p>
</div>
</div>
<div class="sect2">
<h3 id="coreconcepts-publishers">发布者</h3>
<div class="paragraph">
<p>发布者是数据的提供者。
当订阅者请求数据时， <a href="https://developer.apple.com/documentation/combine/publisher">publisher protocol</a> 有严格的返回值类型约定，并有一系列明确的完成信号可能会终止它。</p>
</div>
<div class="paragraph">
<p>你可以从 <a href="#reference-just">Just</a> 和 <a href="#reference-future">Future</a> 开始使用发布者，它们分别作为单一数据源和异步函数来使用。</p>
</div>
<div class="paragraph">
<p>当订阅者发出请求时，许多发布者会立即提供数据。
在某些情况下，发布者可能有一个单独的机制，使其能够在订阅后返回数据。
这是由协议 <a href="https://developer.apple.com/documentation/combine/connectablepublisher">ConnectablePublisher</a> 来约定实现的。
遵循 <code>ConnectablePublisher</code> 的发布者将有一个额外的机制，在订阅者发出请求后才启动数据流。
这可能是对发布者单独的调用 <code>.connect()</code> 来完成。
另一种可能是 <code>.autoconnect()</code>，一旦订阅者请求，它将立即启动数据流。</p>
</div>
<div class="paragraph">
<p>Combine 提供了一些额外的便捷的发布者：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-just">Just</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-future">Future</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-deferred">Deferred</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-empty">Empty</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-sequence">Sequence</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-fail">Fail</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-record">Record</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-share">Share</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-multicast">Multicast</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-observableobject">ObservableObject</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-published">@Published</a></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Combine 之外的一些 Apple API 也提供发布者。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-swiftui">SwiftUI</a> 使用 <code>@Published</code> 和 <code>@ObservedObject</code> 属性包装，由 Combine 提供，含蓄地创建了一个发布者，用来支持它的声明式 UI 的机制。</p>
</li>
<li>
<p>Foundation</p>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a></p>
</li>
<li>
<p><a href="#reference-kvo-publisher">.publisher on KVO instance</a></p>
</li>
<li>
<p><a href="#reference-notificationcenter">NotificationCenter</a></p>
</li>
<li>
<p><a href="#reference-timer">Timer</a></p>
</li>
<li>
<p><a href="#reference-result">Result</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="coreconcepts-operators">操作符</h3>
<div class="paragraph">
<p>操作符是 Apple 参考文档中发布者下包含的一些预构建函数的便捷名称。
操作符用来组合成管道。
许多操作符会接受开发人员的一个或多个闭包，以定义业务逻辑，同时保持并持有发布者/订阅者的生命周期。</p>
</div>
<div class="paragraph">
<p>一些操作符支持合并来自不同管道的输出、更改数据的时序或过滤所提供的数据。
操作符可能还会对操作类型有限制，
还可用于定义错误处理和重试逻辑、缓冲和预先载入以及支持调试。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Mapping elements</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-scan">scan</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-tryscan">tryScan</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-setfailuretype">setFailureType</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-map">map</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-trymap">tryMap</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-flatmap">flatMap</a></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Filtering elements</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-compactmap">compactMap</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-trycompactmap">tryCompactMap</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-replaceempty">replaceEmpty</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-filter">filter</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-tryfilter">tryFilter</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-replaceerror">replaceError</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-removeduplicates">removeDuplicates</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-tryremoveduplicates">tryRemoveDuplicates</a></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Reducing elements</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-collect">collect</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-reduce">reduce</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-tryreduce">tryReduce</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-ignoreoutput">ignoreOutput</a></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Mathematic operations on elements</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-max">max</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-trymax">tryMax</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-count">count</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-min">min</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-min">tryMin</a></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Applying matching criteria to elements</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-allsatisfy">allSatisfy</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-tryallsatisfy">tryAllSatisfy</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-contains">contains</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-containswhere">containsWhere</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-trycontainswhere">tryContainsWhere</a></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Applying sequence operations to elements</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-firstwhere">firstWhere</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-tryfirstwhere">tryFirstWhere</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-first">first</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-lastwhere">lastWhere</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-trylastwhere">tryLastWhere</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-last">last</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-dropwhile">dropWhile</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-trydropwhile">tryDropWhile</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-dropuntiloutput">dropUntilOutput</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-prepend">prepend</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-drop">drop</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-prefixuntiloutput">prefixUntilOutput</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-prefixwhile">prefixWhile</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-tryprefixwhile">tryPrefixWhile</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-output">output</a></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Combining elements from multiple publishers</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-combinelatest">combineLatest</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-merge">merge</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-zip">zip</a></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Handling errors</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-catch">catch</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-trycatch">tryCatch</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-assertnofailure">assertNoFailure</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-retry">retry</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-maperror">mapError</a></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Adapting publisher types</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-switchtolatest">switchToLatest</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-erasetoanypublisher">eraseToAnyPublisher</a></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Controlling timing</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-debounce">debounce</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-delay">delay</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-measureinterval">measureInterval</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-throttle">throttle</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-timeout">timeout</a></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Encoding and decoding</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-encode">encode</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-decode">decode</a></p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Working with multiple subscribers</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-multicast">multicast</a></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><p class="tableblock">Debugging</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-breakpoint">breakpoint</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-handleevents">handleEvents</a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#reference-print">print</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="coreconcepts-subjects">Subjects</h3>
<div class="paragraph">
<p>Subjects 是一种遵循 <a href="https://developer.apple.com/documentation/combine/subject"><code>Subject</code></a> 协议的特殊的发布者。
这个协议要求 subjects 有一个 <code>.send(_:)</code> 方法，来允许开发者发送特定的值给订阅者或管道。</p>
</div>
<div class="paragraph">
<p>Subjects 可以通过调用 <code>.send(_:)</code> 方法来将值“注入”到流中，
这对于将现有的命令式的代码与 Combine 集成非常有用。</p>
</div>
<div class="paragraph">
<p>一个 subject 还可以向多个订阅者广播消息。
如果多个订阅者连接到一个 subject，它将在调用 <code>send(_:)</code> 时向多个订阅者发送值。
一个 subject 还经常用于连接或串联多个管道，特别是同时给多个管道发送值时。</p>
</div>
<div class="paragraph">
<p>Subject 不会盲目地传递其订阅者的需求。
相反，它为需求提供了一个聚合点。
在没有收到订阅消息之前，一个 subject 不会向其连接的发布者发出需求信号。
当它收到订阅者的需求时，它会向它连接的发布者发出 <code>unlimited</code> 需求信号。
虽然 subject 支持多个订阅者，但任何未请求数据的订阅者，在请求之前均不会给它们提供数据。</p>
</div>
<div class="paragraph">
<p>Combine 中有两种内建的 subject : <a href="#reference-currentvaluesubject">CurrentValueSubject</a> 和 <a href="#reference-passthroughsubject">PassthroughSubject</a>。
它们的行为类似，但不同的是 <code>CurrentValueSubject</code> 需要一个初始值并记住它当前的值，<code>PassthroughSubject</code> 则不会。
当调用 <code>.send()</code> 时，两者都将向它们的订阅者提供更新的值。</p>
</div>
<div class="paragraph">
<p>在给遵循  <a href="https://developer.apple.com/documentation/combine/observableobject"><code>ObservableObject</code></a> 协议的对象创建发布者时，<code>CurrentValueSubject</code> 和 <code>PassthroughSubject</code> 也很有用。
SwiftUI 中的多个声明式组件都遵循这个协议。</p>
</div>
</div>
<div class="sect2">
<h3 id="coreconcepts-subscribers">订阅者</h3>
<div class="paragraph">
<p>虽然 <a href="https://developer.apple.com/documentation/combine/subscriber"><code>Subscriber</code></a> 是用于接收整个管道数据的协议，但通常 <em>the subscriber</em> 指的是管道的末端。</p>
</div>
<div class="paragraph">
<p>Combine 中有两个内建的订阅者： <a href="#reference-assign">Assign</a> 和 <a href="#reference-sink">Sink</a>。
SwiftUI 中有一个订阅者： <a href="#reference-onreceive">onReceive</a>。</p>
</div>
<div class="paragraph">
<p>订阅者支持取消操作，取消时将终止订阅关系以及所有流完成之前，由发布者发送的数据。
<code>Assign</code> 和 <code>Sink</code> 都遵循 <a href="https://developer.apple.com/documentation/combine/cancellable">Cancellable 协议</a>.</p>
</div>
<div class="paragraph">
<p>当你存储和自己订阅者的引用以便稍后清理时，你通常希望引用销毁时能自己取消订阅。
<a href="#reference-anycancellable">AnyCancellable</a> 提供类型擦除的引用，可以将任何订阅者转换为 <code>AnyCancellable</code> 类型，允许在该引用上使用 <code>.cancel()</code>，但无法访问订阅者本身（对于实例来说可以，但是需要更多数据）。
存储对订阅者的引用非常重要，因为当引用被释放销毁时，它将隐含地取消其操作。</p>
</div>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/combine/subscribers/assign"><code>Assign</code></a> 将从发布者传下来的值应用到由 keypath 定义的对象，
keypath 在创建管道时被设置。
一个在 Swift 中的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">isEnabled</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">signupButton</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/combine/subscribers/sink"><code>Sink</code></a> 接受一个闭包，该闭包接收从发布者发送的任何结果值。
这允许开发人员使用自己的代码终止管道。
此订阅者在编写单元测试以验证发布者或管道时也非常有帮助。
一个在 Swift 中的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">receivedValue</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The end result was </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">receivedValue</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>其他订阅者是其他 Apple 框架的一部分。
例如，SwiftUI 中的几乎每个 <code>control</code> 都可以充当订阅者。
SwiftUI 中的 <a href="https://developer.apple.com/documentation/swiftui/view/">View 协议</a> 定义了一个 <code>.onReceive(publisher)</code> 函数，可以把视图当作订阅者使用。
<code>onReceive</code> 函数接受一个类似于 <code>sink</code> 接受的闭包，可以操纵 SwiftUI 中的 <code>@State</code> 或 <code>@Bindings</code>。</p>
</div>
<div class="paragraph">
<p>一个在 SwiftUI 中的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">MyView</span> <span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>

    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">currentStatusValue</span> <span class="o">=</span> <span class="s">"ok"</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"Current status: </span><span class="se">\(</span><span class="n">currentStatusValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">onReceive</span><span class="p">(</span><span class="kt">MyPublisher</span><span class="o">.</span><span class="n">currentStatusPublisher</span><span class="p">)</span> <span class="p">{</span> <span class="n">newStatus</span> <span class="k">in</span>
                <span class="k">self</span><span class="o">.</span><span class="n">currentStatusValue</span> <span class="o">=</span> <span class="n">newStatus</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于任何类型的 UI 对象 (UIKit、AppKit 或者 SwiftUI)， <a href="#reference-assign">Assign</a> 可以在管道中使用来更新其属性。</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="developingwith">使用 Combine 进行开发</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通常从利用现有的发布者、操作符和订阅者来组成管道开始。
本书中的许多示例突出了各种模式，其中许多模式旨在对界面内的用户输入提供声明性响应。</p>
</div>
<div class="paragraph">
<p>你可能还希望创建更容易集成到 Combine 的 API。
例如，创建一个封装远程 API 的发布者，返回单个结果或一系列结果。
或者，你可能正在创建一个订阅者来随着时间的推移去处理和消费数据。</p>
</div>
<div class="sect2">
<h3 id="关于管道运用的思考">关于管道运用的思考</h3>
<div class="paragraph">
<p>在用 Combine 进行开发时，有两种更广泛的发布者模式经常出现：期望发布者返回单一的值并完成，和期望发布者随着时间的推移返回多个值。</p>
</div>
<div class="paragraph">
<p>我把第一个称作 “one-shot”（一次性）的发布者或管道。
这些发布者会创建单个响应（或者可能没有响应），然后正常终止。</p>
</div>
<div class="paragraph">
<p>我把第二个称作 “continuous”（连续）的发布者。
这些发布者和相关管道应始终处于活动状态，并提供处理持续事件的方法。
在这种情况下，管道的寿命要长得多，而且通常不希望此类管道发生失败或终止。</p>
</div>
<div class="paragraph">
<p>当你在考虑如何使用 Combine 进行开发时，把管道视作这两个类型之一，并把它们混合在一起以实现你的目标，往往是很有帮助的。
例如，模式 <a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a> 明确地在不间断的管道中使用一次性的管道来处理错误。</p>
</div>
<div class="paragraph">
<p>当你创建发布者或管道的实例时，好好思考你希望它如何工作是值得的 —— 要么是一次性的，要么是连续的。
你的选择将关系到你如何处理错误，或者你是否要处理操纵事件时序的操作符 (例如 <a href="#reference-debounce">debounce</a> 或者 <a href="#reference-throttle">throttle</a>).</p>
</div>
<div class="paragraph">
<p>除了管道或发布者将提供多少数据外，你还经常需要考虑管道将提供哪种类型对。
许多管道更多的是通过各种类型转换数据，并处理该过程中可能出现的错误情况。
该情况的一个例子是返回一个管道，在管道中如例子 <a href="#patterns-update-interface-userinput">通过用户输入更新声明式 UI</a> 所示返回一个列表，以提供一种表示“空”结果的方法，即使列表中永远不会有超过 1 个元素。</p>
</div>
<div class="paragraph">
<p>最终，使用 Combine 来连接两端的数据：当数据可用时，由原始的发布者发送它们，然后订阅者最终消费数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="developingwith-types">Combine 发布者和订阅者涉及到的 Swift 类型</h3>
<div class="paragraph">
<p>当你在 Swift 中构建管道时，函数链导致该类型被聚合为嵌套的通用类型。
如果你正在创建一个管道，然后想要将该管道作为 API 提供给代码的另一部分，则对于开发人员来说，暴露的属性或函数的类型定义可能异常复杂且毫无用处。</p>
</div>
<div class="paragraph">
<p>为了说明暴露的类型复杂性，如果你从 PassthroughSubject 创建了一个发布者，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">name</span> <span class="k">in</span>
        <span class="k">return</span> <span class="kt">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">promise</span> <span class="k">in</span>
            <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="s">""</span><span class="p">))</span>
            <span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
                <span class="kt">Just</span><span class="p">(</span><span class="s">"No user found"</span><span class="p">)</span>
            <span class="p">}</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
                <span class="k">return</span> <span class="s">"</span><span class="se">\(</span><span class="n">result</span><span class="se">)</span><span class="s"> foo"</span>
        <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>结果的类型是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kt">Publishers</span><span class="o">.</span><span class="kt">FlatMap</span><span class="o">&lt;</span><span class="kt">Publishers</span><span class="o">.</span><span class="kt">Map</span><span class="o">&lt;</span><span class="kt">Publishers</span><span class="o">.</span><span class="kt">Catch</span><span class="o">&lt;</span><span class="kt">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Just</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当你想要暴露这个 subject 时，所有这些混合的细节可能会让你感到非常迷惑，使你的代码更难使用。</p>
</div>
<div class="paragraph">
<p>为了清理该接口，并提供一个好用的 API，可以使用类型擦除类来包装发布者或订阅者。
这样明确隐藏了 Swift 中从链式函数中构建的类型复杂性。</p>
</div>
<div class="paragraph">
<p>用于为订阅者和发布者暴露简化类型的两个类是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/combine/anysubscriber">AnySubscriber</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/anypublisher">AnyPublisher</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每个发布者还继承了一种便利的方法 <code>eraseToAnyPublisher()</code>，它返回一个 <code>AnyPublisher</code> 实例。
<code>eraseToAnyPublisher()</code> 的使用非常像操作符，通常作为链式管道中的最后一个元素，以简化返回的类型。</p>
</div>
<div class="paragraph">
<p>如果你在上述代码的管道末尾添加 <code>.eraseToAnyPublisher()</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">name</span> <span class="k">in</span>
        <span class="k">return</span> <span class="kt">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">promise</span> <span class="k">in</span>
            <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="s">""</span><span class="p">))</span>
            <span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
                <span class="kt">Just</span><span class="p">(</span><span class="s">"No user found"</span><span class="p">)</span>
            <span class="p">}</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
                <span class="k">return</span> <span class="s">"</span><span class="se">\(</span><span class="n">result</span><span class="se">)</span><span class="s"> foo"</span>
        <span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>结果的类型将被简化为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的技术在闭包内构造较小的管道时将非常有用。
例如，当你想在闭包中给操作符 <a href="#reference-flatmap">flatMap</a> 返回一个发布者时，你可以通过明确的声明闭包应返回 <code>AnyPublisher</code> 来获得更简单的类型推断。
可以在模式 <a href="#patterns-sequencing-operations">有序的异步操作</a> 中找到这样的一个例子。</p>
</div>
</div>
<div class="sect2">
<h3 id="developingwith-threads">管道和线程</h3>
<div class="paragraph">
<p>Combine 不是一个单线程的结构。
操作符和发布者可以在不同的调度队列或 runloops 中运行。
构建的管道可以在单个队列中，也可以跨多个队列或线程传输数据。</p>
</div>
<div class="paragraph">
<p>Combine 允许发布者指定线程调度器，不论是从上游的发布者（操作符）接收数据或者向下游的订阅者发送数据，都使用它调度到指定线程。
在与更新 UI 元素的订阅者配合使用时，这一点至关重要，因为更新 UI 始终应该在主线程上。</p>
</div>
<div class="paragraph">
<p>例如，你可能在代码中看到这样的操作符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>许多操作符可以修改用于进行相关处理的线程或队列。
<a href="#reference-receive">receive</a> 和 <a href="#reference-subscribe">subscribe</a> 是最常见的两个，它们分别负责把调用操作符之后和之前的执行代码调度到对应的线程。</p>
</div>
<div class="paragraph">
<p>许多其他操作符的参数也包括调度器。
例如 <a href="#reference-delay">delay</a>, <a href="#reference-debounce">debounce</a>, 和 <a href="#reference-throttle">throttle</a>.
这些也会对执行代码的队列产生影响 - 无论是对自己，还是对于后续在管道中执行的任何操作符。
这些操作符都使用 <code>scheduler</code> 参数，来切换到相应的线程或队列以完成工作。
任何后面连接着他们的操作符也会在其调度器上被调用，从而产生一些影响，如 <a href="#reference-receive">receive</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你想明确指定操作符或后续的操作在哪个线程环境中运行，可以使用 <a href="#reference-receive">receive</a>  操作符。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="把-combine-运用到你的开发中">把 Combine 运用到你的开发中</h3>
<div class="paragraph">
<p>通常有两种途径使用 Combine 来进行开发：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，简单的使用是把你闭包中的同步调用改成一个操作符。
最普遍的两个操作符是 <a href="#reference-map">map</a> 和 <a href="#reference-trymap">tryMap</a>，后者是当你的代码需要抛出错误时使用。</p>
</li>
<li>
<p>第二是集成你自己的代码，即提供完成回调的异步代码或 API。
如果你集成的代码是异步的，则大概无法在闭合内轻松地使用它。
你需要将异步代码包装成一个 Combine 操作符可以配合和调用的结构。
在实践中，这通常意味着需要创建一个发布者的实例，然后在管道中使用它。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#reference-future">Future</a> 发布者是专门用来支持这类集成的, 在模式 <a href="#patterns-future">用 Future 来封装异步请求以创建一次性的发布者</a> 中有一个这样的示例。</p>
</div>
<div class="paragraph">
<p>如果你想使用发布者提供的数据作为创建此发布者的参数或输入，则有两种通用的方法可以这么做：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用 <a href="#reference-flatmap">flatMap</a> 操作符, 使用传入的数据创建或返回发布者实例。
这是模式 <a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a> 的一种变体。</p>
</li>
<li>
<p>或者，<a href="#reference-map">map</a> 或 <a href="#reference-trymap">tryMap</a> 可被用做创建发布者实例，紧跟 <a href="#reference-switchtolatest">switchToLatest</a> 链将该发布者解析为将在管道内传递的值。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="#patterns-cascading-update-interface">级联多个 UI 更新，包括网络请求</a> 和 <a href="#patterns-update-interface-userinput">通过用户输入更新声明式 UI</a> 模式说明了这种使用方法。</p>
</div>
<div class="paragraph">
<p>你可能会发现创建返回发布者的对象是值得的。
这通常使你的代码能够封装与远程或基于网络的 API 通信的详细信息。
可以使用 <a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a> 或你自己的代码进行开发。
在模式 <a href="#patterns-cascading-update-interface">级联多个 UI 更新，包括网络请求</a> 中详细介绍了这方面的一个简单的示例。</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="patterns">常用模式和方法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章包括一系列模式和发布者、订阅者和管道的示例。
这些示例旨在说明如何使用 Combine 框架完成各种任务。</p>
</div>
<div class="sect2">
<h3 id="patterns-sink-subscriber">使用 sink 创建一个订阅者</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>要接收来自发布者或管道生成的输出以及错误或者完成消息，你可以使用 <a href="#reference-sink">sink</a> 创建一个订阅者。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-sink">sink</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-assign-subscriber">使用 assign 创建一个订阅者</a></p>
</li>
<li>
<p><a href="#patterns-testing-publisher">使用 XCTestExpectation 测试发布者</a></p>
</li>
<li>
<p><a href="#patterns-testing-subscriber-scheduled">使用从 PassthroughSubject 预定好的发送的事件测试订阅者</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>Sink 创建了一个通用订阅者来捕获或响应来自 Combine 管道的数据，同时支持取消和 <a href="#coreconcepts-lifecycle">发布者和订阅者的生命周期</a>。</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="title">简单的 sink 例子</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">cancellablePipeline</span> <span class="o">=</span> <span class="n">publishingSource</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">someValue</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="c1">// do what you want with the resulting value passed down</span>
    <span class="c1">// be aware that depending on the publisher, this closure</span>
    <span class="c1">// may be invoked multiple times.</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received </span><span class="se">\(</span><span class="n">someValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">})</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>简单版本的 sink 是非常简洁的，跟了一个尾随闭包来接收从管道发送来的数据。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">带有完成事件和数据的 sink</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">cancellablePipeline</span> <span class="o">=</span> <span class="n">publishingSource</span><span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">switch</span> <span class="n">completion</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">finished</span><span class="p">:</span>
        <span class="c1">// no associated data, but you can react to knowing the</span>
        <span class="c1">// request has been completed</span>
        <span class="k">break</span>
    <span class="k">case</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="k">let</span> <span class="nv">anError</span><span class="p">):</span>
        <span class="c1">// do what you want with the error details, presenting,</span>
        <span class="c1">// logging, or hiding as appropriate</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"received the error: "</span><span class="p">,</span> <span class="n">anError</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">someValue</span> <span class="k">in</span>
    <span class="c1">// do what you want with the resulting value passed down</span>
    <span class="c1">// be aware that depending on the publisher, this closure</span>
    <span class="c1">// may be invoked multiple times.</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received </span><span class="se">\(</span><span class="n">someValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">})</span>

<span class="n">cancellablePipeline</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Sinks 是通过发布者或管道中的代码链创建的，并为管道提供终点。
当 sink 在发布者创建或调用时，它通过 <code>subscribe</code> 方法隐式地开始了 <a href="#coreconcepts-lifecycle">发布者和订阅者的生命周期</a>，并请求无限制的数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Sinks 是可取消的订阅者。在任何时候，你可以使用 sink 末端对其的引用，并在上面调用 <code>.cancel()</code> 来使管道失效并关闭管道。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect2">
<h3 id="patterns-assign-subscriber">使用 assign 创建一个订阅者</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>使用管道的结果来设置值，这个值通常是位于用户界面或控制组件上的属性，不过任何符合 KVO 的对象都可以提供该值。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-assign">assign</a></p>
</li>
<li>
<p><a href="#reference-receive">receive</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-sink-subscriber">使用 sink 创建一个订阅者</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>Assign 是专门设计用于将来自发布者或管道的数据应用到属性的订阅者，每当它收到数据时都会更新该属性。
与 sink 一样，它创建时激活并请求无限数据。
Assign 要求将失败类型指定为 <code>&lt;Never&gt;</code>，因此，如果你的管道可能失败（例如使用 tryMap 等操作符），则需要在使用 <code>.assign</code> 之前 <a href="#patterns-general-error-handling">错误处理</a>。</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="title">简单的 assign 例子</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">cancellablePipeline</span> <span class="o">=</span> <span class="n">publishingSource</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">isEnabled</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">yourButton</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="n">cancellablePipeline</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span> <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>.assign</code> 通常在创建时链接到发布者，并且返回值是可取消的。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果 <code>.assign</code> 被用于更新用户界面的元素，则需要确保在主线程更新它。这个调用确保了订阅者是在主线程上接收数据的。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Assign 持有对使用 <a href="https://developer.apple.com/documentation/swift/referencewritablekeypath">key path</a> 更新的属性的引用，以及对正在更新的对象的引用。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在任何时候，你都可以调用 <code>cancel()</code> 终止和使管道失效。通常，当把从管道中更新的对象（如 viewController）销毁时，我们会取消管道。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect2">
<h3 id="patterns-datataskpublisher-decode">使用 dataTaskPublisher 发起网络请求</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>一个常见的用例是从 URL 请求 JSON 数据并解码。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a></p>
</li>
<li>
<p><a href="#reference-map">map</a></p>
</li>
<li>
<p><a href="#reference-decode">decode</a></p>
</li>
<li>
<p><a href="#reference-sink">sink</a></p>
</li>
<li>
<p><a href="#reference-subscribe">subscribe</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-datataskpublisher-trymap">使用 dataTaskPublisher 进行更严格的请求处理</a></p>
</li>
<li>
<p><a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a></p>
</li>
<li>
<p><a href="#patterns-retry">在发生暂时失败时重试</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>这可以通过使用 Combine 的 <a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a> 搭配一系列处理数据的操作符来轻松完成。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>最简单的，调用 <a href="https://developer.apple.com/documentation/foundation/urlsession">URLSession</a> 的 <a href="https://developer.apple.com/documentation/foundation/urlsession/3329708-datataskpublisher">dataTaskPublisher</a>，然后在数据到达订阅者之前使用 <a href="#reference-map">map</a> 和 <a href="#reference-decode">decode</a>。</p>
</div>
<div class="paragraph">
<p>使用此操作的最简单例子可能是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">myURL</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"https://postman-echo.com/time/valid?timestamp=2016-10-10"</span><span class="p">)</span>
<span class="c1">// checks the validity of a timestamp - this one returns {"valid":true}</span>
<span class="c1">// matching the data structure returned from https://postman-echo.com/time/valid</span>
<span class="kd">fileprivate</span> <span class="kd">struct</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="p">:</span> <span class="kt">Decodable</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">let</span> <span class="nv">valid</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">remoteDataPublisher</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">myURL</span><span class="o">!</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="c1">// the dataTaskPublisher output combination is (data: Data, response: URLResponse)</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">data</span> <span class="p">}</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">JSONDecoder</span><span class="p">())</span> <i class="conum" data-value="4"></i><b>(4)</b>

<span class="k">let</span> <span class="nv">cancellableSink</span> <span class="o">=</span> <span class="n">remoteDataPublisher</span>
    <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received the completion"</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">completion</span><span class="p">))</span>
            <span class="k">switch</span> <span class="n">completion</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">.</span><span class="nv">finished</span><span class="p">:</span> <i class="conum" data-value="5"></i><b>(5)</b>
                    <span class="k">break</span>
                <span class="k">case</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="k">let</span> <span class="nv">anError</span><span class="p">):</span> <i class="conum" data-value="6"></i><b>(6)</b>
                    <span class="nf">print</span><span class="p">(</span><span class="s">"received error: "</span><span class="p">,</span> <span class="n">anError</span><span class="p">)</span>
            <span class="p">}</span>
    <span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">someValue</span> <span class="k">in</span> <i class="conum" data-value="7"></i><b>(7)</b>
        <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received </span><span class="se">\(</span><span class="n">someValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">})</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>通常，你将有一个结构体的定义，至少遵循 <a href="https://developer.apple.com/documentation/swift/decodable">Decodable</a> 协议（即使没有完全遵循 <a href="https://developer.apple.com/documentation/swift/codable">Codable protocol</a>）。此结构体可以只定义从网络拉取到的 JSON 中你感兴趣的字段。
不需要定义完整的 JSON 结构。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>dataTaskPublisher</code> 是从 <code>URLSession</code> 实例化的。 你可以配置你自己的 <code>URLSession</code>，或者使用 shared session.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回的数据是一个元组：<code>(data: Data, response: URLResponse)</code>。
<a href="#reference-map">map</a> 操作符用来获取数据并丢弃 <code>URLResponse</code>，只把 <code>Data</code> 沿管道向下传递。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><a href="#reference-decode">decode</a> 用于加载数据并尝试解析它。
如果解码失败，它会抛出一个错误。
如果它成功，通过管道传递的对象将是来自 JSON 数据的结构体。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>如果解码完成且没有错误，则将触发完成操作，并将值传递给 <code>receiveValue</code> 闭包。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>如果发生失败（无论是网络请求还是解码），则错误将被传递到 <code>failure</code> 闭包。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>只有当数据请求并解码成功时，才会调用此闭包，并且收到的数据格式将是结构体 <code>PostmanEchoTimeStampCheckResponse</code> 的实例。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect2">
<h3 id="patterns-datataskpublisher-trymap">使用 dataTaskPublisher 进行更严格的请求处理</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>当 URLSesion 进行连接时，它仅在远程服务器未响应时报告错误。
你可能需要根据状态码将各种响应视为不同的错误。
为此，你可以使用 tryMap 检查 http 响应并在管道中抛出错误。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a></p>
</li>
<li>
<p><a href="#reference-trymap">tryMap</a></p>
</li>
<li>
<p><a href="#reference-decode">decode</a></p>
</li>
<li>
<p><a href="#reference-sink">sink</a></p>
</li>
<li>
<p><a href="#reference-subscribe">subscribe</a></p>
</li>
<li>
<p><a href="#reference-maperror">mapError</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-datataskpublisher-decode">使用 dataTaskPublisher 发起网络请求</a></p>
</li>
<li>
<p><a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a></p>
</li>
<li>
<p><a href="#patterns-retry">在发生暂时失败时重试</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>要对 URL 响应中被认为是失败的操作进行更多控制，可以对 <code>dataTaskPublisher</code> 的元组响应使用 <code>tryMap</code> 操作符。
由于 <code>dataTaskPublisher</code> 将响应数据和 <code>URLResponse</code> 都返回到了管道中，你可以立即检查响应，并在需要时抛出自己的错误。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这方面的一个例子可能看起来像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">myURL</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"https://postman-echo.com/time/valid?timestamp=2016-10-10"</span><span class="p">)</span>
<span class="c1">// checks the validity of a timestamp - this one returns {"valid":true}</span>
<span class="c1">// matching the data structure returned from https://postman-echo.com/time/valid</span>
<span class="kd">fileprivate</span> <span class="kd">struct</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="p">:</span> <span class="kt">Decodable</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">valid</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>
<span class="kd">enum</span> <span class="kt">TestFailureCondition</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">invalidServerResponse</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">remoteDataPublisher</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">myURL</span><span class="o">!</span><span class="p">)</span>
    <span class="o">.</span><span class="n">tryMap</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">httpResponse</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
                    <span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">200</span> <span class="k">else</span> <span class="p">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
                        <span class="k">throw</span> <span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">invalidServerResponse</span> <i class="conum" data-value="4"></i><b>(4)</b>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">data</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">JSONDecoder</span><span class="p">())</span>

<span class="k">let</span> <span class="nv">cancellableSink</span> <span class="o">=</span> <span class="n">remoteDataPublisher</span>
    <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received the completion"</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">completion</span><span class="p">))</span>
            <span class="k">switch</span> <span class="n">completion</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">.</span><span class="nv">finished</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">case</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="k">let</span> <span class="nv">anError</span><span class="p">):</span>
                    <span class="nf">print</span><span class="p">(</span><span class="s">"received error: "</span><span class="p">,</span> <span class="n">anError</span><span class="p">)</span>
            <span class="p">}</span>
    <span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">someValue</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received </span><span class="se">\(</span><span class="n">someValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <a href="#patterns-datataskpublisher-decode">上个模式</a> 中使用了 <a href="#reference-map">map</a> 操作符， 这里我们使用 tryMap，这使我们能够根据返回的内容识别并在管道中抛出错误。</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="#reference-trymap">tryMap</a> 仍旧获得元组 <code>(data: Data, response: URLResponse)</code>，并且在这里定义仅返回管道中的 Data 类型。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在 <code>tryMap</code> 的闭包内，我们将响应转换为 <code>HTTPURLResponse</code> 并深入进去，包括查看特定的状态码。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在这个例子中，我们希望将 200 状态码以外的<strong>任何</strong>响应视为失败。<code>HTTPURLResponse</code>.<code>statusCode</code> 是一种 Int 类型，因此你也可以使用 <code>httpResponse.statusCode &gt; 300</code> 等逻辑。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>如果判断条件未满足，则会抛出我们选择的错误实例：在这个例子中，是 <code>invalidServerResponse</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>如果没有出现错误，则我们只需传递 <code>Data</code> 以进行进一步处理。</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="标准化-datataskpublisher-返回的错误">标准化 dataTaskPublisher 返回的错误</h4>
<div class="paragraph">
<p>当在管道上触发错误时，不管错误发生在管道中的什么位置，都会发送 <code>.failure</code> 完成回调，并把错误封装在其中。</p>
</div>
<div class="paragraph">
<p>此模式可以扩展来返回一个发布者，该发布者使用此通用模式可接受并处理任意数量的特定错误。
在许多示例中，我们用默认值替换错误条件。
如果我们想要返回一个发布者的函数，该发布者不会根据失败来选择将发生什么，则同样 <a href="#reference-trymap">tryMap</a> 操作符可以与 <a href="#reference-maperror">mapError</a> 一起使用来转换响应对象以及转换 URLError 错误类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">enum</span> <span class="kt">APIError</span><span class="p">:</span> <span class="kt">Error</span><span class="p">,</span> <span class="kt">LocalizedError</span> <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">case</span> <span class="n">unknown</span><span class="p">,</span> <span class="nf">apiError</span><span class="p">(</span><span class="nv">reason</span><span class="p">:</span> <span class="kt">String</span><span class="p">),</span> <span class="nf">parserError</span><span class="p">(</span><span class="nv">reason</span><span class="p">:</span> <span class="kt">String</span><span class="p">),</span> <span class="nf">networkError</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="kt">URLError</span><span class="p">)</span>

    <span class="k">var</span> <span class="nv">errorDescription</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">unknown</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"Unknown error"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">apiError</span><span class="p">(</span><span class="k">let</span> <span class="nv">reason</span><span class="p">),</span> <span class="o">.</span><span class="nf">parserError</span><span class="p">(</span><span class="k">let</span> <span class="nv">reason</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reason</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">networkError</span><span class="p">(</span><span class="k">let</span> <span class="nv">from</span><span class="p">):</span> <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="k">return</span> <span class="n">from</span><span class="o">.</span><span class="n">localizedDescription</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">fetch</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">Data</span><span class="p">,</span> <span class="kt">APIError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">URLRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>

    <span class="k">return</span> <span class="kt">URLSession</span><span class="o">.</span><span class="kt">DataTaskPublisher</span><span class="p">(</span><span class="nv">request</span><span class="p">:</span> <span class="n">request</span><span class="p">,</span> <span class="nv">session</span><span class="p">:</span> <span class="o">.</span><span class="n">shared</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="o">.</span><span class="n">tryMap</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span> <span class="k">in</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">httpResponse</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">APIError</span><span class="o">.</span><span class="n">unknown</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">401</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">APIError</span><span class="o">.</span><span class="nf">apiError</span><span class="p">(</span><span class="nv">reason</span><span class="p">:</span> <span class="s">"Unauthorized"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">403</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">APIError</span><span class="o">.</span><span class="nf">apiError</span><span class="p">(</span><span class="nv">reason</span><span class="p">:</span> <span class="s">"Resource forbidden"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">404</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">APIError</span><span class="o">.</span><span class="nf">apiError</span><span class="p">(</span><span class="nv">reason</span><span class="p">:</span> <span class="s">"Resource not found"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="mi">405</span><span class="o">..&lt;</span><span class="mi">500</span> <span class="o">~=</span> <span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">APIError</span><span class="o">.</span><span class="nf">apiError</span><span class="p">(</span><span class="nv">reason</span><span class="p">:</span> <span class="s">"client error"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="mi">500</span><span class="o">..&lt;</span><span class="mi">600</span> <span class="o">~=</span> <span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">APIError</span><span class="o">.</span><span class="nf">apiError</span><span class="p">(</span><span class="nv">reason</span><span class="p">:</span> <span class="s">"server error"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="n">mapError</span> <span class="p">{</span> <span class="n">error</span> <span class="k">in</span> <i class="conum" data-value="5"></i><b>(5)</b>
            <span class="c1">// if it's our kind of error already, we can return it directly</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="k">as?</span> <span class="kt">APIError</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">error</span>
            <span class="p">}</span>
            <span class="c1">// if it is a TestExampleError, convert it into our new error type</span>
            <span class="k">if</span> <span class="n">error</span> <span class="k">is</span> <span class="kt">TestExampleError</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kt">APIError</span><span class="o">.</span><span class="nf">parserError</span><span class="p">(</span><span class="nv">reason</span><span class="p">:</span> <span class="s">"Our example error"</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// if it is a URLError, we can convert it into our more general error kind</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">urlerror</span> <span class="o">=</span> <span class="n">error</span> <span class="k">as?</span> <span class="kt">URLError</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kt">APIError</span><span class="o">.</span><span class="nf">networkError</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">urlerror</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// if all else fails, return the unknown error condition</span>
            <span class="k">return</span> <span class="kt">APIError</span><span class="o">.</span><span class="n">unknown</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span> <i class="conum" data-value="6"></i><b>(6)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>APIError</code> 是一个错误类型的枚举，我们在此示例中使用该枚举来列举可能发生的所有错误。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>.networkError</code> 是 <code>APIError</code> 的一个特定情况，当 <a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a> 返回错误时我们将把错误转换为该类型。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们使用标准 dataTaskPublisher 开始生成此发布者。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>然后，我们将路由到 <a href="#reference-trymap">tryMap</a> 操作符来检查响应，根据服务器响应创建特定的错误。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>最后，我们使用 <a href="#reference-maperror">mapError</a> 将任何其他不可忽视的错误类型转换为通用的错误类型 <code>APIError</code>。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="patterns-future">用 Future 来封装异步请求以创建一次性的发布者</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>使用 <code>Future</code> 将异步请求转换为发布者，以便在 Combine 管道中使用返回结果。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-future">Future</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-delegate-publisher-subject">通过包装基于 delegate 的 API 创建重复发布者</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">Contacts</span>
<span class="k">let</span> <span class="nv">futureAsyncPublisher</span> <span class="o">=</span> <span class="kt">Future</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">promise</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kt">CNContactStore</span><span class="p">()</span><span class="o">.</span><span class="nf">requestAccess</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">contacts</span><span class="p">)</span> <span class="p">{</span> <span class="n">grantedAccess</span><span class="p">,</span> <span class="n">err</span> <span class="k">in</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="c1">// err is an optional</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">err</span> <span class="o">=</span> <span class="n">err</span> <span class="p">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="k">return</span> <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">grantedAccess</span><span class="p">))</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Future</code> 本身由你定义返回类型，并接受一个闭包。
它给出一个与类型描述相匹配的 <code>Result</code> 对象，你可以与之交互。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>只要传入的闭包符合类型要求，任何异步的 API 你都可以调用。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在异步 API 完成的回调中，由你决定什么是失败还是成功。
对 <code>promise(.failure(&lt;FailureType&gt;))</code> 的调用返回一个失败的结果。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>或者调用 <code>promise(.success(&lt;OutputType&gt;))</code> 返回一个值。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#reference-future">Future</a> 在创建时立即发起其中异步 API 的调用，<strong>而不是</strong> 当它收到订阅需求时。
这可能不是你想要或需要的行为。
如果你希望在订阅者请求数据时再发起调用，你可能需要用 <a href="#reference-deferred">Deferred</a> 来包装 Future。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您想返回一个已经被解析的 promise 作为 <code>Future</code> 发布者，你可以在闭包中立即返回你想要的结果。</p>
</div>
<div class="paragraph">
<p>以下示例将单个值 <code>true</code> 返回表示成功。
你同样可以简单地返回 <code>false</code>，发布者仍然会将其作为一个成功的 promise。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">resolvedSuccessAsPublisher</span> <span class="o">=</span> <span class="kt">Future</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">promise</span> <span class="k">in</span>
    <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span>
<span class="p">}</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一个返回 <code>Future</code> 发布者的例子，它立即将 promise 解析为错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">enum</span> <span class="kt">ExampleFailure</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">oneCase</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">resolvedFailureAsPublisher</span> <span class="o">=</span> <span class="kt">Future</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">promise</span> <span class="k">in</span>
    <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="kt">ExampleFailure</span><span class="o">.</span><span class="n">oneCase</span><span class="p">))</span>
<span class="p">}</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect2">
<h3 id="patterns-sequencing-operations">有序的异步操作</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>使用 Combine 的管道来显式地对异步操作进行排序</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这类似于一个叫做 "promise chaining" 的概念。
虽然你可以将 Combine 处理的和其行为一致，但它可能不能良好地替代对 promise 库的使用。
主要区别在于，promise 库总是将每个 promise 作为单一结果处理，而 Combine 带来了可能需要处理许多值的复杂性。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-future">Future</a></p>
</li>
<li>
<p><a href="#reference-flatmap">flatMap</a></p>
</li>
<li>
<p><a href="#reference-zip">zip</a></p>
</li>
<li>
<p><a href="#reference-sink">sink</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-delegate-publisher-subject">通过包装基于 delegate 的 API 创建重复发布者</a></p>
</li>
<li>
<p>使用此代码的 ViewController 在 github 的项目中 <a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/AsyncCoordinatorViewController.swift">UIKit-Combine/AsyncCoordinatorViewController.swift</a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>任何需要按特定顺序执行的异步（或同步）任务组都可以使用 Combine 管道进行协调管理。
通过使用 <a href="#reference-future">Future</a> 操作符，可以捕获完成异步请求的行为，序列操作符提供了这种协调功能的结构。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>通过将任何异步 API 请求与 <a href="#reference-future">Future</a> 发布者进行封装，然后将其与 <a href="#reference-flatmap">flatMap</a> 操作符链接在一起，你可以以特定顺序调用被封装的异步 API 请求。
通过使用 <a href="#reference-future">Future</a> 或其他发布者创建多个管道，使用 <a href="#reference-zip">zip</a> 操作符将它们合并之后等待管道完成，通过这种方法可以创建多个并行的异步请求。</p>
</div>
<div class="paragraph">
<p>如果你想强制一个 <a href="#reference-future">Future</a> 发布者直到另一个发布者完成之后才被调用，你可以把 future 发布者创建在 <a href="#reference-flatmap">flatMap</a> 的闭包中，这样它就会等待有值被传入 flatMap 操作符之后才会被创建。</p>
</div>
<div class="paragraph">
<p>通过组合这些技术，可以创建任何并行或串行任务的结构。</p>
</div>
<div class="paragraph">
<p>如果后面的任务需要较早任务的数据，这种协调异步请求的技术会特别有效。
在这些情况下，所需的数据结果可以直接通过管道传输。</p>
</div>
<div class="paragraph">
<p>此排序的示例如下。
在此示例中，按钮在完成时会高亮显示，按钮的排列顺序是特意用来显示操作顺序的。
整个序列由单独的按钮操作触发，该操作还会重置所有按钮的状态，如果序列中有尚未完成的任务，则都将被取消。
在此示例中，异步 API 请求会在随机的时间之后完成，作为例子来展示时序的工作原理。</p>
</div>
<div class="paragraph">
<p>创建的工作流分步表示如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>步骤 1 先运行。</p>
</li>
<li>
<p>步骤 2 有三个并行的任务，在步骤 1 完成之后运行。</p>
</li>
<li>
<p>步骤 3 等步骤 2 的三个任务全部完成之后，再开始执行。</p>
</li>
<li>
<p>步骤 4 在步骤 3 完成之后开始执行。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，还有一个 activity indicator 被触发，以便在序列开始时开始动画，在第 4 步完成时停止。</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/AsyncCoordinatorViewController.swift">UIKit-Combine/AsyncCoordinatorViewController.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">AsyncCoordinatorViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">startButton</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">step1_button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">step2_1_button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">step2_2_button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">step2_3_button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">step3_button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">step4_button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">activityIndicator</span><span class="p">:</span> <span class="kt">UIActivityIndicatorView</span><span class="o">!</span>

    <span class="k">var</span> <span class="nv">cancellable</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">coordinatedPipeline</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">?</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">doit</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">Any</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">runItAll</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">runItAll</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="o">.</span><span class="n">cancellable</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Cancelling existing run"</span><span class="p">)</span>
            <span class="n">cancellable</span><span class="p">?</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
            <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">stopAnimating</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"resetting all the steps"</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">resetAllSteps</span><span class="p">()</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="c1">// driving it by attaching it to .sink</span>
        <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">startAnimating</span><span class="p">()</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="nf">print</span><span class="p">(</span><span class="s">"attaching a new sink to start things going"</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">cancellable</span> <span class="o">=</span> <span class="n">coordinatedPipeline</span><span class="p">?</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="o">.</span><span class="nf">print</span><span class="p">()</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received the completion: "</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">completion</span><span class="p">))</span>
                <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">stopAnimating</span><span class="p">()</span>
            <span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received value: "</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">})</span>
    <span class="p">}</span>
    <span class="c1">// MARK: - helper pieces that would normally be in other files</span>

    <span class="c1">// this emulates an async API call with a completion callback</span>
    <span class="c1">// it does nothing other than wait and ultimately return with a boolean value</span>
    <span class="kd">func</span> <span class="nf">randomAsyncAPI</span><span class="p">(</span><span class="n">completion</span> <span class="nv">completionBlock</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">((</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">global</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="n">background</span><span class="p">)</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
            <span class="nf">sleep</span><span class="p">(</span><span class="o">.</span><span class="nf">random</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="mi">1</span><span class="o">...</span><span class="mi">4</span><span class="p">))</span>
            <span class="nf">completionBlock</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">/// Creates and returns pipeline that uses a Future to wrap randomAsyncAPI</span>
    <span class="c1">/// and then updates a UIButton to represent the completion of the async</span>
    <span class="c1">/// work before returning a boolean True.</span>
    <span class="c1">/// - Parameter button: button to be updated</span>
    <span class="kd">func</span> <span class="nf">createFuturePublisher</span><span class="p">(</span><span class="nv">button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="k">return</span> <span class="kt">Future</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">promise</span> <span class="k">in</span>
            <span class="k">self</span><span class="o">.</span><span class="nf">randomAsyncAPI</span><span class="p">()</span> <span class="p">{</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span> <span class="k">in</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">err</span> <span class="o">=</span> <span class="n">err</span> <span class="p">{</span>
                    <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="c1">// so that we can update UI elements to show the "completion"</span>
            <span class="c1">// of this step</span>
        <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">inValue</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span> <i class="conum" data-value="6"></i><b>(6)</b>
            <span class="c1">// intentionally side effecting here to show progress of pipeline</span>
            <span class="k">self</span><span class="o">.</span><span class="nf">markStepDone</span><span class="p">(</span><span class="nv">button</span><span class="p">:</span> <span class="n">button</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">/// highlights a button and changes the background color to green</span>
    <span class="c1">/// - Parameter button: reference to button being updated</span>
    <span class="kd">func</span> <span class="nf">markStepDone</span><span class="p">(</span><span class="nv">button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">button</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">systemGreen</span>
        <span class="n">button</span><span class="o">.</span><span class="n">isHighlighted</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">resetAllSteps</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">button</span> <span class="k">in</span> <span class="p">[</span><span class="k">self</span><span class="o">.</span><span class="n">step1_button</span><span class="p">,</span> <span class="k">self</span><span class="o">.</span><span class="n">step2_1_button</span><span class="p">,</span> <span class="k">self</span><span class="o">.</span><span class="n">step2_2_button</span><span class="p">,</span> <span class="k">self</span><span class="o">.</span><span class="n">step2_3_button</span><span class="p">,</span> <span class="k">self</span><span class="o">.</span><span class="n">step3_button</span><span class="p">,</span> <span class="k">self</span><span class="o">.</span><span class="n">step4_button</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">button</span><span class="p">?</span><span class="o">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="o">.</span><span class="n">lightGray</span>
            <span class="n">button</span><span class="p">?</span><span class="o">.</span><span class="n">isHighlighted</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">stopAnimating</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// MARK: - view setup</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">stopAnimating</span><span class="p">()</span>

        <span class="c1">// Do any additional setup after loading the view.</span>

        <span class="n">coordinatedPipeline</span> <span class="o">=</span> <span class="nf">createFuturePublisher</span><span class="p">(</span><span class="nv">button</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">step1_button</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
            <span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">flatMapInValue</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="k">in</span>
            <span class="k">let</span> <span class="nv">step2_1</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="nf">createFuturePublisher</span><span class="p">(</span><span class="nv">button</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">step2_1_button</span><span class="p">)</span>
            <span class="k">let</span> <span class="nv">step2_2</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="nf">createFuturePublisher</span><span class="p">(</span><span class="nv">button</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">step2_2_button</span><span class="p">)</span>
            <span class="k">let</span> <span class="nv">step2_3</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="nf">createFuturePublisher</span><span class="p">(</span><span class="nv">button</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">step2_3_button</span><span class="p">)</span>
            <span class="k">return</span> <span class="kt">Publishers</span><span class="o">.</span><span class="kt">Zip3</span><span class="p">(</span><span class="n">step2_1</span><span class="p">,</span> <span class="n">step2_2</span><span class="p">,</span> <span class="n">step2_3</span><span class="p">)</span>
                <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
                    <span class="k">return</span> <span class="kc">true</span>
                <span class="p">}</span>
                <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
            <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="nf">createFuturePublisher</span><span class="p">(</span><span class="nv">button</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">step3_button</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
            <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="nf">createFuturePublisher</span><span class="p">(</span><span class="nv">button</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">step4_button</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>runItAll</code> 协调此工作流的进行，它从检查当前是否正在执行开始。
如果是，它会在当前的订阅者上调用 <code>cancel()</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>resetAllSteps</code> 通过遍历所有表示当前工作流状态的按钮，并将它们重置为灰色和未高亮以回到初始状态。
它还验证 activity indicator 当前未处于动画中。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>然后我们开始执行请求，首先开启 activity indicator 的旋转动画。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用 <a href="#reference-sink">sink</a> 创建订阅者并存储对工作流的引用。
被订阅的发布者是在该函数外创建的，允许被多次复用。
管道中的 <a href="#reference-print">print</a> 操作符用于调试，在触发管道时在控制台显示输出。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>每个步骤都由 <a href="#reference-future">Future</a> 发布者紧跟管道构建而成，然后立即由管道操作符切换到主线程，然后更新 UIButton 的背景色，以显示该步骤已完成。
这封装在 <code>createFuturePublisher</code> 的调用中，使用 <a href="#reference-erasetoanypublisher">eraseToAnyPublisher</a> 以简化返回的类型。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><a href="#reference-map">map</a> 操作符用于创建并更新 UIButton，作为特定的效果以显示步骤已完成。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>创建整个管道及其串行和并行任务结构，是结合了对 <code>createFuturePublisher</code> 的调用以及对 <a href="#reference-flatmap">flatMap</a> 和 <a href="#reference-zip">zip</a> 操作符的使用共同完成的。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect2">
<h3 id="patterns-general-error-handling">错误处理</h3>
<div class="paragraph">
<p>上述示例都假设，如果发生错误情况，订阅者将处理这些情况。
但是，你并不总是能够控制订阅者的要求——如果你使用 SwiftUI，情况可能如此。
在这些情况下，你需要构建管道，以便输出类型与订阅者的类型匹配。
这意味着你在处理管道内的任何错误。</p>
</div>
<div class="paragraph">
<p>例如，如果你正在使用 SwiftUI，并且你希望使用 <a href="#reference-assign">assign</a> 在按钮上设置 <code>isEnabled</code> 属性，则订阅者将有几个要求：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>订阅者应匹配 <code>&lt;Bool, Never&gt;</code> 的类型输出</p>
</li>
<li>
<p>应该在主线程调用订阅者</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果发布者抛出一个错误（例如 <a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a> ），你需要构建一个管道来转换输出类型，还需要处理管道内的错误，以匹配错误类型 <code>&lt;Never&gt;</code>。</p>
</div>
<div class="paragraph">
<p>如何处理管道内的错误取决于管道的定义方式。
如果管道设置为返回单个结果并终止， 一个很好的例子就是 <a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a>。
如果管道被设置为持续更新，则错误处理要复杂一点。
这种情况下的一个很好的例子是 <a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a>。</p>
</div>
<div class="sect3">
<h4 id="patterns-assertnofailure">使用 assertNoFailure 验证未发生失败</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>验证管道内未发生错误</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-assertnofailure">assertNoFailure</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-catch">catch</a></p>
</li>
<li>
<p><a href="#reference-flatmap">flatMap</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>在管道中测试常量时，断言 assertNoFailure 非常有用，可将失败类型转换为 <code>&lt;Never&gt;</code>。
如果断言被触发，该操作符将导致应用程序终止（或测试时导致调试器崩溃）。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这对于验证已经处理过错误的常量很有用。
比如你确信你处理了错误，对管道进行了 map 操作，该操作可以将 <code>&lt;Error&gt;</code> 的失败类型转换为 <code>&lt;Never&gt;</code> 传给所需的订阅者。</p>
</div>
<div class="paragraph">
<p>更有可能的是，你希望将错误处理掉，而不是终止应用程序。
期待后面的 <a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a> 和 <a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a> 模式吧，它们会告诉你如何提供逻辑来处理管道中的错误。</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>如果你需要在管道内处理失败，例如在使用 <code>assign</code> 操作符或其他要求失败类型为 <code>&lt;Never&gt;</code> 的操作符之前，你可以使用 <code>catch</code> 来提供适当的逻辑。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-catch">catch</a></p>
</li>
<li>
<p><a href="#reference-just">Just</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-retry">在发生暂时失败时重试</a></p>
</li>
<li>
<p><a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a></p>
</li>
<li>
<p><a href="#patterns-constrained-network">网络受限时从备用 URL 请求数据</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p><a href="#reference-catch">catch</a> 处理错误的方式，是将上游发布者替换为另一个发布者，这是你在闭包中用返回值提供的。</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，这实际上终止了管道。
如果你使用的是一次性发布者（不创建多个事件），那这就没什么。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如，<a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a> 是一个一次性的发布者，你可以使用 catch 在发生错误时返回默认值，以确保你得到响应结果。
扩展我们以前的示例以提供默认的响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">IPInfo</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="c1">// matching the data structure returned from ip.jsontest.com</span>
    <span class="k">var</span> <span class="nv">ip</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">myURL</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"http://ip.jsontest.com"</span><span class="p">)</span>
<span class="c1">// NOTE(heckj): you'll need to enable insecure downloads in your Info.plist for this example</span>
<span class="c1">// since the URL scheme is 'http'</span>

<span class="k">let</span> <span class="nv">remoteDataPublisher</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">myURL</span><span class="o">!</span><span class="p">)</span>
    <span class="c1">// the dataTaskPublisher output combination is (data: Data, response: URLResponse)</span>
    <span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="p">(</span><span class="n">inputTuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="k">in</span>
        <span class="k">return</span> <span class="n">inputTuple</span><span class="o">.</span><span class="n">data</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">IPInfo</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">JSONDecoder</span><span class="p">())</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">return</span> <span class="kt">Publishers</span><span class="o">.</span><span class="kt">Just</span><span class="p">(</span><span class="kt">IPInfo</span><span class="p">(</span><span class="nv">ip</span><span class="p">:</span> <span class="s">"8.8.8.8"</span><span class="p">))</span><i class="conum" data-value="3"></i><b>(3)</b>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>通常，catch 操作符将被放置在几个可能失败的操作符之后，以便在之前任何可能的操作失败时提供回退或默认值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 catch 时，你可以得到错误类型，并可以检查它以选择如何提供响应。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Just 发布者经常用于启动另一个一次性管道，或在发生失败时直接提供默认的响应。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>此技术的一个可能问题是，如果你希望原始发布者生成多个响应值，但使用 catch 之后原始管道就已结束了。
如果你正在创建一条对 <a href="#reference-published">@Published</a> 属性做出响应的管道，那么在任何失败值激活 catch 操作符之后，管道将不再做出进一步响应。
有关此工作原理的详细信息，请参阅 <a href="#reference-catch">catch</a>。</p>
</div>
<div class="paragraph">
<p>如果你要继续响应错误并处理它们，请参阅 <a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a>。</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-retry">在发生暂时失败时重试</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>当 <code>.failure</code> 发生时，<a href="#reference-retry">retry</a> 操作符可以被包含在管道中以重试订阅。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-catch">catch</a></p>
</li>
<li>
<p><a href="#reference-retry">retry</a></p>
</li>
<li>
<p><a href="#reference-delay">delay</a></p>
</li>
<li>
<p><a href="#reference-trymap">tryMap</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a></p>
</li>
<li>
<p><a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>当向 <code>dataTaskPublisher</code> 请求数据时，请求可能会失败。
在这种情况下，你将收到一个带有 error 的 <code>.failure</code> 事件。
当失败时，<a href="#reference-retry">retry</a> 操作符将允许你对相同请求进行一定次数的重试。
当发布者不发送 <code>.failure</code> 事件时，<code>retry</code> 操作符会传递结果值。
<code>retry</code> 仅在发送 <code>.failure</code> 事件时才在 Combine 管道内做出响应。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>当 <code>retry</code> 收到 <code>.failure</code> 结束事件时，它重试的方式是给它所链接的操作符或发布者重新创建订阅。</p>
</div>
<div class="paragraph">
<p>当尝试请求连接不稳定的网络资源时，通常需要 <a href="#reference-retry">retry</a> 操作符，或者再次请求时可能会成功的情况。
如果指定的重试次数全部失败，则将 <code>.failure</code> 结束事件传递给订阅者。</p>
</div>
<div class="paragraph">
<p>在下面的示例中，我们将 retry 与 <a href="#reference-delay">delay</a> 操作符相结合使用。
我们使用延迟操作符在下一个请求之前使其出现少量随机延迟。
这使得重试的尝试行为被分隔开，使重试不会快速连续的发生。</p>
</div>
<div class="paragraph">
<p>此示例还包括使用 <a href="#reference-trymap">tryMap</a> 操作符以更全面地检查从 <code>dataTaskPublisher</code> 返回的任何 URL 响应。
服务器的任何响应都由 <code>URLSession</code> 封装，并作为有效的响应转发。
<code>URLSession</code> 不将 <em>404 Not Found</em> 的 http 响应视为错误响应，也不将任何 <em>50x</em> 错误代码视作错误。
使用 <code>tryMap</code>，我们可检查已发送的响应代码，并验证它是 200 的成功响应代码。
在此示例中，如果响应代码不是 200 ，则会抛出一个异常 —— 这反过来又会导致 tryMap 操作符传递 <code>.failure</code> 事件，而不是数据。
此示例将 <code>tryMap</code> 设置在 retry 操作符 <strong>之后</strong>，以便仅在网站未响应时重新尝试请求。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">remoteDataPublisher</span> <span class="o">=</span> <span class="n">urlSession</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="kt">URL</span><span class="o">!</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">delay</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="kt">DispatchQueue</span><span class="o">.</span><span class="kt">SchedulerTimeType</span><span class="o">.</span><span class="kt">Stride</span><span class="p">(</span><span class="nv">integerLiteral</span><span class="p">:</span> <span class="kt">Int</span><span class="o">.</span><span class="nf">random</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="mi">1</span><span class="o">..&lt;</span><span class="mi">5</span><span class="p">)),</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">backgroundQueue</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">.</span><span class="nf">retry</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="o">.</span><span class="n">tryMap</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="k">in</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">httpResponse</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span><span class="p">,</span>
            <span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">200</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">invalidServerResponse</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">JSONDecoder</span><span class="p">())</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="n">backgroundQueue</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="#reference-delay">delay</a> 操作符将流经过管道的结果保持一小段时间，在这个例子中随机选择1至5秒。通过在管道中添加延迟，即使原始请求成功，重试也始终会发生。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>重试被指定为尝试3次。
如果每次尝试都失败，这将导致总共 4 次尝试 - 原始请求和 3 次额外尝试。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>tryMap 被用于检查 dataTaskPublisher 返回的数据，如果服务器的响应数据有效，但不是 200 HTTP 响应码，则返回 <code>.failure</code> 完成事件。</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用 <a href="#reference-retry">retry</a> 操作符与 <a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a> 时，请验证你请求的 URL 如果反复请求或重试，不会产生副作用。
理想情况下，此类请求应具有幂等性。
如果没有，<a href="#reference-retry">retry</a> 操作符可能会发出多个请求，并产生非常意想不到的副作用。</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>flatMap</code> 操作符可以与 <code>catch</code> 一起使用，以持续处理新发布的值上的错误。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-flatmap">flatMap</a></p>
</li>
<li>
<p><a href="#reference-just">Just</a></p>
</li>
<li>
<p><a href="#reference-catch">catch</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a></p>
</li>
<li>
<p><a href="#patterns-retry">在发生暂时失败时重试</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p><code>flatMap</code> 是用于处理持续事件流中错误的操作符。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>你提供一个闭包给 <code>flatMap</code>，该闭包可以获取所传入的值，并创建一个一次性的发布者，完成可能失败的工作。
这方面的一个例子是从网络请求数据，然后将其解码。
你可以引入一个 <a href="#reference-catch">catch</a> 操作符，以捕获任何错误并提供适当的值。</p>
</div>
<div class="paragraph">
<p>当你想要保持对上游发布者的更新时，这是一个完美的机制，因为它创建一次性的发布者或短管道，发送一个单一的值，然后完成每一个传入的值。
所创建的一次性发布者的完成事件在 flatMap 中终止，并且不会传递给下游订阅者。</p>
</div>
<div class="paragraph">
<p>一个使用 <code>dataTaskPublisher</code> 的这样的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">remoteDataPublisher</span> <span class="o">=</span> <span class="kt">Just</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">testURL</span><span class="o">!</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">url</span> <span class="k">in</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="o">.</span><span class="n">tryMap</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="k">in</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">httpResponse</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span><span class="p">,</span>
                <span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">200</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">throw</span> <span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">invalidServerResponse</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">JSONDecoder</span><span class="p">())</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="o">.</span><span class="k">catch</span> <span class="p">{</span><span class="n">_</span> <span class="k">in</span> <i class="conum" data-value="6"></i><b>(6)</b>
            <span class="k">return</span> <span class="kt">Just</span><span class="p">(</span><span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="p">(</span><span class="nv">valid</span><span class="p">:</span> <span class="kc">false</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Just</code> 以传入一个 URL 作为示例启动此发布者。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>flatMap</code> 以 URL 作为输入，闭包继续创建一次性发布者管道。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>dataTaskPublisher</code> 使用输入的 url 发出请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>输出的结果（一个 <code>(Data, URLResponse)</code> 元组）流入 <code>tryMap</code> 以解析其他错误。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>decode</code> 尝试将返回的数据转换为本地定义的类型。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>如果其中任何一个失败，<code>catch</code> 将把错误转换为一个默认的值。
在这个例子中，是具有预设好 <code>valid = false</code> 属性的对象。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-constrained-network">网络受限时从备用 URL 请求数据</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>在 Apple 的 WWDC 2019 演示 <a href="https://developer.apple.com/videos/play/wwdc2019/712/">Advances in Networking, Part 1</a> 中，使用 <code>tryCatch</code> 和 <code>tryMap</code> 操作符提供了示例模式，以响应网络受到限制的特殊错误。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a></p>
</li>
<li>
<p><a href="#reference-trycatch">tryCatch</a></p>
</li>
<li>
<p><a href="#reference-trymap">tryMap</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a></p>
</li>
<li>
<p><a href="#patterns-retry">在发生暂时失败时重试</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="c1">// Generalized Publisher for Adaptive URL Loading</span>
<span class="kd">func</span> <span class="nf">adaptiveLoader</span><span class="p">(</span><span class="nv">regularURL</span><span class="p">:</span> <span class="kt">URL</span><span class="p">,</span> <span class="nv">lowDataURL</span><span class="p">:</span> <span class="kt">URL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">Data</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">URLRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">regularURL</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">request</span><span class="o">.</span><span class="n">allowsConstrainedNetworkAccess</span> <span class="o">=</span> <span class="kc">false</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">return</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">request</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="o">.</span><span class="n">tryCatch</span> <span class="p">{</span> <span class="n">error</span> <span class="o">-&gt;</span> <span class="kt">URLSession</span><span class="o">.</span><span class="kt">DataTaskPublisher</span> <span class="k">in</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="k">guard</span> <span class="n">error</span><span class="o">.</span><span class="n">networkUnavailableReason</span> <span class="o">==</span> <span class="o">.</span><span class="n">constrained</span> <span class="k">else</span> <span class="p">{</span>
               <span class="k">throw</span> <span class="n">error</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">lowDataURL</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
        <span class="o">.</span><span class="n">tryMap</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">httpResponse</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPUrlResponse</span><span class="p">,</span> <i class="conum" data-value="6"></i><b>(6)</b>
                   <span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">200</span> <span class="k">else</span> <span class="p">{</span>
                       <span class="k">throw</span> <span class="kt">MyNetworkingError</span><span class="o">.</span><span class="n">invalidServerResponse</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">data</span>
<span class="p">}</span>
<span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span> <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>在苹果的 WWDC 中的这个例子，提供了一个函数，接受两个 URL 作为参数 —— 一个主要的 URL 和一个备用的。
它会返回一个发布者，该发布者将请求数据，并在网络受到限制时向备用 URL 请求数据。</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>request 变量是一个尝试请求数据的 <code>URLRequest</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置 <code>request.allowsConstrainedNetworkAccess</code> 将导致 <code>dataTaskPublisher</code> 在网络受限时返回错误。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>调用 <code>dataTaskPublisher</code> 发起请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>tryCatch</code> 用于捕获当前的错误状态并检查特定错误（受限的网络）。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>如果它发现错误，它会使用备用 URL 创建一个新的一次性发布者。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>由此产生的发布者仍可能失败，<code>tryMap</code> 可以基于对应到错误条件的 HTTP 响应码来抛出错误，将此映射为失败。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>eraseToAnyPublisher</code> 可在操作符链上进行类型擦除，因此 adaptiveLoader 函数的返回类型为 <code>AnyPublisher&lt;Data, Error&gt;</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在示例中，如果从原始请求返回的错误不是网络受限的问题，则它会将 <code>.failure</code>  结束事件传到管道中。
如果错误是网络受限，则 <code>tryCatch</code> 操作符会创建对备用 URL 的新请求。</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="patterns-uikit-integration">和 UIKit 或 AppKit 集成</h3>
<div class="sect3">
<h4 id="patterns-update-interface-userinput">通过用户输入更新声明式 UI</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>查询基于 Web 的 API 并将要显示在 UI 中的数据返回</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>带有此代码的 Xcode 项目 ViewController 在 github 工程中，位于 <a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubViewController.swift"><code>UIKit-Combine/GithubViewController.swift</code></a></p>
</li>
<li>
<p>Publishers:
<a href="#reference-published">@Published</a>,
<a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a></p>
</li>
<li>
<p>Operators:
<a href="#reference-map">map</a>,
<a href="#reference-switchtolatest">switchToLatest</a>,
<a href="#reference-receive">receive</a>,
<a href="#reference-throttle">throttle</a>,
<a href="#reference-removeduplicates">removeDuplicates</a></p>
</li>
<li>
<p>Subscribers:
<a href="#reference-assign">assign</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a></p>
</li>
<li>
<p><a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a></p>
</li>
<li>
<p><a href="#patterns-datataskpublisher-trymap">使用 dataTaskPublisher 进行更严格的请求处理</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>像 Combine 这样的框架的主要好处之一是建立一个声明性结构，定义界面将如何根据用户输入进行更新。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>将 Combine 与 UIKit 集成的模式是设置一个变量，该变量将保持对更新状态的引用，并使用 IBAction 连接控件。</p>
</div>
<div class="paragraph">
<p>以下示例是更大的 ViewController 实现中的代码的一部分。</p>
</div>
<div class="paragraph">
<p>这个例子与下一个模式  <a href="#patterns-cascading-update-interface">级联多个 UI 更新，包括网络请求</a> 有点重叠，都建立在一个初始的发布者上。</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubAPI.swift">UIKit-Combine/GithubAPI.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">github_id_entry</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="k">var</span> <span class="nv">usernameSubscriber</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>

    <span class="c1">// username from the github_id_entry field, updated via IBAction</span>
    <span class="c1">// @Published is creating a publisher $username of type &lt;String, Never&gt;</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">username</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span> <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="c1">// github user retrieved from the API publisher. As it's updated, it</span>
    <span class="c1">// is "wired" to update UI elements</span>
    <span class="kd">@Published</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">githubUserData</span><span class="p">:</span> <span class="p">[</span><span class="kt">GithubAPIUser</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">// MARK - Actions</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">githubIdChanged</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UITextField</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">username</span> <span class="o">=</span> <span class="n">sender</span><span class="o">.</span><span class="n">text</span> <span class="p">??</span> <span class="s">""</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Set username to "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="c1">// Do any additional setup after loading the view.</span>

        <span class="n">usernameSubscriber</span> <span class="o">=</span> <span class="err">$</span><span class="n">username</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="o">.</span><span class="nf">throttle</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">myBackgroundQueue</span><span class="p">,</span> <span class="nv">latest</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
            <span class="c1">// ^^ scheduler myBackGroundQueue publishes resulting elements</span>
            <span class="c1">// into that queue, resulting on this processing moving off the</span>
            <span class="c1">// main runloop.</span>
            <span class="o">.</span><span class="nf">removeDuplicates</span><span class="p">()</span> <i class="conum" data-value="6"></i><b>(6)</b>
            <span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"username pipeline: "</span><span class="p">)</span> <span class="c1">// debugging output for pipeline</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">username</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">GithubAPIUser</span><span class="p">],</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="k">in</span> <i class="conum" data-value="7"></i><b>(7)</b>
                <span class="k">return</span> <span class="kt">GithubAPI</span><span class="o">.</span><span class="nf">retrieveGithubUser</span><span class="p">(</span><span class="nv">username</span><span class="p">:</span> <span class="n">username</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// ^^ type returned by retrieveGithubUser is a Publisher, so we use</span>
            <span class="c1">// switchToLatest to resolve the publisher to its value</span>
            <span class="c1">// to return down the chain, rather than returning a</span>
            <span class="c1">// publisher down the pipeline.</span>
            <span class="o">.</span><span class="nf">switchToLatest</span><span class="p">()</span> <i class="conum" data-value="8"></i><b>(8)</b>
            <span class="c1">// using a sink to get the results from the API search lets us</span>
            <span class="c1">// get not only the user, but also any errors attempting to get it.</span>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">githubUserData</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>UITextField</code> 是从用户交互推动更新的界面元素。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们定义了一个 <a href="#reference-published">@Published</a> 属性，既能保存数据，又能响应更新。
因为它是一个 <code>@Published</code> 属性，它提供了一个发布者，我们可以使用 Combine 的管道更新界面的其他变量或元素。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们从 IBAction 内部设置变量 <code>username</code>，如果发布者 <code>$username</code> 有任何订阅者，它反过来就会触发数据流更新。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们又在发布者 <code>$username</code> 上设置了一个订阅者，以触发进一步的行为。
在这个例子中，它使用更新过的 <code>username</code> 的值从 Github 的 REST API 取回一个 GithubAPIUser 实例。
每次更新用户名值时，它都会发起新的 HTTP 请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><a href="#reference-throttle">throttle</a> 在这里是防止每编辑一次 <code>UITextField</code> 都触发一个网络请求。
throttle 操作符保证了每半秒最多可发出 1 个请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><a href="#reference-removeduplicates">removeDuplicates</a> 移除重复的更改用户名事件，以便不会连续两次对相同的值发起 API 请求。
如果用户结束编辑时返回的是之前的值，<code>removeDuplicates</code> 可防止发起冗余请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>map 在此处和 flatMap 处理错误类似，返回一个发布者的实例。
在 map 被调用时，API 对象返回一个发布者。
它不会返回请求的值，而是返回发布者本身。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><a href="#reference-switchtolatest">switchToLatest</a> 操作符接收发布者实例并解析其中的数据。
<code>switchToLatest</code> 将发布者解析为值，并将该值传递到管道中，在这个例子中，是一个 <code>[GithubAPIUser]</code> 的实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>在管道末尾的 <code>assign</code> 是订阅者，它将值分配到另一个变量：<code>githubUserData</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>模式 <a href="#patterns-cascading-update-interface">级联多个 UI 更新，包括网络请求</a> 在此代码上扩展为各种UI元素的多个级联更新。</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-cascading-update-interface">级联多个 UI 更新，包括网络请求</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>由上游的订阅者触发多个 UI 元素更新</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>带有此代码的 ViewController 在 github 项目中，位于 <a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubViewController.swift">UIKit-Combine/GithubViewController.swift</a>。
你可以通过在 github 项目中运行 UIKit target 来查看此代码。</p>
</li>
<li>
<p>GithubAPI 在 github 项目中，位于 <a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubAPI.swift">UIKit-Combine/GithubAPI.swift</a></p>
</li>
<li>
<p>发布者:
<a href="#reference-published">@Published</a>,
<a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a>,
<a href="#reference-just">Just</a>,
<a href="#reference-empty">Empty</a></p>
</li>
<li>
<p>操作符:
<a href="#reference-decode">decode</a>,
<a href="#reference-catch">catch</a>,
<a href="#reference-map">map</a>,
<a href="#reference-trymap">tryMap</a>,
<a href="#reference-switchtolatest">switchToLatest</a>,
<a href="#reference-filter">filter</a>,
<a href="#reference-handleevents">handleEvents</a>,
<a href="#reference-subscribe">subscribe</a>,
<a href="#reference-receive">receive</a>,
<a href="#reference-throttle">throttle</a>,
<a href="#reference-removeduplicates">removeDuplicates</a></p>
</li>
<li>
<p>订阅者:
<a href="#reference-sink">sink</a>,
<a href="#reference-assign">assign</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-continual-error-handling">使用 flatMap 和 catch 在不取消管道的情况下处理错误</a></p>
</li>
<li>
<p><a href="#patterns-oneshot-error-handling">使用 catch 处理一次性管道中的错误</a></p>
</li>
<li>
<p><a href="#patterns-datataskpublisher-trymap">使用 dataTaskPublisher 进行更严格的请求处理</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>以下提供的示例是扩展了 <a href="#patterns-update-interface-userinput">通过用户输入更新声明式 UI</a> 例子中的发布者, 添加了额外的 Combine 管道，当有人与所提供的界面交互时以更新多个 UI 元素。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>此视图的模式从接受用户输入的文本框开始，紧接着是一系列操作事件流：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用一个 IBAction 来更新 <a href="#reference-published">@Published</a> <code>username</code> 变量。</p>
</li>
<li>
<p>我们有一个订阅者（<code>usernameSubscriber</code>）连接到 <code>$username</code> 发布者，该发布者发送值的更新，并尝试取回 GitHub user。
结果返回的变量 <code>githubUserData</code>（也被 <a href="#reference-published">@Published</a> 标记）是一个 GitHub 用户对象的列表。
尽管我们只期望在这里获得单个值，但我们使用列表是因为我们可以方便地在失败情况下返回空列表：无法访问 API 或用户名未在 GitHub 注册。</p>
</li>
<li>
<p>我们有 <code>passthroughSubject</code> <code>apiNetworkActivitySubscriber</code> 来反映 GithubAPI 对象何时开始或完成网络请求。</p>
</li>
<li>
<p>我们有另一个订阅者 <code>repositoryCountSubscriber</code> 连接到 <code>$githubUserData</code> 发布者，该发布者从 github 用户数据对象中提取出仓库个数，并将其分配给要显示的文本字段。</p>
</li>
<li>
<p>我们有一个最终的订阅者 <code>avatarViewSubscriber</code> 连接到 <code>$githubUserData</code>，尝试取回与用户的头像相关的图像进行显示。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>返回空列表很有用，因为当提供无效的用户名时，我们希望明确地移除以前显示的任何头像。
为此，我们需要管道始终有值可以流动，以便触发进一步的管道和相关的 UI 界面更新。
如果我们使用可选的 <code>String?</code> 而不是 <code>String[]</code> 数组，可选的字符串不会在值是 nil 时触发某些管道，并且我们始终希望管道返回一个结果值（即使是空值）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以 <a href="#reference-assign">assign</a> 和 <a href="#reference-sink">sink</a> 创建的订阅者被存储在 ViewController 实例的 <code>AnyCancellable</code> 变量中。
由于它们是在类实例中定义的，Swift 编译器创建的 deinitializers 会在类被销毁时，取消并清理发布者。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>许多喜欢 RxSwift 的开发者使用的是 "CancelBag" 对象来存储可取消的引用，并在销毁时取消管道。
可以在这儿看到一个这样的例子：https://github.com/tailec/CombineExamples/blob/master/CombineExamples/Shared/CancellableBag.swift.
这与 Combine 中在 <code>AnyCancellable</code> 类型上调用 <code>store</code> 函数是相似的，它允许你将订阅者的引用保存在一个集合中，例如 <code>Set&lt;AnyCancellable&gt;</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>管道使用 <a href="#reference-subscribe">subscribe</a> 操作符明确配置为在后台队列中工作。
如果没有该额外的配置，管道将被在主线程调用并执行，因为它们是从 UI 线程上调用的，这可能会导致用户界面响应速度明显减慢。
同样，当管道的结果分配给或更新 UI 元素时，<a href="#reference-receive">receive</a> 操作符用于将该工作转移回主线程。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了让 UI 在 <a href="#reference-published">@Published</a> 属性发送的更改事件中不断更新，我们希望确保任何配置的管道都具有 &lt;Never&gt; 的失败类型。
这是 <a href="#reference-assign">assign</a> 操作符所必需的。
当使用 <a href="#reference-sink">sink</a> 操作符时，它也是一个潜在的 bug 来源。
如果来自 <a href="#reference-published">@Published</a> 变量的管道以一个接受 Error 失败类型的 <a href="#reference-sink">sink</a> 结束，如果发生错误，sink 将给管道发送终止信号。
这将停止管道的任何进一步处理，即使有变量仍然被更新。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubAPI.swift">UIKit-Combine/GithubAPI.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">Foundation</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">enum</span> <span class="kt">APIFailureCondition</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">invalidServerResponse</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">GithubAPIUser</span><span class="p">:</span> <span class="kt">Decodable</span> <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="c1">// A very *small* subset of the content available about</span>
    <span class="c1">//  a github API user for example:</span>
    <span class="c1">// https://api.github.com/users/heckj</span>
    <span class="k">let</span> <span class="nv">login</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">public_repos</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">let</span> <span class="nv">avatar_url</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">GithubAPI</span> <span class="p">{</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="c1">// NOTE(heckj): I've also seen this kind of API access</span>
    <span class="c1">// object set up with with a class and static methods on the class.</span>
    <span class="c1">// I don't know that there's a specific benefit to making this a value</span>
    <span class="c1">// type/struct with a function on it.</span>

    <span class="c1">/// externally accessible publisher that indicates that network activity is happening in the API proxy</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">networkActivityPublisher</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span> <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="c1">/// creates a one-shot publisher that provides a GithubAPI User</span>
    <span class="c1">/// object as the end result. This method was specifically designed to</span>
    <span class="c1">/// return a list of 1 object, as opposed to the object itself to make</span>
    <span class="c1">/// it easier to distinguish a "no user" result (empty list)</span>
    <span class="c1">/// representation that could be dealt with more easily in a Combine</span>
    <span class="c1">/// pipeline than an optional value. The expected return type is a</span>
    <span class="c1">/// Publisher that returns either an empty list, or a list of one</span>
    <span class="c1">/// GithubAPUser, with a failure return type of Never, so it's</span>
    <span class="c1">/// suitable for recurring pipeline updates working with a @Published</span>
    <span class="c1">/// data source.</span>
    <span class="c1">/// - Parameter username: username to be retrieved from the Github API</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">retrieveGithubUser</span><span class="p">(</span><span class="nv">username</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">GithubAPIUser</span><span class="p">],</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span> <i class="conum" data-value="4"></i><b>(4)</b>

        <span class="k">if</span> <span class="n">username</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">{</span> <i class="conum" data-value="5"></i><b>(5)</b>
            <span class="k">return</span> <span class="kt">Just</span><span class="p">([])</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="nv">assembledURL</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="s">"https://api.github.com/users/</span><span class="se">\(</span><span class="n">username</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">publisher</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="n">assembledURL</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">handleEvents</span><span class="p">(</span><span class="nv">receiveSubscription</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <i class="conum" data-value="6"></i><b>(6)</b>
                <span class="n">networkActivityPublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
            <span class="p">},</span> <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
                <span class="n">networkActivityPublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
            <span class="p">},</span> <span class="nv">receiveCancel</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">networkActivityPublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="o">.</span><span class="n">tryMap</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="k">in</span> <i class="conum" data-value="7"></i><b>(7)</b>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">httpResponse</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span><span class="p">,</span>
                    <span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">200</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">throw</span> <span class="kt">APIFailureCondition</span><span class="o">.</span><span class="n">invalidServerResponse</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">data</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">GithubAPIUser</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">JSONDecoder</span><span class="p">())</span> <i class="conum" data-value="8"></i><b>(8)</b>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span>
                <span class="p">[</span><span class="nv">$0</span><span class="p">]</span> <i class="conum" data-value="9"></i><b>(9)</b>
            <span class="p">}</span>
            <span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span> <i class="conum" data-value="10"></i><b>(10)</b>
                <span class="c1">// When I originally wrote this method, I was returning</span>
                <span class="c1">// a GithubAPIUser? optional.</span>
                <span class="c1">// I ended up converting this to return an empty</span>
                <span class="c1">// list as the "error output replacement" so that I could</span>
                <span class="c1">// represent that the current value requested didn't *have* a</span>
                <span class="c1">// correct github API response.</span>
                <span class="k">return</span> <span class="kt">Just</span><span class="p">([])</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span> <i class="conum" data-value="11"></i><b>(11)</b>
            <span class="k">return</span> <span class="n">publisher</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>此处创建的 decodable 结构体是从 GitHub API 返回的数据的一部分。
在由 <a href="#reference-decode">decode</a> 操作符处理时，任何未在结构体中定义的字段都将被简单地忽略。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>与 GitHub API 交互的代码被放在一个独立的结构体中，我习惯于将其放在一个单独的文件中。
API 结构体中的函数返回一个发布者，然后与 ViewController 中的其他管道进行混合合并。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>该结构体还使用 <a href="#reference-passthroughsubject">passthroughSubject</a> 暴露了一个发布者，使用布尔值以在发送网络请求时反映其状态。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我最开始创建了一个管道以返回一个可选的 GithubAPIUser 实例，但发现没有一种方便的方法来在失败条件下传递 “nil” 或空对象。
然后我修改了代码以返回一个列表，即使只需要一个实例，它却能更方便地表示一个“空”对象。
这对于想要在对 GithubAPIUser 对象不再存在后，在后续管道中做出响应以擦除现有值的情况很重要 —— 这时可以删除 repositoryCount 和用户头像的数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>这里的逻辑只是为了防止无关的网络请求，如果请求的用户名少于 3 个字符，则返回空结果。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><a href="#reference-handleevents">handleEvents</a> 操作符是我们触发网络请求发布者更新的方式。
我们定义了在订阅和终结（完成和取消）时触发的闭包，它们会在 <a href="#reference-passthroughsubject">passthroughSubject</a> 上调用 <code>send()</code>。
这是我们如何作为单独的发布者提供有关管道操作的元数据的示例。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><a href="#reference-trymap">tryMap</a> 添加了对来自 github 的 API 响应的额外检查，以将来自 API 的不是有效用户实例的正确响应转换为管道失败条件。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><a href="#reference-decode">decode</a> 从响应中获取数据并将其解码为 <code>GithubAPIUser</code> 的单个实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td><a href="#reference-map">map</a> 用于获取单个实例并将其转换为单元素的列表，将类型更改为 <code>GithubAPIUser</code> 的列表：<code>[GithubAPIUser]</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td><a href="#reference-catch">catch</a> 运算符捕获此管道中的错误条件，并在失败时返回一个空列表，同时还将失败类型转换为 <code>Never</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td><a href="#reference-erasetoanypublisher">eraseToAnyPublisher</a> 抹去链式操作符的复杂类型，并将整个管道暴露为 <code>AnyPublisher</code> 的一个实例。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubViewController.swift">UIKit-Combine/GithubViewController.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">github_id_entry</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">activityIndicator</span><span class="p">:</span> <span class="kt">UIActivityIndicatorView</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">repositoryCountLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">githubAvatarImageView</span><span class="p">:</span> <span class="kt">UIImageView</span><span class="o">!</span>

    <span class="k">var</span> <span class="nv">repositoryCountSubscriber</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">avatarViewSubscriber</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">usernameSubscriber</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">headingSubscriber</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">apiNetworkActivitySubscriber</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>

    <span class="c1">// username from the github_id_entry field, updated via IBAction</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">username</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>

    <span class="c1">// github user retrieved from the API publisher. As it's updated, it</span>
    <span class="c1">// is "wired" to update UI elements</span>
    <span class="kd">@Published</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">githubUserData</span><span class="p">:</span> <span class="p">[</span><span class="kt">GithubAPIUser</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">// publisher reference for this is $username, of type &lt;String, Never&gt;</span>
    <span class="k">var</span> <span class="nv">myBackgroundQueue</span><span class="p">:</span> <span class="kt">DispatchQueue</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="s">"viewControllerBackgroundQueue"</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">coreLocationProxy</span> <span class="o">=</span> <span class="kt">LocationHeadingProxy</span><span class="p">()</span>

    <span class="c1">// MARK - Actions</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">githubIdChanged</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UITextField</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">username</span> <span class="o">=</span> <span class="n">sender</span><span class="o">.</span><span class="n">text</span> <span class="p">??</span> <span class="s">""</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Set username to "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// MARK - lifecycle methods</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="c1">// Do any additional setup after loading the view.</span>

        <span class="k">let</span> <span class="nv">apiActivitySub</span> <span class="o">=</span> <span class="kt">GithubAPI</span><span class="o">.</span><span class="n">networkActivityPublisher</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">doingSomethingNow</span> <span class="k">in</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">doingSomethingNow</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">startAnimating</span><span class="p">()</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">stopAnimating</span><span class="p">()</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">apiNetworkActivitySubscriber</span> <span class="o">=</span> <span class="kt">AnyCancellable</span><span class="p">(</span><span class="n">apiActivitySub</span><span class="p">)</span>

        <span class="n">usernameSubscriber</span> <span class="o">=</span> <span class="err">$</span><span class="n">username</span> <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="o">.</span><span class="nf">throttle</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">myBackgroundQueue</span><span class="p">,</span> <span class="nv">latest</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
            <span class="c1">// ^^ scheduler myBackGroundQueue publishes resulting elements</span>
            <span class="c1">// into that queue, resulting on this processing moving off the</span>
            <span class="c1">// main runloop.</span>
            <span class="o">.</span><span class="nf">removeDuplicates</span><span class="p">()</span>
            <span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"username pipeline: "</span><span class="p">)</span> <span class="c1">// debugging output for pipeline</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">username</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">GithubAPIUser</span><span class="p">],</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="k">in</span>
                <span class="k">return</span> <span class="kt">GithubAPI</span><span class="o">.</span><span class="nf">retrieveGithubUser</span><span class="p">(</span><span class="nv">username</span><span class="p">:</span> <span class="n">username</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// ^^ type returned in the pipeline is a Publisher, so we use</span>
            <span class="c1">// switchToLatest to flatten the values out of that</span>
            <span class="c1">// pipeline to return down the chain, rather than returning a</span>
            <span class="c1">// publisher down the pipeline.</span>
            <span class="o">.</span><span class="nf">switchToLatest</span><span class="p">()</span>
            <span class="c1">// using a sink to get the results from the API search lets us</span>
            <span class="c1">// get not only the user, but also any errors attempting to get it.</span>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">githubUserData</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>

        <span class="c1">// using .assign() on the other hand (which returns an</span>
        <span class="c1">// AnyCancellable) *DOES* require a Failure type of &lt;Never&gt;</span>
        <span class="n">repositoryCountSubscriber</span> <span class="o">=</span> <span class="err">$</span><span class="n">githubUserData</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"github user data: "</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">userData</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">in</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nv">firstUser</span> <span class="o">=</span> <span class="n">userData</span><span class="o">.</span><span class="n">first</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">firstUser</span><span class="o">.</span><span class="n">public_repos</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="s">"unknown"</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">repositoryCountLabel</span><span class="p">)</span>

        <span class="k">let</span> <span class="nv">avatarViewSub</span> <span class="o">=</span> <span class="err">$</span><span class="n">githubUserData</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">userData</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">UIImage</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">firstUser</span> <span class="o">=</span> <span class="n">userData</span><span class="o">.</span><span class="n">first</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// my placeholder data being returned below is an empty</span>
                    <span class="c1">// UIImage() instance, which simply clears the display.</span>
                    <span class="c1">// Your use case may be better served with an explicit</span>
                    <span class="c1">// placeholder image in the event of this error condition.</span>
                    <span class="k">return</span> <span class="kt">Just</span><span class="p">(</span><span class="kt">UIImage</span><span class="p">())</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="n">firstUser</span><span class="o">.</span><span class="n">avatar_url</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
                    <span class="c1">// ^^ this hands back (Data, response) objects</span>
                    <span class="o">.</span><span class="nf">handleEvents</span><span class="p">(</span><span class="nv">receiveSubscription</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
                        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
                            <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">startAnimating</span><span class="p">()</span>
                        <span class="p">}</span>
                    <span class="p">},</span> <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
                        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
                            <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">stopAnimating</span><span class="p">()</span>
                        <span class="p">}</span>
                    <span class="p">},</span> <span class="nv">receiveCancel</span><span class="p">:</span> <span class="p">{</span>
                        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
                            <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">stopAnimating</span><span class="p">()</span>
                        <span class="p">}</span>
                    <span class="p">})</span>
                    <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">myBackgroundQueue</span><span class="p">)</span>
                    <span class="c1">// ^^ do this work on a background Queue so we don't impact</span>
                    <span class="c1">// UI responsiveness</span>
                    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">data</span> <span class="p">}</span>
                    <span class="c1">// ^^ pare down to just the Data object</span>
                    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span><span class="o">!</span><span class="p">}</span>
                    <span class="c1">// ^^ convert Data into a UIImage with its initializer</span>
                    <span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span>
                        <span class="k">return</span> <span class="kt">Just</span><span class="p">(</span><span class="kt">UIImage</span><span class="p">())</span>
                    <span class="p">}</span>
                    <span class="c1">// ^^ deal the failure scenario and return my "replacement"</span>
                    <span class="c1">// image for when an avatar image either isn't available or</span>
                    <span class="c1">// fails somewhere in the pipeline here.</span>
                    <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
                    <span class="c1">// ^^ match the return type here to the return type defined</span>
                    <span class="c1">// in the .map() wrapping this because otherwise the return</span>
                    <span class="c1">// type would be terribly complex nested set of generics.</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">switchToLatest</span><span class="p">()</span>
            <span class="c1">// ^^ Take the returned publisher that's been passed down the chain</span>
            <span class="c1">// and "subscribe it out" to the value within in, and then pass</span>
            <span class="c1">// that further down.</span>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="c1">// ^^ and then switch to receive and process the data on the main</span>
            <span class="c1">// queue since we're messing with the UI</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">image</span> <span class="o">-&gt;</span> <span class="kt">UIImage</span><span class="p">?</span> <span class="k">in</span>
                <span class="n">image</span>
            <span class="p">}</span>
            <span class="c1">// ^^ this converts from the type UIImage to the type UIImage?</span>
            <span class="c1">// which is key to making it work correctly with the .assign()</span>
            <span class="c1">// operator, which must map the type *exactly*</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">githubAvatarImageView</span><span class="p">)</span>

        <span class="c1">// convert the .sink to an `AnyCancellable` object that we have</span>
        <span class="c1">// referenced from the implied initializers</span>
        <span class="n">avatarViewSubscriber</span> <span class="o">=</span> <span class="kt">AnyCancellable</span><span class="p">(</span><span class="n">avatarViewSub</span><span class="p">)</span>

        <span class="c1">// KVO publisher of UIKit interface element</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">repositoryCountLabel</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
            <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">someValue</span> <span class="k">in</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"repositoryCountLabel Updated to </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">someValue</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们向我们之前的 controller 添加一个订阅者，它将来自 GithubAPI 对象的活跃状态的通知连接到我们的 activityIndicator。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>从 IBAction 更新用户名的地方（来自我们之前的示例 <a href="#patterns-update-interface-userinput">通过用户输入更新声明式 UI</a>）我们让订阅者发出网络请求并将结果放入一个我们的 ViewController 的新变量中（还是 <a href="#reference-published">@Published</a>）。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>第一个订阅者连接在发布者 <code>$githubUserData</code> 上。
此管道提取用户仓库的个数并更新到 UILabel 实例上。
当列表为空时，管道中间有一些逻辑来返回字符串 “unknown”。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第二个订阅者也连接到发布者 <code>$githubUserData</code>。
这会触发网络请求以获取 github 头像的图像数据。
这是一个更复杂的管道，从 <code>githubUser</code> 中提取数据，组装一个 URL，然后请求它。
我们也使用 <a href="#reference-handleevents">handleEvents</a> 操作符来触发对我们视图中的 activityIndi​​cator 的更新。
我们使用 <a href="#reference-receive">receive</a> 在后台队列上发出请求，然后将结果传递回主线程以更新 UI 元素。
<a href="#reference-catch">catch</a> 和失败处理在失败时返回一个空的 <code>UIImage</code> 实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>最终订阅者连接到 UILabel 自身。
任何来自 Foundation 的 Key-Value Observable 对象都可以产生一个发布者。
在此示例中，我们附加了一个发布者，该发布者触发 UI 元素已更新的打印语句。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然我们可以在更新 UI 元素时简单地将管道连接到它们，但这使得和实际的 UI 元素本身耦合更紧密。
虽然简单而直接，但创建明确的状态，以及分别对用户行为和数据做出更新是一个好的建议，这更利于调试和理解。
在上面的示例中，我们使用两个 <a href="#reference-published">@Published</a> 属性来保存与当前视图关联的状态。
其中一个由 <code>IBAction</code> 更新，第二个使用 Combine 发布者管道以声明的方式更新。
所有其他的 UI 元素都依赖这些属性的发布者更新时进行更新。</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-merging-streams-interface">合并多个管道以更新 UI 元素</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>观察并响应多个 UI 元素发送的值，并将更新的值联合起来以更新界面。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>带有此代码的 ViewController 在 github 项目中，位于 <a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/FormViewController.swift">UIKit-Combine/FormViewController.swift</a></p>
</li>
<li>
<p>发布者:
<a href="#reference-published">@Published</a>,</p>
</li>
<li>
<p>操作符:
<a href="#reference-combinelatest">combineLatest</a>,
<a href="#reference-map">map</a>,
<a href="#reference-receive">receive</a></p>
</li>
<li>
<p>订阅者:
<a href="#reference-assign">assign</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-update-interface-userinput">通过用户输入更新声明式 UI</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>此示例故意模仿许多 Web 表单样式的验证场景，不过是在 UIKit 中使用 Combine。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>ViewController 被配置了多个通过声明式更新的元素。
同时持有了 3 个主要的文本输入字段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value1</code></p>
</li>
<li>
<p><code>value2</code></p>
</li>
<li>
<p><code>value2_repeat</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它还有一个按钮来提交合并的值，以及两个 labels 来提供反馈。</p>
</div>
<div class="paragraph">
<p>这些字段的更新规则被实现为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value1</code> 中的条目至少有 3 个字符。</p>
</li>
<li>
<p><code>value2</code> 中的条目至少有 5 个字符。</p>
</li>
<li>
<p><code>value2_repeat</code> 中的条目必须与 <code>value2</code> 相同。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果这些规则中的任何一个未得到满足，则我们希望禁用提交按钮并显示相关消息，解释需要满足的内容。</p>
</div>
<div class="paragraph">
<p>这可以通过设置连接与合并在一起的一系列管道来实现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有一个 <a href="#reference-published">@Published</a> 属性匹配每个用户输入字段。
<a href="#reference-combinelatest">combineLatest</a> 用于从属性中获取不断发布的更新，并将它们合并到单个管道中。
<a href="#reference-map">map</a> 操作符强制执行所需字符和值必须相同的规则。
如果值与所需的输出不匹配，我们将在管道中传递 nil。</p>
</li>
<li>
<p>value1 还另外有一个验证管道，只使用了 <a href="#reference-map">map</a> 操作符来验证值，或返回 nil。</p>
</li>
<li>
<p>执行验证的 map 操作符内部的逻辑也用于更新用户界面中的 label 信息。</p>
</li>
<li>
<p>最终管道使用 <a href="#reference-combinelatest">combineLatest</a> 将两条验证管道合并为一条管道。
此组合的管道上连接了订阅者，以确定是否应启用提交按钮。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的示例将这些结合起来进行了展示。</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/FormViewController.swift">UIKit-Combine/FormViewController.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">FormViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">value1_input</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">value2_input</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">value2_repeat_input</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">submission_button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">value1_message_label</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">value2_message_label</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">value1_updated</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UITextField</span><span class="p">)</span> <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="n">value1</span> <span class="o">=</span> <span class="n">sender</span><span class="o">.</span><span class="n">text</span> <span class="p">??</span> <span class="s">""</span>
    <span class="p">}</span>
    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">value2_updated</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UITextField</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">value2</span> <span class="o">=</span> <span class="n">sender</span><span class="o">.</span><span class="n">text</span> <span class="p">??</span> <span class="s">""</span>
    <span class="p">}</span>
    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">value2_repeat_updated</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UITextField</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">value2_repeat</span> <span class="o">=</span> <span class="n">sender</span><span class="o">.</span><span class="n">text</span> <span class="p">??</span> <span class="s">""</span>
    <span class="p">}</span>

    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">value1</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">value2</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">value2_repeat</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>

    <span class="k">var</span> <span class="nv">validatedValue1</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">?,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">return</span> <span class="err">$</span><span class="n">value1</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">value1</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="n">value1</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">{</span>
                <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
                    <span class="k">self</span><span class="o">.</span><span class="n">value1_message_label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"minimum of 3 characters required"</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="kc">nil</span>
            <span class="p">}</span>
            <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">value1_message_label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">""</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">value1</span>
        <span class="p">}</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">validatedValue2</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">?,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="k">return</span> <span class="kt">Publishers</span><span class="o">.</span><span class="kt">CombineLatest</span><span class="p">(</span><span class="err">$</span><span class="n">value2</span><span class="p">,</span> <span class="err">$</span><span class="n">value2_repeat</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">value2</span><span class="p">,</span> <span class="n">value2_repeat</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="n">value2_repeat</span> <span class="o">==</span> <span class="n">value2</span><span class="p">,</span> <span class="n">value2</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">self</span><span class="o">.</span><span class="n">value2_message_label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"values must match and have at least 5 characters"</span>
                    <span class="k">return</span> <span class="kc">nil</span>
                <span class="p">}</span>
                <span class="k">self</span><span class="o">.</span><span class="n">value2_message_label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">""</span>
                <span class="k">return</span> <span class="n">value2</span>
            <span class="p">}</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">readyToSubmit</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)?,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span> <i class="conum" data-value="6"></i><b>(6)</b>
        <span class="k">return</span> <span class="kt">Publishers</span><span class="o">.</span><span class="kt">CombineLatest</span><span class="p">(</span><span class="n">validatedValue2</span><span class="p">,</span> <span class="n">validatedValue1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">value2</span><span class="p">,</span> <span class="n">value1</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">realValue2</span> <span class="o">=</span> <span class="n">value2</span><span class="p">,</span> <span class="k">let</span> <span class="nv">realValue1</span> <span class="o">=</span> <span class="n">value1</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kc">nil</span>
                <span class="p">}</span>
                <span class="nf">return</span> <span class="p">(</span><span class="n">realValue2</span><span class="p">,</span> <span class="n">realValue1</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="k">var</span> <span class="nv">cancellableSet</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[]</span> <i class="conum" data-value="7"></i><b>(7)</b>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>

        <span class="k">self</span><span class="o">.</span><span class="n">readyToSubmit</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">}</span> <i class="conum" data-value="8"></i><b>(8)</b>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">isEnabled</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">submission_button</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">cancellableSet</span><span class="p">)</span> <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>此代码的开头遵照了 <a href="#patterns-update-interface-userinput">通过用户输入更新声明式 UI</a> 中的模式.
IBAction 消息用于更新 <a href="#reference-published">@Published</a> 属性，触发对所连接的任何订阅者的更新。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个验证管道使用 <a href="#reference-map">map</a> 操作符接收字符串值输入，如果与验证规则不符，则将其转换为 nil。
这也将发布者属性的输出类型从 <code>&lt;String&gt;</code> 转换为可选的 <code>&lt;String?&gt;</code>。
同样的逻辑也用于触发消息文本的更新，以提供有关所需内容的信息。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>由于我们正在更新用户界面元素，因此我们明确将这些更新包裹在 <code>DispatchQueue.main.async</code> 中，以在主线程上调用。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><a href="#reference-combinelatest">combineLatest</a> 将两个发布者合并到一个管道中，该管道的输出类型是每个上游发布者的合并值。
在这个例子中，输出类型是 <code>(&lt;String&gt;, &lt;String&gt;)</code> 的元组。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>与其使用 <code>DispatchQueue.main.async</code>，不如使用 <a href="#reference-receive">receive</a> 操作符明确在主线程上执行下一个操作符，因为它将执行 UI 更新。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>两条验证管道通过 <a href="#reference-combinelatest">combineLatest</a> 相结合，并将经过检查的输出合并为单个元组输出。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>我们可以将分配的管道存储为 <code>AnyCancellable?</code> 引用（将其映射到 viewcontroller 的生命周期），但另一种选择是创建一个变量来收集所有可取消的引用。
这从空集合开始，任何 sink 或 assign 的订阅者都可以被添加到其中，以持有对它们的引用，以便他们在 viewcontroller 的整个生命周期内运行。
如果你正在创建多个管道，这可能是保持对所有管道的引用的便捷方式。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>如果任何值为 nil，则 <a href="#reference-map">map</a> 操作符将向管道传递 false 值。
对 nil 值的检查提供了用于启用（或禁用）提交按钮的布尔值。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td><code>store</code> 方法可在 <a href="https://developer.apple.com/documentation/combine/cancellable">Cancellable</a> 协议上调用，该协议明确设置为支持存储可用于取消管道的引用。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-delegate-publisher-subject">通过包装基于 delegate 的 API 创建重复发布者</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>将 Apple delegate API 之一包装为 Combine 管道来提供值。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-passthroughsubject">passthroughSubject</a></p>
</li>
<li>
<p><a href="#reference-currentvaluesubject">currentValueSubject</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-future">用 Future 来封装异步请求以创建一次性的发布者</a></p>
</li>
<li>
<p><a href="#reference-passthroughsubject">passthroughSubject</a></p>
</li>
<li>
<p><a href="#reference-delay">delay</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p><a href="#reference-future">Future</a> 发布者非常适合包装现有代码以发出单个请求，但它不适用于产生冗长或可能无限量输出的发布者。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Apple 的 Cocoa API 倾向于使用对象/代理模式，你可以选择接收任意数量的不同回调（通常包含数据）。
其中一个例子是在 CoreLocation 库中，提供了许多不同的数据源。</p>
</div>
<div class="paragraph">
<p>如果你想在管道中使用此类 API 之一提供的数据，你可以将对象包装起来，并使用 <a href="#reference-passthroughsubject">passthroughSubject</a> 来暴露发布者。
下面的示例代码显示了一个包装 CoreLocation 中 CLManager 的对象并通过 UIKit 的 ViewController 消费其数据的示例。</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/LocationHeadingProxy.swift">UIKit-Combine/LocationHeadingProxy.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">Foundation</span>
<span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">CoreLocation</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">LocationHeadingProxy</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">CLLocationManagerDelegate</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">mgr</span><span class="p">:</span> <span class="kt">CLLocationManager</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">headingPublisher</span><span class="p">:</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">CLHeading</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">var</span> <span class="nv">publisher</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">CLHeading</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="kt">CLLocationManager</span><span class="p">()</span>
        <span class="n">headingPublisher</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">CLHeading</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="n">publisher</span> <span class="o">=</span> <span class="n">headingPublisher</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>

        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
        <span class="n">mgr</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">enable</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mgr</span><span class="o">.</span><span class="nf">startUpdatingHeading</span><span class="p">()</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">disable</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mgr</span><span class="o">.</span><span class="nf">stopUpdatingHeading</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// MARK - delegate methods</span>

    <span class="cm">/*
     *  locationManager:didUpdateHeading:
     *
     *  Discussion:
     *    Invoked when a new heading is available.
     */</span>
    <span class="kd">func</span> <span class="nf">locationManager</span><span class="p">(</span><span class="n">_</span> <span class="nv">manager</span><span class="p">:</span> <span class="kt">CLLocationManager</span><span class="p">,</span> <span class="n">didUpdateHeading</span> <span class="nv">newHeading</span><span class="p">:</span> <span class="kt">CLHeading</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">headingPublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="n">newHeading</span><span class="p">)</span> <i class="conum" data-value="6"></i><b>(6)</b>
    <span class="p">}</span>

    <span class="cm">/*
     *  locationManager:didFailWithError:
     *  Discussion:
     *    Invoked when an error has occurred. Error types are defined in "CLError.h".
     */</span>
    <span class="kd">func</span> <span class="nf">locationManager</span><span class="p">(</span><span class="n">_</span> <span class="nv">manager</span><span class="p">:</span> <span class="kt">CLLocationManager</span><span class="p">,</span> <span class="n">didFailWithError</span> <span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">headingPublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://developer.apple.com/documentation/corelocation/cllocationmanager">CLLocationManager</a> 作为 CoreLocation 的一部分，是被包装的核心。
因为要使用该框架，它有其他方法需要被调用，因此我将它暴露为一个 public 的只读属性。
这对于先请求用户许可然后使用位置 API 很有用，框架将该位置 API 暴露为一个在 <code>CLLocationManager</code> 上的方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用一个具有我们要发布的数据类型的 private 的 <code>PassthroughSubject</code> 实例，来提供我们的类内部访问以转发数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>一个 public 的属性 <code>publisher</code> 将来自上面的 subject 的发布者暴露给外部以供订阅。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>其核心是将该类指定为 <code>CLLocationManager</code> 实例的代理，在该实例初始化的尾端进行设置。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>CoreLocation API 不会立即开始发送信息。
有些方法需要调用才能启动（并停止）数据流，这些方法被包装并暴露在此 <code>LocationHeadingProxy</code> 对象上。
大多数发布者都设置为订阅并根据订阅驱动消费，因此这有点不符合发布者如何开始生成数据的规范。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>在定义代理和激活 <code>CLLocationManager</code> 后，数据将通过在 <a href="https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate">CLLocationManagerDelegate</a> 上定义的回调提供。
我们为这个包装的对象实现了我们想要的回调，并在其中使用 <a href="#reference-passthroughsubject">passthroughSubject</a> <code>.send()</code> 将信息转发给任何现有的订阅者。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>虽然没有严格要求，但代理提供了 <code>Error</code> 上报回调，因此我们也将其包括在示例中通过 <a href="#reference-passthroughsubject">passthroughSubject</a> 转发。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/HeadingViewController.swift">UIKit-Combine/HeadingViewController.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">UIKit</span>
<span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">CoreLocation</span>

<span class="kd">class</span> <span class="kt">HeadingViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="k">var</span> <span class="nv">headingSubscriber</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>

    <span class="k">let</span> <span class="nv">coreLocationProxy</span> <span class="o">=</span> <span class="kt">LocationHeadingProxy</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">headingBackgroundQueue</span><span class="p">:</span> <span class="kt">DispatchQueue</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="s">"headingBackgroundQueue"</span><span class="p">)</span>

    <span class="c1">// MARK - lifecycle methods</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">permissionButton</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">activateTrackingSwitch</span><span class="p">:</span> <span class="kt">UISwitch</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">headingLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">locationPermissionLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">requestPermission</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"requesting corelocation permission"</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="kt">Future</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">promise</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="k">self</span><span class="o">.</span><span class="n">coreLocationProxy</span><span class="o">.</span><span class="n">mgr</span><span class="o">.</span><span class="nf">requestWhenInUseAuthorization</span><span class="p">()</span>
            <span class="k">return</span> <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">delay</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">headingBackgroundQueue</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
        <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"updating corelocation permission label"</span><span class="p">)</span>
            <span class="k">self</span><span class="o">.</span><span class="nf">updatePermissionStatus</span><span class="p">()</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">trackingToggled</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UISwitch</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">sender</span><span class="o">.</span><span class="n">isOn</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nv">true</span><span class="p">:</span>
            <span class="k">self</span><span class="o">.</span><span class="n">coreLocationProxy</span><span class="o">.</span><span class="nf">enable</span><span class="p">()</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Enabling heading tracking"</span><span class="p">)</span>
        <span class="k">case</span> <span class="nv">false</span><span class="p">:</span>
            <span class="k">self</span><span class="o">.</span><span class="n">coreLocationProxy</span><span class="o">.</span><span class="nf">disable</span><span class="p">()</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Disabling heading tracking"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">updatePermissionStatus</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">CLLocationManager</span><span class="o">.</span><span class="nf">authorizationStatus</span><span class="p">()</span>
        <span class="k">switch</span> <span class="n">x</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">authorizedWhenInUse</span><span class="p">:</span>
            <span class="n">locationPermissionLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"Allowed when in use"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">notDetermined</span><span class="p">:</span>
            <span class="n">locationPermissionLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"notDetermined"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">restricted</span><span class="p">:</span>
            <span class="n">locationPermissionLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"restricted"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">denied</span><span class="p">:</span>
            <span class="n">locationPermissionLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"denied"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">authorizedAlways</span><span class="p">:</span>
            <span class="n">locationPermissionLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"authorizedAlways"</span>
        <span class="kd">@unknown</span> <span class="k">default</span><span class="p">:</span>
            <span class="n">locationPermissionLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"unknown default"</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="c1">// Do any additional setup after loading the view.</span>

        <span class="c1">// request authorization for the corelocation data</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">updatePermissionStatus</span><span class="p">()</span>

        <span class="k">let</span> <span class="nv">corelocationsub</span> <span class="o">=</span> <span class="n">coreLocationProxy</span>
            <span class="o">.</span><span class="n">publisher</span>
            <span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"headingSubscriber"</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
            <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">someValue</span> <span class="k">in</span> <i class="conum" data-value="5"></i><b>(5)</b>
                <span class="k">self</span><span class="o">.</span><span class="n">headingLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">someValue</span><span class="o">.</span><span class="n">trueHeading</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="n">headingSubscriber</span> <span class="o">=</span> <span class="kt">AnyCancellable</span><span class="p">(</span><span class="n">corelocationsub</span><span class="p">)</span>
    <span class="p">}</span>

<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>CoreLocation 的特点之一是要向用户请求访问数据的许可。
启动此请求的 API 将立即返回，但即使用户允许或拒绝请求，它并不提供任何详细信息。
<code>CLLocationManager</code> 类包括信息，并在想要获取信息时将其作为类方法暴露给外部，但未提供任何信息来了解用户何时或是否响应了请求。
由于操作不提供任何返回信息，我们将整数提供给管道作为数据，主要表示已发出请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>由于没有明确的方法来判断用户何时会授予权限，但权限是持久的，因此在尝试获取数据之前，我们简单地使用了 <a href="#reference-delay">delay</a> 操作符。
此使用只会将值的传递延迟两秒钟。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>延迟后，我们调用类方法，并尝试根据当前提供的状态的结果更新界面中的信息。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>由于 CoreLocation 需要调用方法来明确启用或禁用数据，因此将我们发布者 proxy 的方法连接到了一个 <code>UISwitch</code> 的 <code>IBAction</code> 开关上。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>方位数据在本 <a href="#reference-sink">sink</a> 订阅者中接收，在此示例中，我们将其写到文本 label 上。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-notificationcenter">响应 NotificationCenter 的更新</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>作为发布者接收 NotificationCenter 的通知，以声明式的对所提供的信息做出响应。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-notificationcenter">NotificationCenter</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>单元测试在 <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/NotificationCenterPublisherTests.swift"><code>UsingCombineTests/NotificationCenterPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>大量的框架和用户界面组件通过 NotificationCenter 的通知提供有关其状态和交互的信息。
Apple 的文档包括一篇关于 <a href="https://developer.apple.com/documentation/combine/receiving_and_handling_events_with_combine">receiving and handling events with Combine</a> 的文章，特别提及了 NotificationCenter。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>通过 <a href="https://developer.apple.com/documentation/foundation/notificationcenter">NotificationCenter</a> 发送的 <a href="https://developer.apple.com/documentation/foundation/notification">Notifications</a> 为你应用中的事件提供了一个通用的中心化的位置。</p>
</div>
<div class="paragraph">
<p>你还可以将自己的通知添加到你的应用程序中，在发送通知时，还可以在其 <code>userInfo</code> 属性中添加一个额外的字典来发送数据。
一个定义你自己通知的示例 <code>.myExampleNotification</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">extension</span> <span class="kt">Notification</span><span class="o">.</span><span class="kt">Name</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">myExampleNotification</span> <span class="o">=</span> <span class="kt">Notification</span><span class="o">.</span><span class="kt">Name</span><span class="p">(</span><span class="s">"an-example-notification"</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通知名称是基于字符串的结构体。
当通知发布到 NotificationCenter 时，可以传递对象引用，表明发送通知的具体对象。
此外，通知可以包括 <code>userInfo</code>，是一个 <code>[AnyHashable : Any]?</code> 类型的值。
这允许将任意的字典（无论是引用类型还是值类型）包含在通知中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">myUserInfo</span> <span class="o">=</span> <span class="p">[</span><span class="s">"foo"</span><span class="p">:</span> <span class="s">"bar"</span><span class="p">]</span>

<span class="k">let</span> <span class="nv">note</span> <span class="o">=</span> <span class="kt">Notification</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="o">.</span><span class="n">myExampleNotification</span><span class="p">,</span> <span class="nv">userInfo</span><span class="p">:</span> <span class="n">myUserInfo</span><span class="p">)</span>
<span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">post</span><span class="p">(</span><span class="n">note</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然在 AppKit 和 macOS 应用程序中普遍地使用了通知，但并非所有开发人员都乐于大量使用 NotificationCenter。
通知起源于更具动态性的 Objective-C runtime ，广泛利用 Any 和 optional 类型。
在 Swift 代码或管道中使用它们意味着管道必须提供类型检查并处理与预期或非预期的数据相关的任何可能错误。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>创建 NotificationCenter 发布者时，你提供要接收的通知的名称，并可选地提供对象引用，以过滤特定类型的对象。
属于 <a href="https://developer.apple.com/documentation/appkit/nscontrol">NSControl</a> 子类的多个 AppKit 组件共享了一组通知，过滤操作对于获得这些组件的正确的通知至关重要。</p>
</div>
<div class="paragraph">
<p>订阅 AppKit 生成通知的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">sub</span> <span class="o">=</span> <span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="kt">NSControl</span><span class="o">.</span><span class="n">textDidChangeNotification</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
                                               <span class="nv">object</span><span class="p">:</span> <span class="n">filterField</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$0</span><span class="o">.</span><span class="n">object</span> <span class="k">as!</span> <span class="kt">NSTextField</span><span class="p">)</span><span class="o">.</span><span class="n">stringValue</span> <span class="p">}</span>  <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="kt">MyViewModel</span><span class="o">.</span><span class="n">filterString</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">myViewModel</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>AppKit 中的 TextField 在值更新时生成 <code>textDidChangeNotification</code> 通知。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>一个 AppKit 的应用程序通常可以具有大量可能被更改的 TextField。
包含对发送控件的引用可用于过滤你特别感兴趣的文本的更改通知。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><a href="#reference-map">map</a> 操作符可用于获取通知中包含的对象引用，在这个例子中，发送通知的 TextField 的 <code>.stringValue</code> 属性提供了它更新后的值。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>由此产生的字符串可以使用可写入的 <code>KeyValue</code> 路径进行 assign。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个订阅你自己的通知事件的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">myExampleNotification</span><span class="p">,</span> <span class="nv">object</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="c1">// can't use the object parameter to filter on a value reference, only class references, but</span>
    <span class="c1">// filtering on 'nil' only constrains to notification name, so value objects *can* be passed</span>
    <span class="c1">// in the notification itself.</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">receivedNotification</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"passed through: "</span><span class="p">,</span> <span class="n">receivedNotification</span><span class="p">)</span>
        <span class="c1">// receivedNotification.name</span>
        <span class="c1">// receivedNotification.object - object sending the notification (sometimes nil)</span>
        <span class="c1">// receivedNotification.userInfo - often nil</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="patterns-swiftui-integration">和 SwiftUI 集成</h3>
<div class="sect3">
<h4 id="pattern-observableobject">使用 ObservableObject 与 SwiftUI 模型作为发布源</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>SwiftUI 包含 @ObservedObject 和 ObservableObject 协议，它为 SwiftUI 的视图提供了将状态外部化的手段，同时通知 SwiftUI 模型的变化。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-published">@Published</a></p>
</li>
<li>
<p><a href="#reference-observableobject">ObservableObject</a></p>
</li>
<li>
<p><a href="#reference-currentvaluesubject">currentValueSubject</a></p>
</li>
<li>
<p><a href="#reference-combinelatest">combineLatest</a></p>
</li>
<li>
<p><a href="#reference-map">map</a></p>
</li>
<li>
<p><a href="#reference-onreceive">onReceive</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<p>SwiftUI 的例子：</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/SwiftUI-Notes/ReactiveForm.swift"><code>SwiftUI-Notes/ReactiveForm.swift</code></a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/SwiftUI-Notes/ReactiveFormModel.swift"><code>SwiftUI-Notes/ReactiveFormModel.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>SwiftUI 视图是基于某些已知状态呈现的声明性结构，当该状态发生变化时，这些当前的结构将失效并更新。
我们可以使用 Combine 来提供响应式更新来操纵此状态，并将其暴露回 SwiftUI。
此处提供的示例是一个简单的输入表单，目的是根据对两个字段的输入提供响应式和动态的反馈。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下规则被编码到 Combine 的管道中：
1. 两个字段必须相同 - 如输入密码或电子邮件地址，然后通过第二个条目进行确认。
2. 输入的值至少为 5 个字符的长度。
3. 根据这些规则的结果启用或禁用提交按钮。</p>
</div>
<div class="paragraph">
<p>SwiftUI 通过将状态外化为类中的属性，并使用 <code>ObservableObject</code> 协议将该类引用到模型中来实现此目的。
两个属性 <code>firstEntry</code> 和 <code>secondEntry</code> 作为字符串使用 <a href="#reference-published">@Published</a> 属性包装，允许 SwiftUI 绑定到它们的更新，以及更新它们。
第三个属性 <code>submitAllowed</code> 暴露为 Combine 发布者，可在视图内使用，从而维护视图内部的 <code>@State buttonIsDisabled</code> 状态。
第四个属性 —— 一个 <code>validationMessages</code> 字符串数组 - 在 Combine 管道中将前两个属性进行组合计算，并且使用 <a href="#reference-published">@Published</a> 属性包装暴露给 SwiftUI。</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/SwiftUI-Notes/ReactiveFormModel.swift">SwiftUI-Notes/ReactiveFormModel.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">Foundation</span>
<span class="kd">import</span> <span class="kt">Combine</span>

<span class="kd">class</span> <span class="kt">ReactiveFormModel</span> <span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>

    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">firstEntry</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="n">firstEntryPublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">firstEntry</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">firstEntryPublisher</span> <span class="o">=</span> <span class="kt">CurrentValueSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">(</span><span class="s">""</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">secondEntry</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="n">secondEntryPublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">secondEntry</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">secondEntryPublisher</span> <span class="o">=</span> <span class="kt">CurrentValueSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">(</span><span class="s">""</span><span class="p">)</span>

    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">validationMessages</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">cancellableSet</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">var</span> <span class="nv">submitAllowed</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span>

    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>

        <span class="k">let</span> <span class="nv">validationPipeline</span> <span class="o">=</span> <span class="kt">Publishers</span><span class="o">.</span><span class="kt">CombineLatest</span><span class="p">(</span><span class="n">firstEntryPublisher</span><span class="p">,</span> <span class="n">secondEntryPublisher</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="k">in</span> <i class="conum" data-value="4"></i><b>(4)</b>
                <span class="k">var</span> <span class="nv">diagMsgs</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>
                <span class="k">let</span> <span class="p">(</span><span class="nv">value</span><span class="p">,</span> <span class="nv">value_repeat</span><span class="p">)</span> <span class="o">=</span> <span class="n">arg</span>
                <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">value_repeat</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">diagMsgs</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"Values for fields must match."</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">value_repeat</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">diagMsgs</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"Please enter values of at least 5 characters."</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">diagMsgs</span>
            <span class="p">}</span>

        <span class="n">submitAllowed</span> <span class="o">=</span> <span class="n">validationPipeline</span> <i class="conum" data-value="5"></i><b>(5)</b>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">stringArray</span> <span class="k">in</span>
                <span class="k">return</span> <span class="n">stringArray</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>

        <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">validationPipeline</span> <i class="conum" data-value="6"></i><b>(6)</b>
            <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">validationMessages</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">cancellableSet</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>firstEntry 和 secondEntry 都使用空字符串作为默认值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>然后，这些属性还用 <a href="#reference-currentvaluesubject">currentValueSubject</a> 进行镜像，该镜像属性使用来自每个 <code>@Published</code> 属性的 <code>didSet</code> 发送更新事件。这驱动下面定义的 Combine 管道，以便在值从 SwiftUI 视图更改时触发响应式更新。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><a href="#reference-combinelatest">combineLatest</a> 用于合并来自 <code>firstEntry</code> 或 <code>secondEntry</code> 的更新，以便从任一来源来触发更新。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><a href="#reference-map">map</a> 接受输入值并使用它们来确定和发布验证过的消息数组。该数据流 <code>validationPipeline</code> 是两个后续管道的发布源。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>第一个后续管道使用验证过的消息数组来确定一个 true 或 false 的布尔值发布者，用于启用或禁用提交按钮。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>第二个后续管道接受验证过的消息数组，并更新持有的该 ObservedObject 实例的 <code>validationMessages</code>，以便 SwiftUI 在需要时监听和使用它。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>两种不同的状态更新的暴露方法 —— 作为发布者或外部状态，在示例中都进行了展示，以便于你可以更好的利用任一种方法。
提交按钮启用/禁用的选项可作为 <code>@Published</code> 属性进行暴露，验证消息的数组可作为 <code>&lt;String[], Never&gt;</code> 类型的发布者而对外暴露。
如果需要涉及作为显式状态去跟踪用户行为，则通过暴露 <code>@Published</code> 属性可能更清晰、不直接耦合，但任一种机制都是可以使用的。</p>
</div>
<div class="paragraph">
<p>上述模型与声明式地使用外部状态的 SwiftUI 视图相耦合。</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/SwiftUI-Notes/ReactiveForm.swift">SwiftUI-Notes/ReactiveForm.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">struct</span> <span class="kt">ReactiveForm</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>

    <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">model</span><span class="p">:</span> <span class="kt">ReactiveFormModel</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="c1">// $model is a ObservedObject&lt;ExampleModel&gt;.Wrapper</span>
    <span class="c1">// and $model.objectWillChange is a Binding&lt;ObservableObjectPublisher&gt;</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">buttonIsDisabled</span> <span class="o">=</span> <span class="kc">true</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="c1">// $buttonIsDisabled is a Binding&lt;Bool&gt;</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Reactive Form"</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">headline</span><span class="p">)</span>

            <span class="kt">Form</span> <span class="p">{</span>
                <span class="kt">TextField</span><span class="p">(</span><span class="s">"first entry"</span><span class="p">,</span> <span class="nv">text</span><span class="p">:</span> <span class="err">$</span><span class="n">model</span><span class="o">.</span><span class="n">firstEntry</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
                    <span class="o">.</span><span class="nf">textFieldStyle</span><span class="p">(</span><span class="kt">RoundedBorderTextFieldStyle</span><span class="p">())</span>
                    <span class="o">.</span><span class="nf">lineLimit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="o">.</span><span class="nf">multilineTextAlignment</span><span class="p">(</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
                    <span class="o">.</span><span class="nf">padding</span><span class="p">()</span>

                <span class="kt">TextField</span><span class="p">(</span><span class="s">"second entry"</span><span class="p">,</span> <span class="nv">text</span><span class="p">:</span> <span class="err">$</span><span class="n">model</span><span class="o">.</span><span class="n">secondEntry</span><span class="p">)</span>
                    <span class="o">.</span><span class="nf">textFieldStyle</span><span class="p">(</span><span class="kt">RoundedBorderTextFieldStyle</span><span class="p">())</span>
                    <span class="o">.</span><span class="nf">multilineTextAlignment</span><span class="p">(</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
                    <span class="o">.</span><span class="nf">padding</span><span class="p">()</span>

                <span class="kt">VStack</span> <span class="p">{</span>
                    <span class="kt">ForEach</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">validationMessages</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="n">msg</span> <span class="k">in</span> <i class="conum" data-value="4"></i><b>(4)</b>
                        <span class="kt">Text</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                            <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">red</span><span class="p">)</span>
                            <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">callout</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{})</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Submit"</span><span class="p">)</span>
            <span class="p">}</span><span class="o">.</span><span class="nf">disabled</span><span class="p">(</span><span class="n">buttonIsDisabled</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">onReceive</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">submitAllowed</span><span class="p">)</span> <span class="p">{</span> <span class="n">submitAllowed</span> <span class="k">in</span> <i class="conum" data-value="5"></i><b>(5)</b>
                    <span class="k">self</span><span class="o">.</span><span class="n">buttonIsDisabled</span> <span class="o">=</span> <span class="o">!</span><span class="n">submitAllowed</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">padding</span><span class="p">()</span>
            <span class="o">.</span><span class="nf">background</span><span class="p">(</span><span class="kt">RoundedRectangle</span><span class="p">(</span><span class="nv">cornerRadius</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">stroke</span><span class="p">(</span><span class="kt">Color</span><span class="o">.</span><span class="n">blue</span><span class="p">,</span> <span class="nv">lineWidth</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="kt">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ReactiveForm_Previews</span><span class="p">:</span> <span class="kt">PreviewProvider</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">previews</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">ReactiveForm</span><span class="p">(</span><span class="nv">model</span><span class="p">:</span> <span class="kt">ReactiveFormModel</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>数据模型使用 <code>@ObservedObject</code> 暴露给 SwiftUI。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@State</code> buttonIsDisabled 在该视图中被声明为局部变量，有一个默认值 <code>true</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>属性包装(<code>$model.firstEntry</code> 和 <code>$model.secondEntry</code>) 的预计值用于将绑定传递到 TextField 视图元素。当用户更改值时，<code>Binding</code> 将触发引用模型上的更新，并让 SwiftUI 的组件知道，如果暴露的模型正在被更改，则组件的更改也即将发生。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在数据模型中生成和 assign 的验证消息，作为 Combine 管道的发布者，在这儿对于 SwiftUI 是不可见的。相反，这只能对这些被暴露的值的变化所引起的模型的变化做出反应，而不关心改变这些值的机制。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>作为如何使用带有 <a href="#reference-onreceive">onReceive</a> 的发布者的示例，使用 <code>onReceive</code> 订阅者来监听引用模型中暴露的发布者。在这个例子中，我们接受值并把它们作为局部变量 <code>@State</code> 存储在 SwiftUI 的视图中，但它也可以在一些转化后使用，如果该逻辑只和视图显示的结果值强相关的话。在这，我们将其与 <code>Button</code> 上的 <code>disabled</code> 一起使用，使 SwiftUI 能够根据 <code>@State</code> 中存储的值启用或禁用该 UI 元素。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="patterns-testing-and-debugging">测试和调试</h3>
<div class="paragraph">
<p>Combine 中的发布者和订阅者接口是非常易于测试的。</p>
</div>
<div class="paragraph">
<p>借助 Combine 的可组合性，你可以利用此优势创建或消费符合 <a href="https://developer.apple.com/documentation/combine/publisher">Publisher</a> 协议的 API。</p>
</div>
<div class="paragraph">
<p>以 <a href="https://developer.apple.com/documentation/combine/publisher">publisher protocol</a> 为关键接口，你可以替换任何一方以单独验证你的代码。</p>
</div>
<div class="paragraph">
<p>例如，如果你的代码专注于通过 Combine 从外部 Web 服务中提供其数据，则可能会使此接口遵循 <code>AnyPublisher&lt;Data, Error&gt;</code>。
然后，你可以使用该接口独立测试管道的任何一侧。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>你可以模拟 API 请求和可能响应的数据，包括各种错误条件。
这可以包括使用 <a href="#reference-just">Just</a> 或 <a href="#reference-fail">Fail</a> 创建的发布者来返回数据，或者更复杂的使用 <a href="#reference-future">Future</a>。
使用这些方案都不需要你进行实际的网络接口调用。</p>
</li>
<li>
<p>同样，你也可以隔离测试，让发布者进行 API 调用，并验证预期的各种成功和失败条件。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="patterns-testing-publisher">使用 XCTestExpectation 测试发布者</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>用于测试发布者（以及连接的任何管道）</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift">UsingCombineTests/DataTaskPublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EmptyPublisherTests.swift">UsingCombineTests/EmptyPublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FuturePublisherTests.swift">UsingCombineTests/FuturePublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift">UsingCombineTests/PublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift">UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-testing-publisher">使用 XCTestExpectation 测试发布者</a></p>
</li>
<li>
<p><a href="#patterns-testing-subscriber-scheduled">使用从 PassthroughSubject 预定好的发送的事件测试订阅者</a></p>
</li>
<li>
<p><a href="#patterns-testing-subscriber">使用 PassthroughSubject 测试订阅者</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>当你测试发布者或创建发布者的某些代码时，你可能无法控制发布者何时返回数据以进行测试。
由其订阅者驱动的 Combine 可以设置一个同步事件来启动数据流。
你可以使用 <a href="https://developer.apple.com/documentation/xctest/xctestexpectation">XCTestExpectation</a> 等待一段确定的时间之后，再调用 completion 闭包进行测试。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>此与 Combine 一起使用的模式：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在测试中设置 expectation。</p>
</li>
<li>
<p>确定要测试的代码。</p>
</li>
<li>
<p>设置要调用的代码，以便在执行成功的情况下，你调用 expectation 的 <code>.fulfill()</code> 函数。</p>
</li>
<li>
<p>设置具有明确超时时间的 <code>wait()</code> 函数，如果 expectation 在该时间窗口内未调用 <code>fulfill()</code>，则测试将失败。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果你正在测试管道中的结果数据，那么在 <a href="#reference-sink">sink</a> 操作符的 <code>receiveValue</code> 闭包中触发 <code>fulfill()</code> 函数是非常方便的。
如果你正在测试管道中的失败情况，则通常在 <a href="#reference-sink">sink</a> 操作符的 <code>receiveCompletion</code> 闭包中包含 <code>fulfill()</code> 方法是有效的。</p>
</div>
<div class="paragraph">
<p>下列示例显示使用 expectation 测试一次性发布者(本例中是 <a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a>)，并期望数据在不出错的情况下流动。</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift#L47">UsingCombineTests/DataTaskPublisherTests.swift - testDataTaskPublisher</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">func</span> <span class="nf">testDataTaskPublisher</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// setup</span>
        <span class="k">let</span> <span class="nv">expectation</span> <span class="o">=</span> <span class="kt">XCTestExpectation</span><span class="p">(</span><span class="nv">description</span><span class="p">:</span> <span class="s">"Download from </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">testURL</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">let</span> <span class="nv">remoteDataPublisher</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">testURL</span><span class="o">!</span><span class="p">)</span>
            <span class="c1">// validate</span>
            <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">fini</span> <span class="k">in</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received the completion"</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">fini</span><span class="p">))</span>
                <span class="k">switch</span> <span class="n">fini</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">.</span><span class="nv">finished</span><span class="p">:</span> <span class="n">expectation</span><span class="o">.</span><span class="nf">fulfill</span><span class="p">()</span> <i class="conum" data-value="2"></i><b>(2)</b>
                <span class="k">case</span> <span class="o">.</span><span class="nv">failure</span><span class="p">:</span> <span class="kt">XCTFail</span><span class="p">()</span> <i class="conum" data-value="3"></i><b>(3)</b>
                <span class="p">}</span>
            <span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span> <span class="k">in</span>
                <span class="k">guard</span> <span class="k">let</span> <span class="nv">httpResponse</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">XCTFail</span><span class="p">(</span><span class="s">"Unable to parse response an HTTPURLResponse"</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="p">}</span>
                <span class="kt">XCTAssertNotNil</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="c1">// print(".sink() data received \(data)")</span>
                <span class="kt">XCTAssertNotNil</span><span class="p">(</span><span class="n">httpResponse</span><span class="p">)</span>
                <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
                <span class="c1">// print(".sink() httpResponse received \(httpResponse)")</span>
            <span class="p">})</span>

        <span class="kt">XCTAssertNotNil</span><span class="p">(</span><span class="n">remoteDataPublisher</span><span class="p">)</span>
        <span class="nf">wait</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="p">[</span><span class="n">expectation</span><span class="p">],</span> <span class="nv">timeout</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Expectation 设置为一个字符串，这样在发生失败时更容易调试。
此字符串仅在测试失败时才能看到。
我们在这里测试的代码是 <code>dataTaskPublisher</code> 从测试前就已定义好的预设的 URL 中取回数据。
发布者通过将 <a href="#reference-sink">sink</a> 订阅者连接到它开始触发请求。
如果没有 expectation，代码仍将运行，但构建的测试运行结构将不会等到结果返回之后再去检查是否有任何意外。
测试中的 expectation "暂停测试" 去等待响应，让操作符先发挥它们的作用。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在这个例子中，测试期望可以成功完成并正常终止，因此在 <code>receiveCompletion</code> 闭包内调用 <code>expectation.fulfill()</code>，具体是接收到 <code>.finished</code> completion 后调用。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>由于我们不期望失败，如果我们收到 <code>.failure</code> completion，我们也明确地调用 <code>XCTFail()</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们在 <code>receiveValue</code> 中还有一些其他断言。
由于此发布者设置返回单个值然后终止，因此我们可以对收到的数据进行内联断言。
如果我们收到多个值，那么我们可以收集这些值，并就事后收到的内容做出断言。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>此测试使用单个 expectation，但你可以包含多个独立的 expectation，去要求它们都被 <code>fulfill()</code>。
它还规定此测试的最长运行时间为 5 秒。
测试并不总是需要五秒钟，因为一旦收到 fulfill，它就会完成。
如果出于某种原因，测试需要超过五秒钟的响应时间，XCTest 将报告测试失败。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-testing-subscriber">使用 PassthroughSubject 测试订阅者</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>为了测试订阅者或包含订阅者的代码，我们可以使用 PassthroughSubject 模拟发布源，明确地控制哪些数据被发送和何时发送。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EncodeDecodeTests.swift">UsingCombineTests/EncodeDecodeTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FilterPublisherTests.swift">UsingCombineTests/FilterPublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FuturePublisherTests.swift">UsingCombineTests/FuturePublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/RetryPublisherTests.swift">UsingCombineTests/RetryPublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SinkSubscriberTests.swift">UsingCombineTests/SinkSubscriberTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SwitchAndFlatMapPublisherTests.swift">UsingCombineTests/SwitchAndFlatMapPublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift">UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-testing-publisher">使用 XCTestExpectation 测试发布者</a></p>
</li>
<li>
<p><a href="#reference-passthroughsubject">passthroughSubject</a></p>
</li>
<li>
<p><a href="#patterns-testing-subscriber-scheduled">使用从 PassthroughSubject 预定好的发送的事件测试订阅者</a></p>
</li>
<li>
<p><a href="#patterns-testable-publisher-subscriber">使用 EntwineTest 创建可测试的发布器和订阅者</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>当你单独测试订阅者时，你可以通过使用 <a href="#reference-passthroughsubject">passthroughSubject</a> 模拟发布者以及使用相关的 <code>.send()</code> 方法触发更新来更精细的控制测试。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>此模式依赖于订阅者在构建时设置发布者-订阅者生命周期的初始部分，并让代码保持等待直到提供数据。
使用 <code>PassthroughSubject</code>，发送数据以触发管道和订阅者闭包，或跟踪可以被验证的状态更改，即可控制测试代码本身。</p>
</div>
<div class="paragraph">
<p>当你测试订阅者对失败的反应时，这种测试模式也非常有效，否则可能会终止订阅。</p>
</div>
<div class="paragraph">
<p>使用这种测试构建方法的一般模式是：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>设置你的 subscriber 和任何你想包含在测试中影响它的管道。</p>
</li>
<li>
<p>在测试中创建一个 <code>PassthroughSubject</code>，构造合适的输出类型和失败类型以与订阅者匹配。</p>
</li>
<li>
<p>为任何初始值或先决条件设置断言。</p>
</li>
<li>
<p>通过 subject 发送数据。</p>
</li>
<li>
<p>测试发送数据的结果 —— 直接测试数据或断言预期的状态更改。</p>
</li>
<li>
<p>如果需要，发送其他数据。</p>
</li>
<li>
<p>测试状态或其他变化的进一步演变。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>此模式的示例如下：</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SinkSubscriberTests.swift#L44">UsingCombineTests/SinkSubscriberTests.swift - testSinkReceiveDataThenError</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">func</span> <span class="nf">testSinkReceiveDataThenError</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// setup - preconditions </span><i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">let</span> <span class="nv">expectedValues</span> <span class="o">=</span> <span class="p">[</span><span class="s">"firstStringValue"</span><span class="p">,</span> <span class="s">"secondStringValue"</span><span class="p">]</span>
    <span class="kd">enum</span> <span class="kt">TestFailureCondition</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">anErrorExample</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">countValuesReceived</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">countCompletionsReceived</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">// setup</span>
    <span class="k">let</span> <span class="nv">simplePublisher</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">()</span> <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">simplePublisher</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
            <span class="n">countCompletionsReceived</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">switch</span> <span class="n">completion</span> <span class="p">{</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="k">case</span> <span class="o">.</span><span class="nv">finished</span><span class="p">:</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received the completion:"</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">completion</span><span class="p">))</span>
                <span class="c1">// no associated data, but you can react to knowing the</span>
                <span class="c1">// request has been completed</span>
                <span class="kt">XCTFail</span><span class="p">(</span><span class="s">"We should never receive the completion, the error should happen first"</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">case</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="k">let</span> <span class="nv">anError</span><span class="p">):</span>
                <span class="c1">// do what you want with the error details, presenting,</span>
                <span class="c1">// logging, or hiding as appropriate</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"received the error: "</span><span class="p">,</span> <span class="n">anError</span><span class="p">)</span>
                <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">anError</span><span class="o">.</span><span class="n">localizedDescription</span><span class="p">,</span>
                               <span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">anErrorExample</span><span class="o">.</span><span class="n">localizedDescription</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">someValue</span> <span class="k">in</span> <i class="conum" data-value="6"></i><b>(6)</b>
            <span class="c1">// do what you want with the resulting value passed down</span>
            <span class="c1">// be aware that depending on the data type being returned,</span>
            <span class="c1">// you may get this closure invoked multiple times.</span>
            <span class="kt">XCTAssertNotNil</span><span class="p">(</span><span class="n">someValue</span><span class="p">)</span>
            <span class="kt">XCTAssertTrue</span><span class="p">(</span><span class="n">expectedValues</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">someValue</span><span class="p">))</span>
            <span class="n">countValuesReceived</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received </span><span class="se">\(</span><span class="n">someValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">})</span>

    <span class="c1">// validate</span>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countValuesReceived</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countCompletionsReceived</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="s">"firstStringValue"</span><span class="p">)</span> <i class="conum" data-value="8"></i><b>(8)</b>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countValuesReceived</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countCompletionsReceived</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="s">"secondStringValue"</span><span class="p">)</span>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countValuesReceived</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countCompletionsReceived</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">anErrorExample</span><span class="p">))</span>  <i class="conum" data-value="9"></i><b>(9)</b>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countValuesReceived</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countCompletionsReceived</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1">// this data will never be seen by anything in the pipeline above because</span>
    <span class="c1">// we have already sent a completion</span>
    <span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">.</span><span class="n">finished</span><span class="p">)</span> <i class="conum" data-value="10"></i><b>(10)</b>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countValuesReceived</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">countCompletionsReceived</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>此测试设置了一些变量，以便在测试执行期间捕获和修改它们，用于验证 sink 代码的执行时间和工作方式。
此外，我们在此处定义了一个错误，以便在我们的测试代码中使用它来验证失败的情况。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>此代码设置为使用 <a href="#reference-passthroughsubject">passthroughSubject</a> 来驱动测试，但我们感兴趣的测试代码是订阅者。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>该订阅者被配置在测试下（在这儿是一个标准的 <a href="#reference-sink">sink</a>）。
我们配置了在接收到数据和 completion 时会触发的代码。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在接收到 completion 时，我们对其调用 switch，添加了一个断言，如果 finish 被调用了，将不通过测试，因为我们期望只会生成 <code>.failure</code> completion。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Swift 中的测试错误是否相等没那么容易，但如果错误是你正在控制的代码，有时你可以使用 <code>localizedDescription</code> 作为测试收到的错误类型的便捷方式。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>receiveValue</code> 闭包在考虑如何对收到的值进行断言时更为复杂。
由于我们在此测试过程中会收到多个值，我们有一些额外的逻辑来检查值是否在我们发送的集合内。
与 completion 的处理逻辑一样，我们还是增加测试特定变量，我们将在以后断言这些变量以验证状态和操作顺序。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>在我们发送任何数据以仔细检查我们的假设之前，我们先验证计数变量。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>在测试中，<code>send()</code> 触发了操作，之后我们就可以立即通过验证我们更新的测试变量来验证所产生的效果了。
在你自己的代码中，你可能无法（或不想要）修改你的订阅者，但你可能能够向对象提供私有/可测试的属性或途径，以类似的方式验证它们。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>我们还使用 <code>send()</code> 发送一个 completion，在这个例子中是一个失败的 completion。</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>最后的 <code>send()</code> 验证刚刚发生的失败事件 —— 当前发送的 finished completion 应该没有被处理，并且应该没有后续的状态更新再发生。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-testing-subscriber-scheduled">使用从 PassthroughSubject 预定好的发送的事件测试订阅者</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>当你想要测试的是管道的时序时，用于测试管道或订阅者。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift">UsingCombineTests/PublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FuturePublisherTests.swift">UsingCombineTests/FuturePublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SinkSubscriberTests.swift">UsingCombineTests/SinkSubscriberTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SwitchAndFlatMapPublisherTests.swift">UsingCombineTests/SwitchAndFlatMapPublisherTests.swift</a></p>
</li>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift">UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-testing-subscriber">使用 PassthroughSubject 测试订阅者</a></p>
</li>
<li>
<p><a href="#patterns-testable-publisher-subscriber">使用 EntwineTest 创建可测试的发布器和订阅者</a></p>
</li>
<li>
<p><a href="#patterns-testing-publisher">使用 XCTestExpectation 测试发布者</a></p>
</li>
<li>
<p><a href="#reference-passthroughsubject">passthroughSubject</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>在 Combine 中有许多针对数据时序的操作符，包括 <a href="#reference-debounce">debounce</a>、<a href="#reference-throttle">throttle</a> 以及 <a href="#reference-delay">delay</a>。
在进行 UI 测试之外，你可能需要测试你的管道时序具有所需的效果。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>实现这个的方法之一是利用 <a href="https://developer.apple.com/documentation/xctest/xctestexpectation">XCTestExpectation</a> 和 <a href="#reference-passthroughsubject">passthroughSubject</a>，将两者结合起来。
基于 <a href="#patterns-testing-publisher">使用 XCTestExpectation 测试发布者</a> 和 <a href="#patterns-testing-subscriber">使用 PassthroughSubject 测试订阅者</a>，在测试中添加 <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue">DispatchQueue</a>，以安排 PassthroughSubject 的 <code>.send()</code> 方法的调用。</p>
</div>
<div class="paragraph">
<p>一个这种用法的例子：</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift#L178">UsingCombineTests/PublisherTests.swift - testKVOPublisher</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">func</span> <span class="nf">testKVOPublisher</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">expectation</span> <span class="o">=</span> <span class="kt">XCTestExpectation</span><span class="p">(</span><span class="nv">description</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">debugDescription</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">foo</span> <span class="o">=</span> <span class="kt">KVOAbleNSObject</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">q</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">debugDescription</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">intValue</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">print</span><span class="p">()</span>
        <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">someValue</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"value of intValue updated to: &gt;&gt;</span><span class="se">\(</span><span class="n">someValue</span><span class="se">)</span><span class="s">&lt;&lt;"</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="n">q</span><span class="o">.</span><span class="nf">asyncAfter</span><span class="p">(</span><span class="nv">deadline</span><span class="p">:</span> <span class="o">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nv">execute</span><span class="p">:</span> <span class="p">{</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Updating to foo.intValue on background queue"</span><span class="p">)</span>
        <span class="n">foo</span><span class="o">.</span><span class="n">intValue</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">expectation</span><span class="o">.</span><span class="nf">fulfill</span><span class="p">()</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="p">})</span>
    <span class="nf">wait</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="p">[</span><span class="n">expectation</span><span class="p">],</span> <span class="nv">timeout</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这将为你的测试添加 <code>DispatchQueue</code>，并以测试的描述 debugDescription 来命名该队列。
这只在调试中测试失败时显示，并且在还有其它后台线程也在使用时，方便地提醒测试代码中发生了什么情况。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>.asyncAfter</code> 和参数 deadline 一起使用，用来定义何时发起请求.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>这是将任何相关的断言嵌入到订阅者或其周围的最简单的方式。此外，将 <code>.fulfill()</code> 作为你发送队列的最后一个条目，好让测试知道它现在已完成。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>请确保当你设置等待超时时间时，有足够的时间让你的队列被调用。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>此技术的一个明显缺点是，它使得测试花费的最短时间至少是测试中的最大的队列延迟。</p>
</div>
<div class="paragraph">
<p>另一种选择是第三方库，名为 EntwineTest，开发灵感来自 RxTest 库。
EntwineTest 是 Entwine 的一部分，一个提供了一些 helpers 扩展了 Combine 的 Swift 库。
该库可以在 github 上找到，位于 <a href="https://github.com/tcldr/Entwine.git，只要使用时遵守" class="bare">https://github.com/tcldr/Entwine.git，只要使用时遵守</a> MIT 证书即可。</p>
</div>
<div class="paragraph">
<p>EntwineTest 中包含的关键元素之一是虚拟时间调度器，以及使用此调度器时安排（<code>TestablePublisher</code>）并收集和记录（<code>TestableSubscriber</code>）结果时间的其他类。</p>
</div>
<div class="paragraph">
<p>来自 EntwineTest 工程的 README 中的一个例子包含在：</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EntwineTestExampleTests.swift">UsingCombineTests/EntwineTestExampleTests.swift - testExampleUsingVirtualTimeScheduler</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">func</span> <span class="nf">testExampleUsingVirtualTimeScheduler</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">scheduler</span> <span class="o">=</span> <span class="kt">TestScheduler</span><span class="p">(</span><span class="nv">initialClock</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">var</span> <span class="nv">didSink</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="kt">Just</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="o">.</span><span class="nf">delay</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">scheduler</span><span class="p">)</span>
        <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
            <span class="n">didSink</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="p">}</span>

    <span class="kt">XCTAssertNotNil</span><span class="p">(</span><span class="n">cancellable</span><span class="p">)</span>
    <span class="c1">// where a real scheduler would have triggered when .sink() was invoked</span>
    <span class="c1">// the virtual time scheduler requires resume() to commence and runs to</span>
    <span class="c1">// completion.</span>
    <span class="n">scheduler</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="kt">XCTAssertTrue</span><span class="p">(</span><span class="n">didSink</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用虚拟时间调度器需要在测试开始时创建一个，将其时钟初始化为起始值。
EntwineTest 中的虚拟时间调度器将以 <code>200</code> 的值开始订阅，如果管道在时间为 <code>900</code> 时还没完成，则会超时。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>你和以往创建任何发布者或订阅者一样，创建你的管道。
EntwineTest 还提供可测试的发布者和订阅者，以供使用。
有关 EntwineTest 这些部分的更多详细信息，请看 <a href="#patterns-testable-publisher-subscriber">使用 EntwineTest 创建可测试的发布器和订阅者</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>.resume()</code> 需要在虚拟时间调度器上调用，以开始其工作和触发管道运行。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在管道运行到完成后，对预期的最终结果进行断言。</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-testable-publisher-subscriber">使用 EntwineTest 创建可测试的发布器和订阅者</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>当你想要测试的是管道的时序时，用于测试管道或订阅者。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EntwineTestExampleTests.swift">UsingCombineTests/EntwineTestExampleTests.swift</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-testing-publisher">使用 XCTestExpectation 测试发布者</a></p>
</li>
<li>
<p><a href="#patterns-testing-subscriber">使用 PassthroughSubject 测试订阅者</a></p>
</li>
<li>
<p><a href="#patterns-testing-subscriber-scheduled">使用从 PassthroughSubject 预定好的发送的事件测试订阅者</a></p>
</li>
<li>
<p><a href="#reference-passthroughsubject">passthroughSubject</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>EntwineTest 库可在 gitHub <a href="https://github.com/tcldr/Entwine.git" class="bare">https://github.com/tcldr/Entwine.git</a> 找到，为使管道可测试提供了一些额外的选择。
除了虚拟时间调度器外，EntwineTest 还有一个 <code>TestablePublisher</code> 和 <code>TestableSubscriber</code>。
这些与虚拟时间调度器协调工作，允许你指定发布者生成数据的时间，并验证订阅者收到的数据。</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>截至 Xcode 11.2，SwiftPM 存在影响使用 Entwine 作为测试库的 bug。
详细信息可在 Swift 的开源 bug 报告中找到 <a href="https://bugs.swift.org/plugins/servlet/mobile#issue/SR-11564">SR-11564</a>。</p>
</div>
<div class="paragraph">
<p>如果使用 Xcode 11.2，你可能需要应用该解决方法，将项目设置修改为 <code>DEAD_CODE_STRIPPING=NO</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>包含在 EntwineTest 项目中的一个这样的例子：</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EntwineTestExampleTests.swift">UsingCombineTests/EntwineTestExampleTests.swift - testMap</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">XCTest</span>
<span class="kd">import</span> <span class="kt">EntwineTest</span>
<span class="c1">// library loaded from</span>
<span class="c1">// https://github.com/tcldr/Entwine/blob/master/Assets/EntwineTest/README.md</span>
<span class="c1">// as a Swift package https://github.com/tcldr/Entwine.git : 0.6.0,</span>
<span class="c1">// Next Major Version</span>

<span class="kd">class</span> <span class="kt">EntwineTestExampleTests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>

    <span class="kd">func</span> <span class="nf">testMap</span><span class="p">()</span> <span class="p">{</span>

        <span class="k">let</span> <span class="nv">testScheduler</span> <span class="o">=</span> <span class="kt">TestScheduler</span><span class="p">(</span><span class="nv">initialClock</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1">// creates a publisher that will schedule its elements relatively</span>
        <span class="c1">// at the point of subscription</span>
        <span class="k">let</span> <span class="nv">testablePublisher</span><span class="p">:</span> <span class="kt">TestablePublisher</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">testScheduler</span><span class="o">.</span><span class="nf">createRelativeTestablePublisher</span><span class="p">([</span> <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="o">.</span><span class="nf">input</span><span class="p">(</span><span class="s">"a"</span><span class="p">)),</span>
            <span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="o">.</span><span class="nf">input</span><span class="p">(</span><span class="s">"b"</span><span class="p">)),</span>
            <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="o">.</span><span class="nf">input</span><span class="p">(</span><span class="s">"c"</span><span class="p">)),</span>
        <span class="p">])</span>

        <span class="c1">// a publisher that maps strings to uppercase</span>
        <span class="k">let</span> <span class="nv">subjectUnderTest</span> <span class="o">=</span> <span class="n">testablePublisher</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">uppercased</span><span class="p">()</span> <span class="p">}</span>

        <span class="c1">// uses the method described above (schedules a subscription at 200</span>
        <span class="c1">// to be cancelled at 900)</span>
        <span class="k">let</span> <span class="nv">results</span> <span class="o">=</span> <span class="n">testScheduler</span><span class="o">.</span><span class="n">start</span> <span class="p">{</span> <span class="n">subjectUnderTest</span> <span class="p">}</span> <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">recordedOutput</span><span class="p">,</span> <span class="p">[</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="o">.</span><span class="n">subscription</span><span class="p">),</span>
            <span class="c1">// subscribed at 200</span>
            <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="o">.</span><span class="nf">input</span><span class="p">(</span><span class="s">"A"</span><span class="p">)),</span>
            <span class="c1">// received uppercased input @ 100 + subscription time</span>
            <span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="o">.</span><span class="nf">input</span><span class="p">(</span><span class="s">"B"</span><span class="p">)),</span>
            <span class="c1">// received uppercased input @ 200 + subscription time</span>
            <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="o">.</span><span class="nf">input</span><span class="p">(</span><span class="s">"C"</span><span class="p">)),</span>
            <span class="c1">// received uppercased input @ 300 + subscription time</span>
        <span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>TestablePublisher</code> 允许你设置一个在特定时间返回特定值的发布者。
在这个例子中，它会以相同的间隔返回 3 个值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>当你使用虚拟时间调度器时，重要的是要确保从 start 开始调用它。
这会启动虚拟时间调度器，它的运行速度可以比时钟快，因为它只需要增加虚拟时间，而不是等待真实过去的时间。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>results</code> 是一个 TestableSubscriber 对象，包括 <code>recordedOutput</code> 属性，该属性提供所有数据的有序列表，并将控制事件的交互与其时间组合在一起。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果这个测试序列是用 asyncAfter 完成的，那么测试将至少需要 500ms 才能完成。
当我在我的笔记本电脑上运行此测试时，它记录花费了 0.0121 秒以完成测试（12.1ms）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>EntwineTest 的副作用是，使用虚拟时间调度器的测试比实时时钟运行速度快得多。
使用实时调度机制来延迟数据发送值的相同测试可能需要更长的时间才能完成。</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-debugging-print">使用 print 操作符调试管道</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>为了了解管道中正在发生的事情，查看所有控制事件和数据交互。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-print">print</a></p>
</li>
<li>
<p><a href="#reference-sink">sink</a></p>
</li>
<li>
<p><a href="#reference-retry">retry</a></p>
</li>
<li>
<p>带有此代码的 ViewController 在 github 项目位于 <a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubViewController.swift">UIKit-Combine/GithubViewController.swift</a></p>
</li>
<li>
<p>retry 的单元测试在 github 项目中位于 <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/RetryPublisherTests.swift">UsingCombineTests/RetryPublisherTests.swift</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-cascading-update-interface">级联多个 UI 更新，包括网络请求</a></p>
</li>
<li>
<p><a href="#patterns-sequencing-operations">有序的异步操作</a></p>
</li>
<li>
<p><a href="#patterns-update-interface-userinput">通过用户输入更新声明式 UI</a></p>
</li>
<li>
<p><a href="#patterns-debugging-breakpoint">使用调试器调试管道</a></p>
</li>
<li>
<p><a href="#patterns-debugging-handleevents">使用 handleEvents 操作符调试管道</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>我获取的最详细的信息来自有选择地使用 <a href="#reference-print">print</a> 操作符。
缺点是它打印了大量信息，因此输出可能很快变得非常庞大。
要理解简单的管道，使用 <code>.print()</code> 作为没有任何参数的操作符是非常简单的。
一旦你想要添加多个 print 操作符，你可能要使用 string 参数，该参数会作为前缀放在输出中。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>示例 <a href="#patterns-cascading-update-interface">级联多个 UI 更新，包括网络请求</a> 在几个地方都有用到它，使用比较长的描述性前缀，以明确是哪个管道在提供信息。</p>
</div>
<div class="paragraph">
<p>通过连接到一个私有的 <code>@Published</code> 的变量 —— githubUserData，两个管道被层叠到了一起。
该示例代码中的两个相关管道：</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubViewController.swift">UIKit-Combine/GithubViewController.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">usernameSubscriber</span> <span class="o">=</span> <span class="err">$</span><span class="n">username</span>
    <span class="o">.</span><span class="nf">throttle</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">myBackgroundQueue</span><span class="p">,</span> <span class="nv">latest</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
    <span class="c1">// ^^ scheduler myBackGroundQueue publishes resulting elements</span>
    <span class="c1">// into that queue, resulting on this processing moving off the</span>
    <span class="c1">// main runloop.</span>
    <span class="o">.</span><span class="nf">removeDuplicates</span><span class="p">()</span>
    <span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"username pipeline: "</span><span class="p">)</span> <span class="c1">// debugging output for pipeline</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">username</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">GithubAPIUser</span><span class="p">],</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="k">in</span>
        <span class="k">return</span> <span class="kt">GithubAPI</span><span class="o">.</span><span class="nf">retrieveGithubUser</span><span class="p">(</span><span class="nv">username</span><span class="p">:</span> <span class="n">username</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// ^^ type returned in the pipeline is a Publisher, so we use</span>
    <span class="c1">// switchToLatest to flatten the values out of that</span>
    <span class="c1">// pipeline to return down the chain, rather than returning a</span>
    <span class="c1">// publisher down the pipeline.</span>
    <span class="o">.</span><span class="nf">switchToLatest</span><span class="p">()</span>
    <span class="c1">// using a sink to get the results from the API search lets us</span>
    <span class="c1">// get not only the user, but also any errors attempting to get it.</span>
    <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">githubUserData</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>

<span class="c1">// using .assign() on the other hand (which returns an</span>
<span class="c1">// AnyCancellable) *DOES* require a Failure type of &lt;Never&gt;</span>
<span class="n">repositoryCountSubscriber</span> <span class="o">=</span> <span class="err">$</span><span class="n">githubUserData</span>
    <span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"github user data: "</span><span class="p">)</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">userData</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">in</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">firstUser</span> <span class="o">=</span> <span class="n">userData</span><span class="o">.</span><span class="n">first</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">firstUser</span><span class="o">.</span><span class="n">public_repos</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="s">"unknown"</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">repositoryCountLabel</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当你运行 UIKit-Combine 示例代码时，随着我慢慢的输入用户名 <code>heckj</code>，终端会显示以下输出。
在进行这些查找的过程中，在最终的帐户之前发现并检索到了另外两个 github 帐户（<code>hec</code> 和 <code>heck</code>）。</p>
</div>
<div class="listingblock">
<div class="title">模拟器的交互输出</div>
<div class="content">
<pre class="rouge highlight"><code>username pipeline: : receive subscription: (RemoveDuplicates)
username pipeline: : request unlimited
github user data: : receive subscription: (CurrentValueSubject)
github user data: : request unlimited
github user data: : receive value: ([])
username pipeline: : receive value: ()
github user data: : receive value: ([])

Set username to  h
username pipeline: : receive value: (h)
github user data: : receive value: ([])

Set username to  he
username pipeline: : receive value: (he)
github user data: : receive value: ([])

Set username to  hec
username pipeline: : receive value: (hec)

Set username to  heck
github user data: : receive value: ([UIKit_Combine.GithubAPIUser(login: "hec", public_repos: 3, avatar_url: "https://avatars3.githubusercontent.com/u/53656?v=4")])

username pipeline: : receive value: (heck)
github user data: : receive value: ([UIKit_Combine.GithubAPIUser(login: "heck", public_repos: 6, avatar_url: "https://avatars3.githubusercontent.com/u/138508?v=4")])

Set username to  heckj
username pipeline: : receive value: (heckj)
github user data: : receive value: ([UIKit_Combine.GithubAPIUser(login: "heckj", public_repos: 69, avatar_url: "https://avatars0.githubusercontent.com/u/43388?v=4")])</code></pre>
</div>
</div>
<div class="paragraph">
<p>一些放在 <a href="#reference-sink">sink</a> 闭包中，用来查看最终结果的无关打印语句已被删除。</p>
</div>
<div class="paragraph">
<p>你可以在开始时看到初始化订阅的设置，然后看到通知，包括通过 <code>print</code> 操作符传递的值的调试信息。
虽然上面的示例内容中未显示它，但你还会在出现错误时看到取消管道的事件，或在发布者报告没有进一步数据时的 completions 事件。</p>
</div>
<div class="paragraph">
<p>在操作符两侧使用 <code>print</code> 来了解其具体的操作方式也很有用。</p>
</div>
<div class="paragraph">
<p>一个这样做的例子如下，利用前缀显示 <a href="#reference-retry">retry</a> 操作符及其工作原理：</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/RetryPublisherTests.swift">UsingCombineTests/RetryPublisherTests.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">func</span> <span class="nf">testRetryWithOneShotFailPublisher</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// setup</span>

    <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="kt">Fail</span><span class="p">(</span><span class="nv">outputType</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">failure</span><span class="p">:</span> <span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">invalidServerResponse</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"(1)&gt;"</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="o">.</span><span class="nf">retry</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="s">"(2)&gt;"</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">fini</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">" ** .sink() received the completion:"</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">fini</span><span class="p">))</span>
        <span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">stringValue</span> <span class="k">in</span>
            <span class="kt">XCTAssertNotNil</span><span class="p">(</span><span class="n">stringValue</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">" ** .sink() received </span><span class="se">\(</span><span class="n">stringValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">})</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>前缀 <code>(1)</code> 是显示 <code>retry</code> 操作符上方的交互行为。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>前缀 <code>(2)</code> 是显示 <code>retry</code> 操作符之后的交互行为。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">单元测试的输出</div>
<div class="content">
<pre class="rouge highlight"><code>Test Suite 'Selected tests' started at 2019-07-26 15:59:48.042
Test Suite 'UsingCombineTests.xctest' started at 2019-07-26 15:59:48.043
Test Suite 'RetryPublisherTests' started at 2019-07-26 15:59:48.043
Test Case '-[UsingCombineTests.RetryPublisherTests testRetryWithOneShotFailPublisher]' started.
(1)&gt;: receive subscription: (Empty) <i class="conum" data-value="1"></i><b>(1)</b>
(1)&gt;: receive error: (invalidServerResponse)
(1)&gt;: receive subscription: (Empty)
(1)&gt;: receive error: (invalidServerResponse)
(1)&gt;: receive subscription: (Empty)
(1)&gt;: receive error: (invalidServerResponse)
(1)&gt;: receive subscription: (Empty)
(1)&gt;: receive error: (invalidServerResponse)
(2)&gt;: receive error: (invalidServerResponse) <i class="conum" data-value="2"></i><b>(2)</b>
 ** .sink() received the completion: failure(UsingCombineTests.RetryPublisherTests.TestFailureCondition.invalidServerResponse)
(2)&gt;: receive subscription: (Retry)
(2)&gt;: request unlimited
(2)&gt;: receive cancel
Test Case '-[UsingCombineTests.RetryPublisherTests testRetryWithOneShotFailPublisher]' passed (0.010 seconds).
Test Suite 'RetryPublisherTests' passed at 2019-07-26 15:59:48.054.
	 Executed 1 test, with 0 failures (0 unexpected) in 0.010 (0.011) seconds
Test Suite 'UsingCombineTests.xctest' passed at 2019-07-26 15:59:48.054.
	 Executed 1 test, with 0 failures (0 unexpected) in 0.010 (0.011) seconds
Test Suite 'Selected tests' passed at 2019-07-26 15:59:48.057.
	 Executed 1 test, with 0 failures (0 unexpected) in 0.010 (0.015) seconds</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在测试例子中，发布者总是返回失败，在输出结果中可以看到带有前缀 <code>(1)</code> 的错误信息，然后 <code>retry</code> 操作符触发重新订阅。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在其中4次尝试（3次"重试"）之后，你就会看到从管道中输出的错误。
当错误到达 sink 后，你会看到发出的 <code>cancel</code> 信号，该信号在重试操作符之后停止。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>虽然非常有效，但 <code>print</code> 操作符是一个钝器，它会生成大量的输出，你必须分析和审查它们以得到你想要的信息。
如果你想让标识和打印的内容更具选择性，或者如果你需要处理传输的数据才能更有意义地使用它们，那么你可以查看 <a href="#reference-handleevents">handleEvents</a> 操作符。
有关如何使用此操作符进行调试的更多详细信息，请查阅 <a href="#patterns-debugging-handleevents">使用 handleEvents 操作符调试管道</a>。</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-debugging-handleevents">使用 handleEvents 操作符调试管道</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>使用断点、打印、记录语句或其他额外的逻辑，以便更有针对性地了解管道内发生的情况。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-handleevents">handleEvents</a></p>
</li>
<li>
<p>使用 handleEvents 的 ViewController 在 github 项目中位于 <a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubViewController.swift">UIKit-Combine/GithubViewController.swift</a></p>
</li>
<li>
<p>有关 handleEvents 的单元测试在 github 项目中位于 <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/HandleEventsPublisherTests.swift">UsingCombineTests/HandleEventsPublisherTests.swift</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-debugging-print">使用 print 操作符调试管道</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">级联多个 UI 更新，包括网络请求</a></p>
</li>
<li>
<p><a href="#patterns-sequencing-operations">有序的异步操作</a></p>
</li>
<li>
<p><a href="#patterns-update-interface-userinput">通过用户输入更新声明式 UI</a></p>
</li>
<li>
<p><a href="#patterns-debugging-breakpoint">使用调试器调试管道</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p><a href="#reference-handleevents">handleEvents</a> 传入数据，不对输出和失败类型或数据进行任何修改。
当你在管道中加入该操作符时，可以指定一些可选的闭包，从而让你能够专注于你想要看到的信息。
具有特定闭包的 <a href="#reference-handleevents">handleEvents</a> 操作符是一个打开新窗口的好方法，通过该窗口可以查看管道取消、出错或以其他预期的方式终止时发生的情况。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>可以指定的闭包包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>receiveSubscription</code></p>
</li>
<li>
<p><code>receiveRequest</code></p>
</li>
<li>
<p><code>receiveCancel</code></p>
</li>
<li>
<p><code>receiveOutput</code></p>
</li>
<li>
<p><code>receiveCompletion</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果每个闭包都包含打印语句，则该操作符将非常像 <a href="#reference-print">print</a> 操作符，具体表现在 <a href="#patterns-debugging-print">使用 print 操作符调试管道</a>。</p>
</div>
<div class="paragraph">
<p>使用 handleEvents 调试的强大之处在于可以选择要查看的内容、减少输出量或操作数据以更好地了解它。</p>
</div>
<div class="paragraph">
<p>在 <a href="https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/GithubViewController.swift">UIKit-Combine/GithubViewController.swift</a> 的示例 viewcontroller 中，订阅、取消和 completion 的事件被用于启动或停止 UIActivityIndicatorView。</p>
</div>
<div class="paragraph">
<p>如果你只想看到管道上传递的数据，而不关心控制消息，那么为 <code>receiveOutput</code> 提供单个闭包并忽略其他闭包可以让你专注于这些详细信息。</p>
</div>
<div class="paragraph">
<p>handleEvents 的单元测试示例展示了所有可提供的闭包：</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/HandleEventsPublisherTests.swift">UsingCombineTests/HandleEventsPublisherTests.swift</a></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">handleEvents</span><span class="p">(</span><span class="nv">receiveSubscription</span><span class="p">:</span> <span class="p">{</span> <span class="n">aValue</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"receiveSubscription event called with </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">aValue</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">},</span> <span class="nv">receiveOutput</span><span class="p">:</span> <span class="p">{</span> <span class="n">aValue</span> <span class="k">in</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="nf">print</span><span class="p">(</span><span class="s">"receiveOutput was invoked with </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">aValue</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">},</span> <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">aValue</span> <span class="k">in</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="nf">print</span><span class="p">(</span><span class="s">"receiveCompletion event called with </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">aValue</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">},</span> <span class="nv">receiveCancel</span><span class="p">:</span> <span class="p">{</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="nf">print</span><span class="p">(</span><span class="s">"receiveCancel event invoked"</span><span class="p">)</span>
<span class="p">},</span> <span class="nv">receiveRequest</span><span class="p">:</span> <span class="p">{</span> <span class="n">aValue</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="nf">print</span><span class="p">(</span><span class="s">"receiveRequest event called with </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">aValue</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">})</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>第一个被调用的闭包是 <code>receiveRequest</code>，所需要的值（the demand value）将传递给它。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第二个闭包 <code>receiveSubscription</code> 通常是从发布者返回的订阅消息，它将对订阅的引用传递给发布者。
此时，管道已运行，发布者将根据原始请求中请求的数据量提供数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>当发布者提供这些数据时，这些数据将传递到 <code>receiveOutput</code> 中，每次有值传递过来都将调用该闭包。
这将随着发布者发送更多的值而重复调用。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>如果管道正常关闭或因失败而终止，<code>receiveCompletion</code> 闭包将收到 completion 事件。
就像 <a href="#reference-sink">sink</a> 闭包一样，你可以对提供的 completion 事件使用 switch，如果它是一个 <code>.failure</code> completion，那么你可以检查附带的错误。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>如果管道被取消，则将调用 <code>receiveCancel</code> 闭包。
不会有任何数据传递到该取消闭包中。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然你还可以使用 <a href="#reference-breakpoint">breakpoint</a> 和 <a href="#reference-breakpointonerror">breakpointOnError</a> 操作符进入调试模式（如<a href="#patterns-debugging-breakpoint">使用调试器调试管道</a> 中所示），带有闭包的 <code>handleEvents()</code> 操作符允许你在 Xcode 内设置断点。
这允许你立即进入调试器，检查流经管道的数据，或获取订阅者的引用，或在失败的 completion 事件中获取错误信息。</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="patterns-debugging-breakpoint">使用调试器调试管道</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>目的</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>强制管道在特定场景或条件下进入调试器。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>参考</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#reference-handleevents">handleEvents</a></p>
</li>
<li>
<p><a href="#reference-map">map</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>另请参阅</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-debugging-print">使用 print 操作符调试管道</a></p>
</li>
<li>
<p><a href="#patterns-debugging-handleevents">使用 handleEvents 操作符调试管道</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>代码和解释</em></dt>
<dd>
<p>你可以在管道内的任何操作符的任何闭包内设置一个断点，触发调试器激活以检查数据。
由于 <a href="#reference-map">map</a> 操作符经常用于简单的输出类型转换，因此它通常是具有你可以使用的闭包的优秀候选者。
如果你想查看控制消息，那么为 <a href="#reference-handleevents">handleEvents</a> 提供的任何闭包添加一个断点，目标实现起来将非常方便。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>你还可以使用 <a href="#reference-breakpoint">breakpoint</a> 操作符触发调试器，这是查看管道中发生情况的一种非常快速和方便的方式。
breakpoint 操作符的行为非常像 handleEvents，使用一些可选参数，期望返回一个布尔值的闭包，如果返回 true 将会调用调试器。</p>
</div>
<div class="paragraph">
<p>可选的闭包包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>receiveSubscription</code></p>
</li>
<li>
<p><code>receiveOutput</code></p>
</li>
<li>
<p><code>receiveCompletion</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">breakpoint</span><span class="p">(</span><span class="nv">receiveSubscription</span><span class="p">:</span> <span class="p">{</span> <span class="n">subscription</span> <span class="k">in</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// return true to throw SIGTRAP and invoke the debugger</span>
<span class="p">},</span> <span class="nv">receiveOutput</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// return true to throw SIGTRAP and invoke the debugger</span>
<span class="p">},</span> <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// return true to throw SIGTRAP and invoke the debugger</span>
<span class="p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这允许你提供逻辑来评估正在传递的数据，并且仅在满足特定条件时触发断点。
通过非常活跃的管道会处理大量数据，这将是一个非常有效的工具，在需要调试器时，让调试器处于活动状态，并让其他数据继续移动。</p>
</div>
<div class="paragraph">
<p>如果你只想在错误条件下进入调试器，则便利的操作符 <a href="#reference-breakpointonerror">breakPointOnError</a> 是完美的选择。
它不需要参数或闭包，当任何形式的错误条件通过管道时，它都会调用调试器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">breakpointOnError</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>断点操作符触发的断点位置不在你的代码中，因此访问本地堆栈和信息可能有点棘手。
这确实允许你在极其特定的情况下检查全局应用状态（每当闭包返回 <code>true</code> 时，使用你提供的逻辑），但你可能会发现在闭包中使用常规断点更有效。
breakpoint() 和 breakpointOnError() 操作符不会立即将你带到闭包的位置，在那里你可以看到可能触发断点的正在传递的数据、抛出的错误或控制信号。
你通常可以在调试窗口内通过堆栈跟踪以查看发布者。</p>
</div>
<div class="paragraph">
<p>当你在操作符的闭包中触发断点时，调试器也会立即获取该闭包的上下文，以便你可以查看/检查正在传递的数据。</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference">Reference</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The reference section of this book is intended to link to, reference, and expand on <a href="#introduction-appledocs">Apple&#8217;s Combine documentation</a>.</p>
</div>
<div class="sect2">
<h3 id="reference-publishers">Publishers</h3>
<div class="paragraph">
<p>For general information about publishers see <a href="#coreconcepts-publishers">Publishers</a> and <a href="#coreconcepts-lifecycle">Lifecycle of Publishers and Subscribers</a>.</p>
</div>
<div class="sect3">
<h4 id="reference-just">Just</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Just</code> provides a single result and then terminates, providing a publisher with a failure type of <code>&lt;Never&gt;</code></p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/just"><code>Just</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-oneshot-error-handling">Using catch to handle errors in a one-shot pipeline</a></p>
</li>
<li>
<p><a href="#patterns-continual-error-handling">Using flatMap with catch to handle errors</a></p>
</li>
<li>
<p><a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Often used within a closure to <a href="#reference-flatmap">flatMap</a> in error handling, it creates a single-response pipeline for use in error handling of continuous values.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="reference-future">Future</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A <code>Future</code> is initialized with a closure that eventually resolves to a single output value or failure completion.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/future">Future</a>.</p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>Future</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FuturePublisherTests.swift"><code>UsingCombineTests/FuturePublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Future</code> is a publisher that let&#8217;s you combine in any asynchronous call and use that call to generate a value or a completion as a publisher.
It is ideal for when you want to make a single request, or get a single response, where the API you are using has a completion handler closure.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The obvious example that everyone immediately thinks about is <code>URLSession</code>.
Fortunately, <a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a> exists to make a call with a <code>URLSession</code> and return a publisher.
If you already have an API object that wraps the direct calls to <code>URLSession</code>, then making a single request using <code>Future</code> can be a great way to integrate the result into a Combine pipeline.</p>
</div>
<div class="paragraph">
<p>There are a number of APIs in the Apple frameworks that use a completion closure.
An example of one is requesting permission to access the contacts store in Contacts.
An example of wrapping that request for access into a publisher using <code>Future</code> might be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">import</span> <span class="kt">Contacts</span>
<span class="k">let</span> <span class="nv">futureAsyncPublisher</span> <span class="o">=</span> <span class="kt">Future</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">promise</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="kt">CNContactStore</span><span class="p">()</span><span class="o">.</span><span class="nf">requestAccess</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">contacts</span><span class="p">)</span> <span class="p">{</span> <span class="n">grantedAccess</span><span class="p">,</span> <span class="n">err</span> <span class="k">in</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="c1">// err is an optional</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">err</span> <span class="o">=</span> <span class="n">err</span> <span class="p">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">grantedAccess</span><span class="p">))</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Future</code> itself has you define the return types and takes a closure.
It hands in a Result object matching the type description, which you interact.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>You can invoke the async API however is relevant, including passing in its required closure.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Within the completion handler, you determine what would cause a failure or a success.
A call to <code>promise(.failure(&lt;FailureType&gt;))</code> returns the failure.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Or a call to <code>promise(.success(&lt;OutputType&gt;))</code> returns a value.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to wrap an async API that could return many values over time, you should not use <code>Future</code> directly, as it only returns a single value.
Instead, you should consider creating your own publisher based on <a href="#reference-passthroughsubject">passthroughSubject</a> or <a href="#reference-currentvaluesubject">currentValueSubject</a>, or wrapping the <code>Future</code> publisher with <a href="#reference-deferred">Deferred</a>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Future creates and invokes its closure to do the asynchronous request <strong>at the time of creation</strong>, not when the publisher receives a demand request.
This can be counter-intuitive, as many other publishers invoke their closures when they receive demand.
This also means that you can&#8217;t directly link a Future publisher to an operator like <code>retry</code>.</p>
</div>
<div class="paragraph">
<p>The <code>retry</code> operator works by making another subscription to the publisher, and <code>Future</code> doesn&#8217;t currently re-invoke the closure you provide upon additional request demands.
This means that chaining a <code>retry</code> operator after <code>Future</code> will not result in Future&#8217;s closure being invoked repeatedly when a <code>.failure</code> completion is returned.</p>
</div>
<div class="paragraph">
<p>The failure of the <code>retry</code> and <code>Future</code> to work together directly has been submitted to Apple as feedback: <code>FB7455914</code>.</p>
</div>
<div class="paragraph">
<p>The <code>Future</code> publisher can be wrapped with <code>Deferred</code> to have it work based on demand, rather than as a one-shot at the time of creation of the publisher.
You can see unit tests illustrating Future wrapped with <code>Deferred</code> in the tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FuturePublisherTests.swift"><code>UsingCombineTests/FuturePublisherTests.swift</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are wanting repeated requests to a <code>Future</code> (for example, wanting to use a retry operator to retry failed requests), wrap the Future publisher with <code>Deferred</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">deferredPublisher</span> <span class="o">=</span> <span class="kt">Deferred</span> <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">return</span> <span class="kt">Future</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">promise</span> <span class="k">in</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">self</span><span class="o">.</span><span class="nf">asyncAPICall</span><span class="p">(</span><span class="nv">sabotage</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">grantedAccess</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">err</span> <span class="o">=</span> <span class="n">err</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nf">promise</span><span class="p">(</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">grantedAccess</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The closure provided in to <code>Deferred</code> will be invoked as demand requests come to the publisher.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This in turn resolves the underlying api call to generate the result as a Promise, with internal closures to resolve the promise.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="reference-empty">Empty</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>empty</code> never publishes any values, and optionally finishes immediately.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/empty"><code>Empty</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-oneshot-error-handling">Using catch to handle errors in a one-shot pipeline</a> shows an example of using <code>catch</code> to handle errors with a one-shot publisher.</p>
</li>
<li>
<p><a href="#patterns-continual-error-handling">Using flatMap with catch to handle errors</a> shows an example of using <code>catch</code> with <code>flatMap</code> to handle errors with a continual publisher.</p>
</li>
<li>
<p><a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
<li>
<p>The unit tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EmptyPublisherTests.swift"><code>UsingCombineTests/EmptyPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Empty</code> is useful in error handling scenarios where the value is an optional, or where you want to resolve an error by simply not sending anything.
Empty can be invoked to be a publisher of any output and failure type combination.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>Empty</code> is most commonly used where you need to return a publisher, but don&#8217;t want to propagate any values (a possible error handling scenario).
If you want a publisher that provides a single value, then look at <a href="#reference-just">Just</a> or <a href="#reference-deferred">Deferred</a> publishers as alternatives.</p>
</div>
<div class="paragraph">
<p>When subscribed to, an instance of the <code>Empty</code> publisher will not return any values (or errors) and will immediately return a finished completion message to the subscriber.</p>
</div>
<div class="paragraph">
<p>An example of using <code>Empty</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">myEmptyPublisher</span> <span class="o">=</span> <span class="kt">Empty</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Because the types are not be able to be inferred, expect to define the types you want to return.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="reference-fail">Fail</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Fail</code> immediately terminates publishing with the specified failure.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/fail"><code>Fail</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The unit tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FailedPublisherTests.swift"><code>UsingCombineTests/FailedPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Fail</code> is commonly used when implementing an API that returns a publisher.
In the case where you want to return an immediate failure, Fail provides a publisher that immediately triggers a failure on subscription.
One way this might be used is to provide a failure response when invalid parameters are passed.
The Fail publisher lets you generate a publisher of the correct type that provides a failure completion when demand is requested.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Initializing a <code>Fail</code> publisher can be done two ways: with the type notation specifying the output and failure types or with the types implied by handing parameters to the initializer.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="paragraph">
<p>Initializing <code>Fail</code> by specifying the types</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="kt">Fail</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">error</span><span class="p">:</span> <span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">exampleFailure</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Initializing <code>Fail</code> by providing types as parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="kt">Fail</span><span class="p">(</span><span class="nv">outputType</span><span class="p">:</span> <span class="kt">String</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">failure</span><span class="p">:</span> <span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">exampleFailure</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reference-sequence">Publishers.Sequence</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Sequence</code> publishes a provided sequence of elements, most often used through convenience initializers.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/sequence"><code>Publishers.Sequence</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The unit tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequencePublisherTests.swift"><code>UsingCombineTests/SequencePublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Sequence</code> provides a way to return values as subscribers demand them initialized from a collection.
Formally, it provides elements from any type conforming to the <a href="https://developer.apple.com/documentation/swift/sequence">sequence protocol</a>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If a subscriber requests unlimited demand, all elements will be sent, and then a <code>.finished</code> completion will terminate the output.
If the subscribe requests a single element at a time, then individual elements will be returned based on demand.</p>
</div>
<div class="paragraph">
<p>If the type within the sequence is denoted as <code>optional</code>, and a nil value is included within the sequence, that will be sent as an instance of the optional type.</p>
</div>
<div class="paragraph">
<p>Combine provides an extension onto the <code>Sequence</code> protocol so that anything that corresponds to it can act as a sequence publisher.
It does so by making a <code>.publisher</code> property available, which implicitly creates a <a href="#reference-sequence">Publishers.Sequence</a> publisher.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">initialSequence</span> <span class="o">=</span> <span class="p">[</span><span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">]</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">initialSequence</span><span class="o">.</span><span class="n">publisher</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reference-record">Record</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that allows for recording a series of inputs and a completion, for later playback to each subscriber.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/combine/record"><code>Record</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/record/recording"><code>Recording</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>Record</code> is illustrated in the unit tests <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/RecordPublisherTests.swift"><code>UsingCombineTests/RecordPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Record</code> allows you to create a publisher with pre-recorded values for repeated playback.
<code>Record</code> acts very similarly to <a href="#reference-sequence">Publishers.Sequence</a> if you want to publish a sequence of values and then send a <code>.finished</code> completion.
It goes beyond that allowing you to specify a <code>.failure</code> completion to be sent from the recording.
<code>Record</code> does not allow you to control the timing of the values being returned, only the order and the eventual completion following them.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>Record</code> can also be serialized (encoded and decoded) as long as the output and failure values can be serialized as well.</p>
</div>
<div class="paragraph">
<p>An example of a simple recording that sends several string values and then a <code>.finished completion</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="c1">// creates a recording</span>
<span class="k">let</span> <span class="nv">recordedPublisher</span> <span class="o">=</span> <span class="kt">Record</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">example</span> <span class="k">in</span>
    <span class="c1">// example : type is Record&lt;String, Never&gt;.Recording</span>
    <span class="n">example</span><span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span>
    <span class="n">example</span><span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="s">"two"</span><span class="p">)</span>
    <span class="n">example</span><span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="s">"three"</span><span class="p">)</span>
    <span class="n">example</span><span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="o">.</span><span class="n">finished</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting instance can be used as a publisher immediately:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">recordedPublisher</span><span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received the completion: "</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">err</span><span class="p">))</span>
    <span class="n">expectation</span><span class="o">.</span><span class="nf">fulfill</span><span class="p">()</span>
<span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received value: "</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Record</code> also has a property <code>recording</code> that can be inspected, with its own properties of output and completion.
<code>Record</code> and <code>recording</code> do not conform to <a href="https://developer.apple.com/documentation/swift/equatable"><code>Equatable</code></a>, so can&#8217;t be easily compared within tests.
It is fairly easy to compare the properties of <code>output</code> or <code>completion</code>, which are <code>Equatable</code> if the underlying contents (output type and failure type) are equatable.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>No convenience methods exist for creating a recording as a subscriber.
You can use the <code>receive</code> methods to create one, wrapping a <a href="#reference-sink">sink</a> subscriber.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="reference-deferred">Deferred</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>The <code>Deferred</code> publisher waits for a subscriber before running the provided closure to create values for the subscriber.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/deferred"><code>Deferred</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The unit tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DeferredPublisherTests.swift"><code>UsingCombineTests/DeferredPublisherTests.swift</code></a></p>
</li>
<li>
<p>The unit tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FuturePublisherTests.swift"><code>UsingCombineTests/FuturePublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Deferred</code> is useful when creating an API to return a publisher, where creating the publisher is an expensive effort, either computationally or in the time it takes to set up.
<code>Deferred</code> holds off on setting up any publisher data structures until a subscription is requested.
This provides a means of deferring the setup of the publisher until it is actually needed.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>Deferred</code> publisher is particularly useful with <a href="#reference-future">Future</a>, which does not wait on demand to start the resolution of underlying (wrapped) asynchronous APIs.</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="reference-makeconnectable">MakeConnectable</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Creates a or converts a publisher to one that explicitly conforms to the <a href="https://developer.apple.com/documentation/combine/connectablepublisher"><code>ConnectablePublisher</code></a> protocol.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The failure type of the publisher must be <code>&lt;Never&gt;</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/makeconnectable"><code>MakeConnectable</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>makeConnectable</code> is illustrated in the unit tests <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MulticastSharePublisherTests.swift"><code>UsingCombineTests/MulticastSharePublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>A connectable publisher has an explicit mechanism for enabling when a subscription and the flow of demand from subscribers will be allowed to the publisher.
By conforming to the <a href="https://developer.apple.com/documentation/combine/connectablepublisher"><code>ConnectablePublisher</code></a> protocol, a publisher will have two additional methods exposed for this control: <code>connect</code> and <code>autoconnect</code>.
Both of these methods return a <code>Cancellable</code> (similar to <a href="#reference-sink">sink</a> or <a href="#reference-assign">assign</a>).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>When using <code>connect</code>, the receipt of subscription will be under imperative control.
Normally when a subscriber is linked to a publisher, the connection is made automatically, subscriptions get sent, and demand gets negotiated per the <a href="#coreconcepts-lifecycle">Lifecycle of Publishers and Subscribers</a>.
With a connectable publisher, in addition to setting up the subscription <code>connect()</code> needs to be explicitly invoked.
Until <code>connect()</code> is invoked, the subscription won&#8217;t be received by the publisher.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">var</span> <span class="nv">cancellables</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">publisher</span> <span class="o">=</span> <span class="kt">Just</span><span class="p">(</span><span class="s">"woot"</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">makeConnectable</span><span class="p">()</span>

<span class="n">publisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Value received in sink: "</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">cancellables</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code will not activate the subscription, and in turn show any results.
In order to enable the subscription, an explicit <code>connect()</code> is required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">publisher</span>
    <span class="o">.</span><span class="nf">connect</span><span class="p">()</span>
    <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">cancellables</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One of the primary uses of having a connectable publisher is to coordinate the timing of connecting multiple subscribers with <a href="#reference-multicast">multicast</a>.
Because multicast only shares existing events and does not replay anything, a subscription joining late could miss some data.
By explicitly enabling the <code>connect()</code>, all subscribers can be attached before any upstream processing begins.</p>
</div>
<div class="paragraph">
<p>In comparison, <code>autoconnect()</code> makes a <code>Connectable</code> publisher act like a non-connectable one.
When you enabled <code>autoconnect()</code> on a <code>Connectable</code> publisher, it will automate the connection such that the first subscription will activate upstream publishers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">var</span> <span class="nv">cancellables</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">publisher</span> <span class="o">=</span> <span class="kt">Just</span><span class="p">(</span><span class="s">"woot"</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">makeConnectable</span><span class="p">()</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">.</span><span class="nf">autoconnect</span><span class="p">()</span> <i class="conum" data-value="2"></i><b>(2)</b>

<span class="n">publisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Value received in sink: "</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">cancellables</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>makeConnectable</code> wraps an existing publisher and makes it explicitly connectable.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>autoconnect</code> automates the process of establishing the connection for you; The first subscriber will establish the connection, subscriptions will be forwards and demand negotiated.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Making a publisher connectable and then immediately enabling <code>autoconnect</code> is an odd example, as you typically want one explicit pattern of behavior or the other.
The two mechanisms allow you to choose which you want for the needs of your code.
As such, it is extremely unlikely that you would ever want to use <code>makeConnectable()</code> followed immediately by <code>autoconnect()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Both <a href="#reference-timer">Timer</a> and <a href="#reference-multicast">multicast</a> are examples of connectable publishers.</p>
</div>
</div>
<div class="sect3">
<h4 id="reference-swiftui">SwiftUI</h4>
<div class="paragraph">
<p>The SwiftUI framework is based upon displaying views from explicit state; as the state changes, the view updates.</p>
</div>
<div class="paragraph">
<p>SwiftUI uses a variety of property wrappers within its Views to reference and display content from outside of those views.
<code>@ObservedObject</code>, <code>@EnvironmentObject</code>, and <code>@Published</code> are the most common that relate to Combine.
SwiftUI uses these property wrappers to create a publisher that will inform SwiftUI when those models have changed, creating a objectWillChange publisher.
Having an object conform to ObservableObject will also get a default <code>objectWillChange</code> publisher.</p>
</div>
<div class="paragraph">
<p>SwiftUI uses <a href="#reference-observableobject">ObservableObject</a>, which has a default concrete class implementation called <code>ObservableObjectPublisher</code> that exposes a publisher for reference objects (classes) marked with <code>@ObservedObject</code>.</p>
</div>
<div class="sect4">
<h5 id="binding">Binding</h5>
<div class="paragraph">
<p>SwiftUI does this primarily by tracking the state and changes to the state using the SwiftUI struct <code>Binding</code>.
A binding is <strong>not</strong> a Combine pipeline, or even usable as one.
A <code>Binding</code> is based on closures that are used when you get or set data through the binding.
When creating a <code>Binding</code>, you can specify the closures, or use the defaults, which handles the needs of SwiftUI elements to react when data is set or request data when a view requires it.</p>
</div>
<div class="paragraph">
<p>There are a number of SwiftUI property wrappers that create bindings:</p>
</div>
<div class="paragraph">
<p><code>@State</code>: creates a binding to a local view property, and is intended to be used only in one view</p>
</div>
<div class="paragraph">
<p>when you create:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">exampleString</span> <span class="o">=</span> <span class="s">""</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>then: <code>exampleString</code> is the state itself and the property wrapper creates <code>$exampleString</code> (also known as property wrapper&#8217;s projected value) which is of type <code>Binding&lt;String&gt;</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Binding</code>:  is used to reference an externally provided binding that the view wants to use to present itself.
You will see there upon occasion when a view is expected to be component, and it is watching for its relevant state data from an enclosing view.</p>
</li>
<li>
<p><code>@EnvironmentObject</code>: make state visible and usable across a set of views.
<code>@EnvironmentObject</code> is used to inject your own objects or state models into the environment, making them available to be used by any of the views within the current view hierarchy.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The exception to <code>@EnvironmentObject</code> cascading across the view hierarchy in SwiftUI is notably when using sheets. Sheets don&#8217;t inherit the environment from the view through which they are presented.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Environment</code> is used to expose environmental information already available from within the frameworks, for example:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">@Environment(\.horizontalSizeClass)</span> <span class="k">var</span> <span class="nv">horizontalSizeClass</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="swiftui-and-combine">SwiftUI and Combine</h5>
<div class="paragraph">
<p>All of this detail on Binding is important to how SwiftUI works, but irrelevant to Combine - Bindings are not combine pipelines or structures, and the classes and structs that SwiftUI uses are directly transformable from Combine publishers or subscribers.</p>
</div>
<div class="paragraph">
<p>SwiftUI does, however, use combine in coordination with Bindings.
Combine fits in to SwiftUI when the state has been externalized into a reference to a model object, most often using the property wrappers <code>@ObservedObject</code> to reference a class conforming to the <code>ObservableObject</code> protocol.
The core of the <code>ObservableObject</code> protocol is a combine publisher <code>objectWillChange</code>, which is used by the SwiftUI framework to know when it needs to invalidate a view based on a model changing.
The <code>objectWillChange</code> publisher only provides an indicator that <strong>something</strong> has changed on the model, not which property, or what changed about it.
The author of the model class can "opt-in" properties into triggering that change using the <code>@Published</code> property wrapper.
If a model has properties that aren&#8217;t wrapped with <code>@Published</code>, then the automatic <code>objectWillChange</code> notification won&#8217;t get triggered when those values are modified.
Typically the model properties will be referenced directly within the View elements.
When the view is invalidated by a value being published through the <code>objectWillChange</code> publisher, the SwiftUI View will request the data it needs, as it needs it, directly from the various model references.</p>
</div>
<div class="paragraph">
<p>The other way that Combine fits into SwiftUI is the method <a href="#reference-onreceive">onReceive</a>, which is a generic instance method on SwiftUI views.</p>
</div>
<div class="paragraph">
<p><a href="#reference-onreceive">onReceive</a> can be used when a view needs to be updated based on some external event that isn&#8217;t directly reflected in a model&#8217;s state being updated.</p>
</div>
<div class="paragraph">
<p>While there is no explicit guidance from Apple on how to use <code>onReceive</code> vs. models, as a general guideline it will be a cleaner pattern to update the model using Combine, keeping the combine publishers and pipelines external to SwiftUI views.
In this mode, you would generally let the <code>@ObservedObject</code> SwiftUI declaration automatically invalidate and update the view, which separates the model updating from the presentation of the view itself.
The alternative ends up having the view bound fairly tightly to the combine publishers providing asynchronous updates, rather than a coherent view of the end state.
There are still some edge cases and needs where you want to trigger a view update directly from a publishers output, and that is where <code>onReceive</code> is most effectively used.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reference-observableobject">ObservableObject</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Used with <a href="https://developer.apple.com/documentation/swiftui">SwiftUI</a>, objects conforming to <a href="https://developer.apple.com/documentation/combine/observableobject">ObservableObject</a> protocol can provide a publisher.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/combine/observableobject"><code>ObservableObject</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/observableobjectpublisher"><code>ObservableObjectPublisher</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/swiftui/observedobject"><code>@ObservedObject</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The unit tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ObservableObjectPublisherTests.swift"><code>UsingCombineTests/ObservableObjectPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>When a class includes a Published property and conforms to the <a href="https://developer.apple.com/documentation/combine/observableobject">ObservableObject protocol</a>, this class instances will get a <code>objectWillChange</code> publisher endpoint providing this publisher.
The <code>objectWillChange</code> publisher will not return any of the changed data, only an indicator that the referenced object has changed.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The output type of <code>ObservableObject.Output</code> is type aliased to Void, so while it is not nil, it will not provide any meaningful data.
Because the output type does not include what changes on the referenced object, the best method for responding to changes is probably best done using <a href="#reference-sink">sink</a>.</p>
</div>
<div class="paragraph">
<p>In practice, this method is most frequently used by the SwiftUI framework.
SwiftUI views use the <code>@ObservedObject</code> property wrapper to know when to invalidate and refresh views that reference classes implementing ObservableObject.</p>
</div>
<div class="paragraph">
<p>Classes implementing ObservedObject are also expected to use @Published to provide notifications of changes on specific properties, or to optionally provide a custom announcement that indicates the object has changed.</p>
</div>
<div class="paragraph">
<p>It can also be used locally to watch for updates to a reference-type model.</p>
</div>
</div>
<div class="sect3">
<h4 id="reference-published">@Published</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A property wrapper that adds a Combine publisher to any property</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/published">Published</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
<li>
<p>unit tests illustrating using Published: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift"><code>UsingCombineTests/PublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>@Published</code> is part of Combine, but allows you to wrap a property, enabling you to get a publisher that triggers data updates whenever the property is changed.
The publisher&#8217;s output type is inferred from the type of the property, and the error type of the provided publisher is <code>&lt;Never&gt;</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A smaller examples of how it can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">@Published</span> <span class="k">var</span> <span class="nv">username</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="err">$</span><span class="n">username</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">someString</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"value of username updated to: "</span><span class="p">,</span> <span class="n">someString</span><span class="p">)</span>
    <span class="p">}</span>

<span class="err">$</span><span class="n">username</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="o">.</span><span class="nf">assign</span><span class="p">(\</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">myLabel</span><span class="p">)</span>

<span class="kd">@Published</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">githubUserData</span><span class="p">:</span> <span class="p">[</span><span class="kt">GithubAPIUser</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@Published</code> wraps the property, username, and will generate events whenever the property is changed.
If there is a subscriber at initialization time, the subscriber will also receive the initial value being set.
The publisher for the property is available at the same scope, and with the same permissions, as the property itself.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The publisher is accessible as <code>$username</code>, of type <code>Published&lt;String&gt;.publisher</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A Published property can have more than one subscriber pipeline triggering from it.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>If you are publishing your own type, you may find it convenient to publish an array of that type as the property, even if you only reference a single value.
This allows you represent an "Empty" result that is still a concrete result within Combine pipelines, as <a href="#reference-assign">assign</a> and <a href="#reference-sink">sink</a> subscribers will only trigger updates on non-nil values.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the publisher generated from <code>@Published</code> receives a cancellation from any subscriber, it is expected to, and will cease, reporting property changes.
Because of this expectation, it is common to arrange pipelines from these publishers that have an error type of <code>&lt;Never&gt;</code> and do all error handling within the pipelines.
For example, if a <a href="#reference-sink">sink</a> subscriber is set up to capture errors from a pipeline originating from a` @Published` property, when the error is received, the sink will send a <code>cancel</code> message, causing the publisher to cease generating any updates on change.
This is illustrated in the test <code>testPublishedSinkWithError</code> at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift"><code>UsingCombineTests/PublisherTests.swift</code></a></p>
</div>
<div class="paragraph">
<p>Additional examples of how to arrange error handling for a continuous publisher like <code>@Published</code> can be found at <a href="#patterns-continual-error-handling">Using flatMap with catch to handle errors</a>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Using <code>@Published</code> should only be done within reference types - that is, within classes.
An early beta (beta2) allowed <code>@Published</code> wrapped within a struct.
This is no longer allowed or supported.
As of beta5, the compiler will not throw an error if this is attempted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>&lt;unknown&gt;:0: error: 'wrappedValue' is unavailable: @Published is only available on properties of classes
	     Combine.Published:5:16: note: 'wrappedValue' has been explicitly marked unavailable here
	         public var wrappedValue: Value { get set }
                        ^</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="reference-foundation">Foundation</h4>

</div>
<div class="sect3">
<h4 id="reference-notificationcenter">NotificationCenter</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Foundation&#8217;s NotificationCenter added the capability to act as a publisher, providing <a href="https://developer.apple.com/documentation/foundation/notifications">Notifications</a> to pipelines.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/foundation/notificationcenter/"><code>NotificationCenter</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-notificationcenter">Responding to updates from NotificationCenter</a></p>
</li>
<li>
<p>The unit tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/NotificationCenterPublisherTests.swift"><code>UsingCombineTests/NotificationCenterPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/appkit">AppKit</a> and MacOS applications have heavily relied on <a href="https://developer.apple.com/documentation/foundation/notification">Notifications</a> to provide general application state information.
A number of components also use Notifications through <a href="https://developer.apple.com/documentation/foundation/notificationcenter">NotificationCenter</a> to provide updates on user interactions, such as</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>NotificationCenter provides a publisher upon which you may create pipelines to declaratively react to application or system notifications.
The publisher optionally takes an object reference which further filters notifications to those provided by the specific reference.</p>
</div>
<div class="paragraph">
<p>Notifications are identified primarily by name, defined by a string in your own code, or a constant from a relevant framework.
You can find a good general list of existing Notifications by name at <a href="https://developer.apple.com/documentation/foundation/nsnotification/name" class="bare">https://developer.apple.com/documentation/foundation/nsnotification/name</a>.
A number of specific notifications are often included within cocoa frameworks.
For example, within AppKit, there are a number of common notifications under <a href="https://developer.apple.com/documentation/appkit/nscontrol">NSControl</a>.</p>
</div>
<div class="paragraph">
<p>A number of AppKit controls provide notifications when the control has been updated.
For example, AppKit&#8217;s <a href="https://developer.apple.com/documentation/appkit/views_and_controls/text_field">TextField</a> triggers a number of notifications including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>textDidBeginEditingNotification</code></p>
</li>
<li>
<p><code>textDidChangeNotification</code></p>
</li>
<li>
<p><code>textDidEndEditingNotification</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">extension</span> <span class="kt">Notification</span><span class="o">.</span><span class="kt">Name</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">yourNotification</span> <span class="o">=</span> <span class="kt">Notification</span><span class="o">.</span><span class="kt">Name</span><span class="p">(</span><span class="s">"your-notification"</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">yourNotification</span><span class="p">,</span> <span class="nv">object</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span>
        <span class="nf">print</span> <span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Notifications are defined by a string for their name.
If defining your own, be careful to define the strings uniquely.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A <code>NotificationCenter</code> publisher can be created for a single type of notification, <code>.yourNotification</code> in this case, defined previously in your code.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><a href="https://developer.apple.com/documentation/foundation/notifications">Notifications</a> are received from the publisher.
These include at least their name, and optionally a <code>object</code> reference from the sending object - most commonly provided from Apple frameworks.
Notifications may also include a <code>userInfo</code> dictionary of arbitrary values, which can be used to pass additional information within your application.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="reference-timer">Timer</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Foundation&#8217;s <code>Timer</code> added the capability to act as a publisher, providing a publisher to repeatedly send values to pipelines based on a <code>Timer</code> instance.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/foundation/timer"><code>Timer</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The unit tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/TimerPublisherTests.swift"><code>UsingCombineTests/TimerPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Timer.publish</code> returns an instance of <a href="https://developer.apple.com/documentation/foundation/timer/timerpublisher"><code>Timer.TimerPublisher</code></a>.
This publisher is a connectable publisher, conforming to <a href="https://developer.apple.com/documentation/combine/connectablepublisher"><code>ConnectablePublisher</code></a>.
This means that even when subscribers are connected to it, it will not start producing values until <code>connect()</code> or <code>autoconnect()</code> is invoked on the publisher.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Creating the timer publisher requires an interval in seconds, and a RunLoop and mode upon which to run.
The publisher may optionally take an additional parameter <code>tolerance</code>, which defines a variance allowed in the generation of timed events.
The default for tolerance is nil, allowing any variance.</p>
</div>
<div class="paragraph">
<p>The publisher has an output type of <a href="https://developer.apple.com/documentation/foundation/date">Date</a> and a failure type of <code>&lt;Never&gt;</code>.</p>
</div>
<div class="paragraph">
<p>If you want the publisher to automatically connect and start receiving values as soon as subscribers are connected and make requests for values, then you may include <code>autoconnect()</code> in the pipeline to have it automatically start to generate values as soon as a subscriber requests data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="kt">Timer</span><span class="o">.</span><span class="nf">publish</span><span class="p">(</span><span class="nv">every</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="o">.</span><span class="n">common</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">autoconnect</span><span class="p">()</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">receivedTimeStamp</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"passed through: "</span><span class="p">,</span> <span class="n">receivedTimeStamp</span><span class="p">)</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can connect up the subscribers, which will receive no values until you invoke <code>connect()</code> on the publisher, which also returns a <a href="https://developer.apple.com/documentation/combine/cancellable">Cancellable</a> reference.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">timerPublisher</span> <span class="o">=</span> <span class="kt">Timer</span><span class="o">.</span><span class="nf">publish</span><span class="p">(</span><span class="nv">every</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="o">.</span><span class="k">default</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">cancellableSink</span> <span class="o">=</span> <span class="n">timerPublisher</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">receivedTimeStamp</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"passed through: "</span><span class="p">,</span> <span class="n">receivedTimeStamp</span><span class="p">)</span>
    <span class="p">}</span>
<span class="c1">// no values until the following is invoked elsewhere/later:</span>
<span class="k">let</span> <span class="nv">cancellablePublisher</span> <span class="o">=</span> <span class="n">timerPublisher</span><span class="o">.</span><span class="nf">connect</span><span class="p">()</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reference-kvo-publisher">publisher from a KeyValueObserving instance</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Foundation added the ability to get a publisher on any <code>NSObject</code> that can be watched with Key Value Observing.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/objectivec/nsobject/keyvalueobservingpublisher">'KeyValueObservingPublisher'</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The unit tests at <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift"><code>UsingCombineTests/PublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Any key-value-observing instance can produce a publisher.
To create this publisher, you call the function <code>publisher</code> on the object, providing it with a single (required) KeyPath value.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">KVOAbleNSObject</span><span class="p">:</span> <span class="kt">NSObject</span> <span class="p">{</span>
    <span class="kd">@objc</span> <span class="kd">dynamic</span> <span class="k">var</span> <span class="nv">intValue</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kd">@objc</span> <span class="kd">dynamic</span> <span class="k">var</span> <span class="nv">boolValue</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">foo</span> <span class="o">=</span> <span class="kt">KVOAbleNSObject</span><span class="p">()</span>

<span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">intValue</span><span class="p">)</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">someValue</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"value updated to: &gt;&gt;</span><span class="se">\(</span><span class="n">someValue</span><span class="se">)</span><span class="s">&lt;&lt;"</span><span class="p">)</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>KVO publisher access implies that with macOS 10.15 release or iOS 13, most of Appkit and UIKit interface instances will be accessible as publishers.
Relying on the interface element&#8217;s state to trigger updates into pipelines can lead to your state being very tightly bound to the interface elements, rather than your model.
You may be better served by explicitly creating your own state to react to from a <a href="#reference-published">@Published</a> property wrapper.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="reference-datataskpublisher">URLSession.dataTaskPublisher</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Foundation&#8217;s <a href="https://developer.apple.com/documentation/foundation/urlsession"><code>URLSession</code></a> has a publisher specifically for requesting data from URLs: <code>dataTaskPublisher</code></p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/foundation/urlsession/datataskpublisher"><code>URLSession.DataTaskPublisher</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-datataskpublisher-decode">Making a network request with dataTaskPublisher</a></p>
</li>
<li>
<p><a href="#patterns-oneshot-error-handling">Using catch to handle errors in a one-shot pipeline</a></p>
</li>
<li>
<p><a href="#patterns-retry">Retrying in the event of a temporary failure</a></p>
</li>
<li>
<p><a href="#patterns-constrained-network">Requesting data from an alternate URL when the network is constrained</a></p>
</li>
<li>
<p><a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>dataTaskPublisher</code>, on URLSession, has two variants for creating a publisher.
The first takes an instance of <a href="https://developer.apple.com/documentation/foundation/url">URL</a>, the second <a href="https://developer.apple.com/documentation/foundation/urlrequest">URLRequest</a>.
The data returned from the publisher is a tuple of <code>(data: Data, response: <a href="https://developer.apple.com/documentation/foundation/urlResponse">URLResponse</a>)</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">URLRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">regularURL</span><span class="p">)</span>
<span class="k">return</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">request</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reference-result">Result</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Foundation also adds <code>Result</code> as a publisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/swift/result" class="bare">https://developer.apple.com/documentation/swift/result</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>Result.publisher</code> is illustrated in the unit tests <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MulticastSharePublisherTests.swift"><code>UsingCombineTests/MulticastSharePublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Combine augments <code>Result</code> from the swift standard library with a <code>.publisher</code> property, returning a publisher with an output type of <code>Success</code> and a failure type of <code>Failure</code>, defined by the <code>Result</code> instance.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Any method that returns an instance of <code>Result</code> can use this property to get a publisher that will provide the resulting value and followed by a <code>.finished</code> completion, or a <code>.failure</code> completion with the relevant <code>Error</code>.</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
<div class="sect3">
<h4 id="reference-realitykit">RealityKit</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/realitykit"><code>RealityKit</code></a> <a href="https://developer.apple.com/documentation/realitykit/scene"><code>.Scene</code></a> <a href="https://developer.apple.com/documentation/realitykit/scene/3254685-publisher"><code>.publisher()</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Scene Publisher (from <a href="https://developer.apple.com/documentation/realitykit">RealityKit</a>)</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/realitykit/scene/publisher">Scene.Publisher</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/realitykit/sceneevents">SceneEvents</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/realitykit/animationevents">AnimationEvents</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/realitykit/audioevents">AudioEvents</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/realitykit/collisionevents">CollisionEvents</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="reference-operators">Operators</h3>
<div class="paragraph">
<p>The <a href="#coreconcepts">chapter on Core Concepts</a> includes an overview of all available <a href="#coreconcepts-operators">Operators</a>.</p>
</div>
<div class="sect3">
<h4 id="reference-operators-mapping">Mapping elements</h4>
<div class="sect4">
<h5 id="reference-scan">scan</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>scan</code> acts like an accumulator, collecting and modifying values according to a closure you provide, and publishing intermediate results with each change from upstream.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/scan.svg" alt="scan operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/scan" class="bare">https://developer.apple.com/documentation/combine/publishers/scan</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>While the published docs are unfortunately anemic, the generated swift headers has useful detail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="c1">/// Transforms elements from the upstream publisher by providing the current element to a closure along with the last value returned by the closure.</span>
<span class="c1">///</span>
<span class="c1">///     let pub = (0...5)</span>
<span class="c1">///         .publisher</span>
<span class="c1">///         .scan(0, { return $0 + $1 })</span>
<span class="c1">///         .sink(receiveValue: { print ("\($0)", terminator: " ") })</span>
<span class="c1">///      // Prints "0 1 3 6 10 15 ".</span>
<span class="c1">///</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - initialResult: The previous result returned by the `nextPartialResult` closure.</span>
<span class="c1">///   - nextPartialResult: A closure that takes as its arguments the previous value returned by the closure and the next element emitted from the upstream publisher.</span>
<span class="c1">/// - Returns: A publisher that transforms elements by applying a closure that receives its previous return value and the next element from the upstream publisher.</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>scan</code> : <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ScanPublisherTests.swift"><code>UsingCombineTests/ScanPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Scan</code> lets you accumulate values or otherwise modify a type as changes flow through the pipeline.
You can use this to collect values into an array, implement a counter, or any number of other interesting use cases.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If you want to be able to throw an error from within the closure doing the accumulation to indicate an error condition, use the <a href="#reference-tryscan">tryScan</a> operator.
If you want to accumulate and process values, but refrain from publishing any results until the upstream publisher completes, consider using the <a href="#reference-reduce">reduce</a> or <a href="#reference-tryreduce">tryReduce</a> operators.</p>
</div>
<div class="paragraph">
<p>When you create a <code>scan</code> operator, you provide an initial value (of the type determined by the upstream publisher) and a closure that takes two parameters - the result returned from the previous invocation of the closure and a new value from the upstream publisher.
You do not need to maintain the type of the upstream publisher, but can convert the type in your closure, returning whatever is appropriate to your needs.</p>
</div>
<div class="paragraph">
<p>For example, the following <code>scan</code> operator implementation counts the number of characters in strings provided by an upstream publisher, publishing an updated count every time a new string is received:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span> <span class="n">prevVal</span><span class="p">,</span> <span class="n">newValueFromPublisher</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">prevVal</span> <span class="o">+</span> <span class="n">newValueFromPublisher</span><span class="o">.</span><span class="n">count</span>
<span class="p">})</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-tryscan">tryScan</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>tryScan</code> is a variant of the <code>scan</code> operator which allows for the provided closure to throw an error and cancel the pipeline.
The closure provided updates and modifies a value based on any inputs from an upstream publisher and publishing intermediate results.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/tryscan.svg" alt="tryscan operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/tryscan" class="bare">https://developer.apple.com/documentation/combine/publishers/tryscan</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>While the published docs are unfortunately anemic, the generated swift headers has some detail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="c1">/// Transforms elements from the upstream publisher by providing the current element to an error-throwing closure along with the last value returned by the closure.</span>
<span class="c1">///</span>
<span class="c1">/// If the closure throws an error, the publisher fails with the error.</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - initialResult: The previous result returned by the `nextPartialResult` closure.</span>
<span class="c1">///   - nextPartialResult: An error-throwing closure that takes as its arguments the previous value returned by the closure and the next element emitted from the upstream publisher.</span>
<span class="c1">/// - Returns: A publisher that transforms elements by applying a closure that receives its previous return value and the next element from the upstream publisher.</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryScan</code> : <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ScanPublisherTests.swift"><code>UsingCombineTests/ScanPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>tryScan</code> lets you accumulate values or otherwise modify a type as changes flow through the pipeline while also supporting an error state.
If either the combined and updates values, or the incoming value, matches logic you define within the closure, you can throw an error, terminating the pipeline.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="reference-map">map</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>map</code> is most commonly used to convert one data type into another along a pipeline.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/map.svg" alt="map operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/map" class="bare">https://developer.apple.com/documentation/combine/publishers/map</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-datataskpublisher-decode">Making a network request with dataTaskPublisher</a></p>
</li>
<li>
<p><a href="#patterns-oneshot-error-handling">Using catch to handle errors in a one-shot pipeline</a></p>
</li>
<li>
<p><a href="#patterns-retry">Retrying in the event of a temporary failure</a></p>
</li>
<li>
<p><a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
<li>
<p>unit tests illustrating using map with dataTaskPublisher: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift"><code>UsingCombineTests/DataTaskPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <code>map</code> operator does not allow for any additional failures to be thrown and does not transform the failure type.
If you want to throw an error within your closure, use the <a href="#reference-trymap">tryMap</a> operator.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>map</code> takes a single closure where you provide the logic for the map operation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>map</code> is the all purpose workhorse operator in Combine.
It provides the ability to manipulate the data, or the type of data, and is the most commonly used operator in pipelines.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, the <a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a> provides a tuple of <code>(data: Data, response: URLResponse)`</code> as its output.
You can use <code>map</code> to pass along the data, for example to use with <a href="#reference-decode">decode</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">data</span> <span class="p">}</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the <code>$0</code> indicates to grab the first parameter passed in, which is a tuple of <code>data</code> and <code>response</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In some cases, the closure may not be able to infer what data type you are returning, so you may need to provide a definition to help the compiler.
For example, if you have an object getting passed down that has a boolean property "isValid" on it, and you want the boolean for your pipeline, you might set that up like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">MyStruct</span> <span class="p">{</span>
    <span class="nv">isValid</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="kc">true</span>
<span class="p">}</span>
<span class="c1">//</span>
<span class="kt">Just</span><span class="p">(</span><span class="kt">MyStruct</span><span class="p">())</span>
<span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">inValue</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">inValue</span><span class="o">.</span><span class="n">isValid</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>inValue</code> is named as the parameter coming in, and the return type is being explicitly specified to <code>Bool</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A single line is an implicit return, in this case it is pulling the <code>isValid</code> property off the struct and passing it down.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-trymap">tryMap</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>tryMap</code> is similar to <a href="#reference-map">map</a>, except that it also allows you to provide a closure that throws additional errors if your conversion logic is unsuccessful.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/trymap" class="bare">https://developer.apple.com/documentation/combine/publishers/trymap</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-datataskpublisher-trymap">Stricter request processing with dataTaskPublisher</a></p>
</li>
<li>
<p>unit tests illustrating using tryMap with dataTaskPublisher: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift"><code>UsingCombineTests/DataTaskPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>tryMap</code> is useful when you have more complex business logic around your map and you want to indicate that the data passed in is an error, possibly handling that error later in the pipeline.
If you are looking at <code>tryMap</code> to decode JSON, you may want to consider using the <a href="#reference-decode">decode</a> operator instead, which is set up for that common task.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">enum</span> <span class="kt">MyFailure</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">notBigEnough</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="kt">Just</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">.</span><span class="n">tryMap</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">inValue</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
      <span class="k">throw</span> <span class="kt">MyFailure</span><span class="o">.</span><span class="n">notBigEnough</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">inValue</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You can specify whatever logic is relevant to your use case within tryMap</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>and throw an error, although throwing an Error isn&#8217;t required.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the error condition doesn&#8217;t occur, you do need to pass down data for any further subscribers.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-flatmap">flatMap</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Used with error recovery or async operations that might fail (for example <code>Future</code>), <code>flatMap</code> will replace any incoming values with another publisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/flatmap"><code>flatMap</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-continual-error-handling">Using flatMap with catch to handle errors</a></p>
</li>
<li>
<p>unit tests illustrating <code>flatMap</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SwitchAndFlatMapPublisherTests.swift"><code>UsingCombineTests/SwitchAndFlatMapPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Typically used in error handling scenarios, <code>flatMap</code> takes a closure that allows you to read the incoming data value, and provide a publisher that returns a value to the pipeline.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>In error handling, this is most frequently used to take the incoming value and create a one-shot pipeline that does some potentially failing operation, and then handling the error condition with a <a href="#reference-catch">catch</a> operator.</p>
</div>
<div class="paragraph">
<p>A simple example <code>flatMap</code>, arranged to show recovering from a decoding error and returning a placeholder value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">data</span> <span class="k">in</span>
    <span class="k">return</span> <span class="kt">Just</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">YourType</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="kt">JSONDecoder</span><span class="p">())</span>
    <span class="o">.</span><span class="k">catch</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Just</span><span class="p">(</span><span class="kt">YourType</span><span class="o">.</span><span class="n">placeholder</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A diagram version of this pipeline construct:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/flatmap.svg" alt="flatMap operator">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>flatMap</code> expects to create a new pipeline within its closure for every input value that it receives.
The expected result of this internal pipeline is a Publisher with its own output and failure type.
The output type of the publisher resulting from the internal pipeline defines the output type of the <code>flatMap</code> operator.
The error type of the internal publisher is often expected to be <code>&lt;Never&gt;</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-setfailuretype">setFailureType</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>setFailureType</code> does not send a <code>.failure</code> completion, it just changes the Failure type associated with the pipeline.
Use this publisher type when you need to match the error types for two otherwise mismatched publishers.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/setfailuretype.svg" alt="setfailuretype operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The upstream publisher must have a failure type of <code>&lt;Never&gt;</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/setfailuretype"><code>setFailureType</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating setFailureType: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FailedPublisherTests.swift"><code>UsingCombineTests/FailedPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>setFailureType</code> is an operator for transforming the error type within a pipeline, often from <code>&lt;Never&gt;</code> to some error type you may want to produce.
<code>setFailureType</code> does not induce an error, but changes the types of the pipeline.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This can be especially convenient if you need to match an operator or subscriber that expects a failure type other than <code>&lt;Never&gt;</code> when you are working with a test or single-value publisher such as <a href="#reference-just">Just</a> or <a href="#reference-just">Sequence</a>.</p>
</div>
<div class="paragraph">
<p>If you want to return a <code>.failure</code> completion of a specific type into a pipeline, use the <a href="#reference-fail">Fail</a> operator.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-filtering">Filtering elements</h4>
<div class="sect4">
<h5 id="reference-compactmap">compactMap</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Calls a closure with each received element and publishes any returned optional that has a value.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/compactmap.svg" alt="compactMap operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/compactmap"><code>compactMap</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>compactMap</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FilteringOperatorTests.swift"><code>UsingCombineTests/FilteringOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>compactMap is very similar to the <a href="#reference-map">map</a> operator, with the exception that it expects the closure to return an optional value, and drops any nil values from published responses.
This is the combine equivalent of the <a href="https://developer.apple.com/documentation/swift/sequence/2950916-compactmap"><code>compactMap</code></a> function which iterates through a <a href="https://developer.apple.com/documentation/swift/sequence"><code>Sequence</code></a> and returns a sequence of any non-nil values.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>It can also be used to process results from an upstream publisher that produces an optional Output type, and collapse those into an unwrapped type.
The simplest version of this just returns the incoming value directly, which will filter out the <code>nil</code> values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">compactMap</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$0</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a variation of this operator, <a href="#reference-trycompactmap">tryCompactMap</a>, which allows the provided closure to throw an Error and cancel the stream on invalid conditions.</p>
</div>
<div class="paragraph">
<p>If you want to convert an optional type into a concrete type, always replacing the <code>nil</code> with an explicit value, you should likely use the <a href="#reference-replacenil">replaceNil</a> operator.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-trycompactmap">tryCompactMap</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Calls a closure with each received element and publishes any returned optional that has a value, or optionally throw an Error cancelling the pipeline.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/trycompactmap"><code>tryCompactMap</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryCompactMap</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FilteringOperatorTests.swift"><code>UsingCombineTests/FilteringOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>tryCompactMap</code> is a variant of the <a href="#reference-compactmap">compactMap</a> operator, allowing the values processed to throw an <code>Error</code> condition.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">tryCompactMap</span> <span class="p">{</span> <span class="n">someVal</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">if</span> <span class="p">(</span><span class="n">someVal</span> <span class="o">==</span> <span class="s">"boom"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">TestExampleError</span><span class="o">.</span><span class="n">example</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">someVal</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If you specify the return type within the closure, it should be an optional value.
The operator that invokes the closure is responsible for filtering the non-<code>nil</code> values it publishes.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to convert an optional type into a concrete type, always replacing the <code>nil</code> with an explicit value, you should likely use the <a href="#reference-replacenil">replaceNil</a> operator.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-filter">filter</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Filter</code> passes through all instances of the output type that match a provided closure, dropping any that don&#8217;t match.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/filter.svg" alt="flatMap operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/filter"><code>filter</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
<li>
<p>unit tests illustrating using <code>filter</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FilterPublisherTests.swift"><code>UsingCombineTests/FilterPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Filter</code> takes a single closure as a parameter that is provided the value from the previous publisher and returns a Bool value.
If the return from the closure is <code>true</code>, then the operator republishes the value further down the chain.
If the return from the closure is <code>false</code>, then the operator drops the value.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If you need a variation of this that will generate an error condition in the pipeline to be handled use the <a href="#reference-tryfilter">tryFilter</a> operator, which allows the closure to throw an error in the evaluation.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-tryfilter">tryFilter</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>tryFilter</code> passes through all instances of the output type that match a provided closure, dropping any that don&#8217;t match, and allows generating an error during the evaluation of that closure.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/tryfilter"><code>tryFilter</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryFilter</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FilterPublisherTests.swift"><code>UsingCombineTests/FilterPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Like <a href="#reference-filter">filter</a>, tryFilter takes a single closure as a parameter that is provided the value from the previous publisher and returns a Bool value.
If the return from the closure is <code>true</code>, then the operator republishes the value further down the chain.
If the return from the closure is <code>false</code>, then the operator drops the value.
You can additionally throw an error during the evaluation of tryFilter, which will then be propagated as the failure type down the pipeline.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="reference-removeduplicates">removeDuplicates</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>removeDuplicates</code> remembers what was previously sent in the pipeline, and only passes forward values that don&#8217;t match the current value.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/removeduplicates.svg" alt="removeDuplicates operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Available when Output of the previous publisher conforms to Equatable.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/removeduplicates"><code>removeDuplicates</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>removeDuplicates</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift"><code>UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The default usage of <code>removeDuplicates</code> doesn&#8217;t require any parameters, and the operator will publish only elements that don&#8217;t match the previously sent element.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">removeDuplicates</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A second usage of <code>removeDuplicates</code> takes a single parameter <code>by</code> that accepts a closure that allows you to determine the logic of what will be removed.
The parameter version does not have the constraint on the Output type being equatable, but requires you to provide the relevant logic.
If the closure returns true, the <code>removeDuplicates</code> predicate will consider the values matched and not forward a the duplicate value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">removeDuplicates</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="c1">// your logic is required if the output type doesn't conform to equatable.</span>
    <span class="n">first</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">second</span><span class="o">.</span><span class="n">id</span>
<span class="p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A variation of <code>removeDuplicates</code> exists that allows the predicate closure to throw an error exists: <a href="#reference-tryremoveduplicates">tryRemoveDuplicates</a></p>
</div>
</div>
<div class="sect4">
<h5 id="reference-tryremoveduplicates">tryRemoveDuplicates</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>tryRemoveDuplicates</code> is a variant of <a href="#reference-removeduplicates">removeDuplicates</a> that allows the predicate testing equality to throw an error, resulting in an <code>Error</code> completion type.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>none</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/tryremoveduplicates"><code>tryRemoveDuplicates</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryRemoveDuplicates</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift"><code>UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>tryRemoveDuplicates</code> is a variant of <a href="#reference-removeduplicates">removeDuplicates</a> taking a single parameter that can throw an error.
The parameter is a closure that allows you to determine the logic of what will be removed.
If the closure returns true, <code>tryRemoveDuplicates</code> will consider the values matched and not forward a the duplicate value.
If the closure throws an error, a failure completion will be propagated down the chain, and no value is sent.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">removeDuplicates</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">throws</span> <span class="k">in</span>
    <span class="c1">// your logic is required if the output type doesn't conform to equatable.</span>

<span class="p">})</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-replaceempty">replaceEmpty</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Replaces an empty stream with the provided element.
If the upstream publisher finishes without producing any elements, this publisher emits the provided element, then finishes normally.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/replaceempty.svg" alt="replaceEmpty operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/replaceempty"><code>replaceEmpty</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>replaceEmpty</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ChangingErrorTests.swift"><code>UsingCombineTests/ChangingErrorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>replaceEmpty</code> will only produce a result if it has not received any values before it receives a <code>.finished</code> completion.
This operator will not trigger on an error passing through it, so if no value has been received with a <code>.failure</code> completion is triggered, it will simply not provide a value.
The operator takes a single parameter, <code>with</code> where you specify the replacement value.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">replaceEmpty</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="s">"-replacement-"</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This operator is useful specifically when you want a stream to always provide a value, even if an upstream publisher may not propagate one.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-replaceerror">replaceError</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that replaces any errors with an output value that matches the upstream Output type.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>none</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/replaceerror"><code>replaceError</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>replaceError</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ChangingErrorTests.swift"><code>UsingCombineTests/ChangingErrorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Where <a href="#reference-maperror">mapError</a> transforms an error, <code>replaceError</code> captures the error and returns a value that matches the Output type of the upstream publisher.
If you don&#8217;t care about the specifics of the error itself, it can be a more convenient operator than using <a href="#reference-catch">catch</a> to handle an error condition.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">replaceError</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>is more compact than</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span>
    <span class="k">return</span> <span class="kt">Just</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#reference-catch">catch</a> would be the preferable error handler if you wanted to return another publisher rather than a singular value.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-replacenil">replaceNil</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Replaces nil elements in the stream with the provided element.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/replacenil.svg" alt="replaceNil operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The output type of the upstream publisher must be an optional type</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/empty/3343774-replacenil"><code>replaceNil</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>replaceNil</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FilteringOperatorTests.swift"><code>UsingCombineTests/FilteringOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Used when the output type is an optional type, the <code>replaceNil</code> operator replaces any nil instances provided by the upstream publisher with a value provided by the user.
The operator takes a single parameter, <code>with</code> where you specify the replacement value.
The type of the replacement should be a non-optional version of the type provided by the upstream publisher.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">replaceNil</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="s">"-replacement-"</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This operator can also be viewed as a way of converting an optional type to an explicit type, where optional values have a pre-determined placeholder.
Put another way, the <code>replaceNil</code> operator is a Combine specific variant of the swift coalescing operator that you might use when unwrapping an optional.</p>
</div>
<div class="paragraph">
<p>If you want to convert an optional type into a concrete type, simply ignoring or collapsing the nil values, you should likely use the <a href="#reference-compactmap">compactMap</a> (or <a href="#reference-trycompactmap">tryCompactMap</a>) operator.</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-reducing">Reducing elements</h4>
<div class="sect4">
<h5 id="reference-collect">collect</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Collects all received elements, and emits a single array of the collection when the upstream publisher finishes.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/collect.svg" alt="collect operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/collect"><code>collect</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>collect</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ReducingOperatorTests.swift"><code>UsingCombineTests/ReducingOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>There are two primary forms of <code>collect</code>, one you specify without any parameters, and one you provide a <code>count</code> parameter.
<code>Collect</code> can also take a more complex form, with a defined strategy for how to buffer and send on items.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For the version without any parameters, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">collect</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The operator will collect all elements from an upstream publisher, holding those in memory until the upstream publisher sends a completion.
Upon receiving the <code>.finished</code> completion, the operator will publish an array of all the values collected.
If the upstream publisher fails with an error, the <code>collect</code> operator forwards the error to the downstream receiver instead of sending its output.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This operator uses an unbounded amount of memory to store the received values.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Collect</code> without any parameters will request an unlimited number of elements from its upstream publisher.
It only sends the collected array to its downstream after a request whose demand is greater than 0 items.</p>
</div>
<div class="paragraph">
<p>The second variation of <code>collect</code> takes a single parameter (<code>count</code>), which influences how many values it buffers and when it sends results.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">collect</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This version of <code>collect</code> will buffer up to the specified <code>count</code> number of elements.
When it has received the count specified, it emits a single array of the collection.</p>
</div>
<div class="paragraph">
<p>If the upstream publisher finishes before filling the buffer, this publisher sends an array of all the items it has received upon receiving a <code>finished</code> completion.
This may be fewer than <code>count</code> elements.</p>
</div>
<div class="paragraph">
<p>If the upstream publisher fails with an error, this publisher forwards the error to the downstream receiver instead of sending its output.</p>
</div>
<div class="paragraph">
<p>The more complex form of <code>collect</code> operates on a provided strategy of how to collect values and when to emit.</p>
</div>
<div class="paragraph">
<p>As of iOS 13.3 there are two strategies published in <a href="https://developer.apple.com/documentation/combine/publishers/timegroupingstrategy"><code>Publishers.TimeGroupingStrategy</code></a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>byTime</code></p>
</li>
<li>
<p><code>byTimeOrCount</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>byTime</code> allows you to specify a scheduler on which to operate, and a time interval stride over which to run.
It collects all values received within that stride and publishes any values it has received from its upstream publisher during that interval.
Like the parameterless version of <code>collect</code>, this will consume an unbounded amount of memory during that stride interval to collect values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">q</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">debugDescription</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">publisher</span>
    <span class="o">.</span><span class="nf">collect</span><span class="p">(</span><span class="o">.</span><span class="nf">byTime</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>byTime</code> operates very similarly to <a href="#reference-throttle">throttle</a> with its defined Scheduler and Stride, but where throttle collapses the values over a sequence of time, <code>collect(.byTime(q, 1.0))</code> will buffer and capture those values.
When the time stride interval is exceeded, the collected set will be sent to the operator&#8217;s subscriber.</p>
</div>
<div class="paragraph">
<p><code>byTimeOrCount</code> also takes a scheduler and a time interval stride, and in addition allows you to specify an upper bound on the count of items received before the operator sends the collected values to its subscriber.
The ability to provide a count allows you to have some confidence about the maximum amount of memory that the operator will consume while buffering values.</p>
</div>
<div class="paragraph">
<p>If either of the count or time interval provided are elapsed, the <code>collect</code> operator will forward the currently collected set to its subscribers.
If a <code>.finished</code> completion is received, the currently collected set will be immediately sent to it&#8217;s subscribers.
If a <code>.failure</code> completion is received, any currently buffered values are dropped and the <code>failure</code> completion is forwarded to collect&#8217;s subscribers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">q</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">debugDescription</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">publisher</span>
    <span class="o">.</span><span class="nf">collect</span><span class="p">(</span><span class="o">.</span><span class="nf">byTimeOrCount</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-ignoreoutput">ignoreOutput</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that ignores all upstream elements, but passes along a completion state (finish or failed).</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/ignoreoutput"><code>ignoreOutput</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>ignoreOutput</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ReducingOperatorTests.swift"><code>UsingCombineTests/ReducingOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>If you only want to know if a stream has finished (or failed), then <code>ignoreOutput</code> may be what you want.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">ignoreOutput</span><span class="p">()</span>
<span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received the completion"</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">completion</span><span class="p">))</span>
    <span class="k">switch</span> <span class="n">completion</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">finished</span><span class="p">:</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="n">finishReceived</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="k">break</span>
    <span class="k">case</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="k">let</span> <span class="nv">anError</span><span class="p">):</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="nf">print</span><span class="p">(</span><span class="s">"received error: "</span><span class="p">,</span> <span class="n">anError</span><span class="p">)</span>
        <span class="n">failureReceived</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() data received"</span><span class="p">)</span>
<span class="p">})</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>No data will ever be presented to a downstream subscriber of <code>ignoreOutput</code>, so the <code>receiveValue</code> closure will never be invoked.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When the stream completes, it will invoke <code>receiveCompletion</code>.
You can switch on the case from that completion to respond to the success.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Or you can do further processing based on receiving a failure.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-reduce">reduce</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that applies a closure to all received elements and produces an accumulated value when the upstream publisher finishes.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/reduce.svg" alt="reduce operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>none</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/reduce"><code>reduce</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using reduce: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ReducingOperatorTests.swift"><code>UsingCombineTests/ReducingOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Very similar in function to the <a href="#reference-scan">scan</a> operator, <code>reduce</code> collects values produced within a stream.
The big difference between <code>scan</code> and <code>reduce</code> is that <code>reduce</code> does not trigger any values until the upstream publisher completes successfully.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>When you create a <code>reduce</code> operator, you provide an initial value (of the type determined by the upstream publisher) and a closure that takes two parameters - the result returned from the previous invocation of the closure and a new value from the upstream publisher.</p>
</div>
<div class="paragraph">
<p>Like <code>scan</code>, you don&#8217;t need to maintain the type of the upstream publisher, but can convert the type in your closure, returning whatever is appropriate to your needs.</p>
</div>
<div class="paragraph">
<p>An example of <code>reduce</code> that collects strings and appends them together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="p">{</span> <span class="n">prevVal</span><span class="p">,</span> <span class="n">newValueFromPublisher</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">prevVal</span><span class="o">+</span><span class="n">newValueFromPublisher</span>
<span class="p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>reduce</code> operator is excellent at converting a stream that provides many values over time into one that provides a single value upon completion.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-tryreduce">tryReduce</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that applies a closure to all received elements and produces an accumulated value when the upstream publisher finishes, while also allowing the closure to throw an exception, terminating the pipeline.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>none</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/tryreduce"><code>tryReduce</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryReduce</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ReducingOperatorTests.swift"><code>UsingCombineTests/ReducingOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>tryReduce</code> is a variation of the <a href="#reference-reduce">reduce</a> operator that allows for the closure to throw an error.
If the exception path is taken, the <code>tryReduce</code> operator will not publish any output values to downstream subscribers.
Like <code>reduce</code>, the <code>tryReduce</code> will only publish a single downstream result upon a <code>.finished</code> completion from the upstream publisher.</p>
</dd>
</dl>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-mathematical">Mathematic operations on elements</h4>
<div class="sect4">
<h5 id="reference-max">max</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Publishes the max value of all values received upon completion of the upstream publisher.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/max.svg" alt="max operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The output type of the upstream publisher must conform to <a href="https://developer.apple.com/documentation/swift/comparable"><code>Comparable</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/sequence/3211183-max"><code>max</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>max</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MathOperatorTests.swift"><code>UsingCombineTests/MathOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>max</code> can be set up with either no parameters, or taking a closure.
If defined as an operator with no parameters, the Output type of the upstream publisher must conform to <a href="https://developer.apple.com/documentation/swift/comparable"><code>Comparable</code></a>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">max</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If what you are publishing doesn&#8217;t conform to <a href="https://developer.apple.com/documentation/swift/comparable"><code>Comparable</code></a>, then you may specify a closure to provide the ordering for the operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">max</span> <span class="p">{</span> <span class="p">(</span><span class="n">struct1</span><span class="p">,</span> <span class="n">struct2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">struct1</span><span class="o">.</span><span class="n">property1</span> <span class="o">&lt;</span> <span class="n">struct2</span><span class="o">.</span><span class="n">property1</span>
    <span class="c1">// returning boolean true to order struct2 greater than struct1</span>
    <span class="c1">// the underlying method parameter for this closure hints to it:</span>
    <span class="c1">// `areInIncreasingOrder`</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameter name of the closure hints to how it should be provided, being named <code>areInIncreasingOrder</code>.
The closure will take two values of the output type of the upstream publisher, and within it you should provide a boolean result indicating if they are in increasing order.</p>
</div>
<div class="paragraph">
<p>The operator will not provide any results under the upstream published has sent a <code>.finished</code> completion.
If the upstream publisher sends a <code>failure</code> completion, then no values will be published and the <code>.failure</code> completion will be forwarded.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-trymax">tryMax</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Publishes the <code>max</code> value of all values received upon completion of the upstream publisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The output type of the upstream publisher must conform to <a href="https://developer.apple.com/documentation/swift/comparable"><code>Comparable</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/sequence/3344605-trymax"><code>tryMax</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryMax</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MathOperatorTests.swift"><code>UsingCombineTests/MathOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>A variation of the <a href="#reference-max">max</a> operator that takes a closure to define ordering, and it also allowed to throw an error.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="reference-min">min</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Publishes the minimum value of all values received upon completion of the upstream publisher.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/min.svg" alt="min operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The output type of the upstream publisher must conform to <a href="https://developer.apple.com/documentation/swift/comparable"><code>Comparable</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/sequence/3211194-min"><code>min</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>min</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MathOperatorTests.swift"><code>UsingCombineTests/MathOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>min</code> can be set up with either no parameters, or taking a closure.
If defined as an operator with no parameters, the Output type of the upstream publisher must conform to <a href="https://developer.apple.com/documentation/swift/comparable"><code>Comparable</code></a>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">min</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If what you are publishing doesn&#8217;t conform to <a href="https://developer.apple.com/documentation/swift/comparable"><code>Comparable</code></a>, then you may specify a closure to provide the ordering for the operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">min</span> <span class="p">{</span> <span class="p">(</span><span class="n">struct1</span><span class="p">,</span> <span class="n">struct2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">struct1</span><span class="o">.</span><span class="n">property1</span> <span class="o">&lt;</span> <span class="n">struct2</span><span class="o">.</span><span class="n">property1</span>
    <span class="c1">// returning boolean true to order struct2 greater than struct1</span>
    <span class="c1">// the underlying method parameter for this closure hints to it:</span>
    <span class="c1">// `areInIncreasingOrder`</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameter name of the closure hints to how it should be provided, being named <code>areInIncreasingOrder</code>.
The closure will take two values of the output type of the upstream publisher, and within it you should provide a boolean result indicating if they are in increasing order.</p>
</div>
<div class="paragraph">
<p>The operator will not provide any results under the upstream published has sent a <code>.finished</code> completion.
If the upstream publisher sends a <code>.failure</code> completion, then no values will be published and the <code>failure</code> completion will be forwarded.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-trymin">tryMin</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Publishes the minimum value of all values received upon completion of the upstream publisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The output type of the upstream publisher must conform to <a href="https://developer.apple.com/documentation/swift/comparable"><code>Comparable</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/sequence/3344606-trymin"><code>tryMin</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryMin</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MathOperatorTests.swift"><code>UsingCombineTests/MathOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>A variation of the <a href="#reference-min">min</a> operator that takes a closure to define ordering, and it also allowed to throw an error.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="reference-count">count</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>count publishes the number of items received from the upstream publisher</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/count.svg" alt="count operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/count"><code>count</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>count</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MathOperatorTests.swift"><code>UsingCombineTests/MathOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The operator will not provide any results under the upstream published has sent a <code>.finished</code> completion.
If the upstream publisher sends a <code>.failure</code> completion, then no values will be published and the <code>failure</code> completion will be forwarded.</p>
</dd>
</dl>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-criteria">Applying matching criteria to elements</h4>
<div class="sect4">
<h5 id="reference-allsatisfy">allSatisfy</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that publishes a single Boolean value that indicates whether all received elements pass a provided predicate.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/allsatisfy.svg" alt="allSatisfy operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/allsatisfy"><code>allSatisfy</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>allSatisfy</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/CriteriaOperatorTests.swift"><code>UsingCombineTests/CriteriaOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>similar to the <a href="#reference-containswhere">containsWhere</a> operator, this operator is provided with a closure.
The type of the incoming value to this closure must match the Output type of the upstream publisher, and the closure must return a Boolean.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The operator will compare any incoming values, only responding when the upstream publisher sends a <code>.finished</code> completion.
At that point, the <code>allSatisfies</code> operator will return a single boolean value indicating if all the values received matched (or not) based on processing through the provided closure.</p>
</div>
<div class="paragraph">
<p>If the operator receives a <code>.failure</code> completion from the upstream publisher, or throws an error itself, then no data values will be published to subscribers.
In those cases, the operator will only return (or forward) the <code>.failure</code> completion.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-tryallsatisfy">tryAllSatisfy</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that publishes a single Boolean value that indicates whether all received elements pass a given throwing predicate.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/tryallsatisfy"><code>tryAllSatisfy</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryAllSatisfy</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/CriteriaOperatorTests.swift"><code>UsingCombineTests/CriteriaOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>similar to the <a href="#reference-trycontainswhere">tryContainsWhere</a> operator, you provide this operator with a closure which may also throw an error.
The type of the incoming value to this closure must match the Output type of the upstream publisher, and the closure must return a Boolean.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The operator will compare any incoming values, only responding when the upstream publisher sends a <code>.finished</code> completion.
At that point, the <code>tryAllSatisfies</code> operator will return a single boolean value indicating if all the values received matched (or not) based on processing through the provided closure.</p>
</div>
<div class="paragraph">
<p>If the operator receives a <code>.failure</code> completion from the upstream publisher, or throws an error itself, then no data values will be published to subscribers.
In those cases, the operator will only return (or forward) the <code>.failure</code> completion.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-contains">contains</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that emits a Boolean value when a specified element is received from its upstream publisher.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/contains.svg" alt="contains operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The upstream publisher&#8217;s output value must conform to the <a href="https://developer.apple.com/documentation/swift/equatable"><code>Equatable</code></a> protocol</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/contains"><code>contains</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>contains</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/CriteriaOperatorTests.swift"><code>UsingCombineTests/CriteriaOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The simplest form of <code>contains</code> accepts a single parameter.
The type of this parameter must match the Output type of the upstream publisher.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The operator will compare any incoming values, only responding when the incoming value is equatable to the parameter provided.
When it does find a match, the operator returns a single boolean value (<code>true</code>) and then terminates the stream.
Any further values published from the upstream provider are then ignored.</p>
</div>
<div class="paragraph">
<p>If the upstream published sends a <code>.finished</code> completion before any values do match, the operator will publish a single boolean (<code>false</code>) and then terminate the stream.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-containswhere">containsWhere</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that emits a Boolean value upon receiving an element that satisfies the predicate closure.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/containswhere.svg" alt="containsWhere operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/containswhere"><code>containsWhere</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>containsWhere</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/CriteriaOperatorTests.swift"><code>UsingCombineTests/CriteriaOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>A more flexible version of the <a href="#reference-contains">contains</a> operator.
Instead of taking a single parameter value to match, you provide a closure which takes in a single value (of the type provided by the upstream publisher) and returns a boolean.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Like <a href="#reference-contains">contains</a>, it will compare multiple incoming values, only responding when the incoming value is equatable to the parameter provided.
When it does find a match, the operator returns a single boolean value and  terminates the stream.
Any further values published from the upstream provider are ignored.</p>
</div>
<div class="paragraph">
<p>If the upstream published sends a <code>.finished</code> completion before any values do match, the operator will publish a single boolean (<code>false</code>) and terminates the stream.</p>
</div>
<div class="paragraph">
<p>If you want a variant of this functionality that checks multiple incoming values to determine if all of them match, consider using the <a href="#reference-allsatisfy">allSatisfy</a> operator.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-trycontainswhere">tryContainsWhere</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that emits a Boolean value upon receiving an element that satisfies the throwing predicate closure.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/trycontainswhere"><code>tryContainsWhere</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryContainsWhere</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/CriteriaOperatorTests.swift"><code>UsingCombineTests/CriteriaOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>A variation of the <a href="#reference-trycontainswhere">tryContainsWhere</a> operator which allows the closure to throw an error.
You provide a closure which takes in a single value (of the type provided by the upstream publisher) and returns a boolean.
This closure may also throw an error.
If the closure throws an error, then the operator will return no values, only the error to any subscribers, terminating the pipeline.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Like <a href="#reference-contains">contains</a>, it will compare multiple incoming values, only responding when the incoming value is equatable to the parameter provided.
When it does find a match, the operator returns a single boolean value and terminates the stream.
Any further values published from the upstream provider are ignored.</p>
</div>
<div class="paragraph">
<p>If the upstream published sends a <code>.finished</code> completion before any values do match, the operator will publish a single boolean (<code>false</code>) and terminates the stream.</p>
</div>
<div class="paragraph">
<p>If the operator receives a <code>.failure</code> completion from the upstream publisher, or throws an error itself, no data values will be published to subscribers.
In those cases, the operator will only return (or forward) the <code>.failure</code> completion.</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-sequence">Applying sequence operations to elements</h4>
<div class="sect4">
<h5 id="reference-first">first</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Publishes the first element of a stream and then finishes.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/first.svg" alt="first operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/first"><code>first</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>first</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-first">first</a> operator, when used without any parameters, will pass through the first value it receives, after which it sends a <code>.finish</code> completion message to any subscribers.
If no values are received before the first operator receives a <code>.finish</code> completion from upstream publishers, the stream is terminated and no values are published.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">first</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want a set number of values from the front of the stream you can also use <a href="#reference-prefixuntiloutput">prefixUntilOutput</a> or the variants: <a href="#reference-prefixwhile">prefixWhile</a> and <a href="#reference-tryprefixwhile">tryPrefixWhile</a>.</p>
</div>
<div class="paragraph">
<p>If you want a set number of values from the middle the stream by count, you may want to use <a href="#reference-output">output</a>, which allows you to select either a single value, or a range value from the sequence of values received by this operator.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-firstwhere">firstWhere</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that only publishes the first element of a stream to satisfy a predicate closure.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/firstwhere"><code>firstWhere</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>firstWhere</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-firstwhere">firstWhere</a> operator is similar to <a href="#reference-first">first</a>, but instead lets you specify if the value should be the first value published by evaluating a closure.
The provided closure should accept a value of the type defined by the upstream publisher, returning a bool.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">first</span> <span class="p">{</span> <span class="p">(</span><span class="n">incomingobject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">incomingobject</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">3</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The first value received that satisfies this closure - that is, has count greater than 3 - is published.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to support an error condition that will terminate the pipeline within this closure, use <a href="#reference-tryfirstwhere">tryFirstWhere</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-tryfirstwhere">tryFirstWhere</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that only publishes the first element of a stream to satisfy a throwing predicate closure.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/tryfirstwhere"><code>tryFirstWhere</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryFirstWhere</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-tryfirstwhere">tryFirstWhere</a> operator is a variant of <a href="#reference-firstwhere">firstWhere</a> that accepts a closure that can throw an error.
The closure provided should accept a value of the type defined by the upstream publisher, returning a bool.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">tryFirst</span> <span class="p">{</span> <span class="p">(</span><span class="n">incomingobject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">incomingobject</span> <span class="o">==</span> <span class="s">"boom"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">TestExampleError</span><span class="o">.</span><span class="n">invalidValue</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">incomingobject</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-last">last</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that only publishes the last element of a stream, once the stream finishes.</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/last.svg" alt="last operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/last"><code>last</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>last</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-last">last</a> operator waits until the upstream publisher sends a <code>finished</code> completion, then publishes the last value it received.
If no values were received prior to receiving the <code>finished</code> completion, no values are published to subscribers.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">last</span><span class="p">()</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-lastwhere">lastWhere</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that only publishes the last element of a stream that satisfies a predicate closure, once the stream finishes.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/lastwhere"><code>lastWhere</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>lastWhere</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-lastwhere">lastWhere</a> operator takes a single closure, accepting a value matching the output type of the upstream publisher, and returning a boolean.
The operator publishes a value when the upstream published completes with a <code>.finished</code> completion.
The value published will be the last one to satisfy the provide closure.
If no values satisfied the closure, then no values are published and the pipeline is terminated normally with a <code>.finished</code> completion.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">last</span> <span class="p">{</span> <span class="p">(</span><span class="n">incomingobject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">incomingobject</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">3</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Publishes the last value that has a length greater than 3.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-trylastwhere">tryLastWhere</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that only publishes the last element of a stream that satisfies a error-throwing predicate closure, once the stream finishes.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/trylastwhere"><code>tryLastWhere</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryLastWhere</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-trylastwhere">tryLastWhere</a> operator is a variant of the <a href="#reference-lastwhere">lastWhere</a> operator that accepts a closure that may also throw an error.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">tryLast</span> <span class="p">{</span> <span class="p">(</span><span class="n">incomingobject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">incomingobject</span> <span class="o">==</span> <span class="s">"boom"</span><span class="p">)</span> <span class="p">{</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">throw</span> <span class="kt">TestExampleError</span><span class="o">.</span><span class="n">invalidValue</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">incomingobject</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">3</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Publishes the last value that has a length greater than 3.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Logic that triggers an error, which will terminate the pipeline.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-dropuntiloutput">dropUntilOutput</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that ignores elements from the upstream publisher until it receives an element from second publisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/dropuntiloutput"><code>dropUntilOutput</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>dropUntilOutput</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-dropuntiloutput">dropUntilOutput</a> operator uses another publisher as a trigger, stopping output through a pipeline until a value is received.
Values received from the upstream publisher are ignored (and dropped) until the trigger is activated.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Any value propagated through the trigger publisher will cause the switch to activate, and allow future values through the pipeline.</p>
</div>
<div class="paragraph">
<p>Errors are still propagated from the upstream publisher, terminating the pipeline with a <code>failure</code> completion.
An error (<code>failure</code> completion) on either the upstream publisher or the trigger publisher will be propagated to any subscribers and terminate the pipeline.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">drop</span><span class="p">(</span><span class="nv">untilOutputFrom</span><span class="p">:</span> <span class="n">triggerPublisher</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to use this kind of mechanism, but with a closure determining values from the upstream publisher, use the <a href="#reference-dropwhile">dropWhile</a> operator.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-dropwhile">dropWhile</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that omits elements from an upstream publisher until a given closure returns false.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/dropwhile"><code>dropWhile</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>dropWhile</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-dropwhile">dropWhile</a> operator takes a single closure, accepting an input value of the output type defined by the upstream publisher, returning a bool.
This closure is used to determine a trigger condition, after which values are allowed to propagate.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This is not the same as the <a href="#reference-filter">filter</a> operator, acting on each value.
Instead it uses a trigger that activates once, and propagates all values after it is activated until the upstream publisher finishes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">drop</span> <span class="p">{</span> <span class="n">upstreamValue</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">upstreamValue</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to use this mechanism, but with a publisher as the trigger instead of a closure, use the <a href="#reference-dropuntiloutput">dropUntilOutput</a> operator.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-trydropwhile">tryDropWhile</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that omits elements from an upstream publisher until a given error-throwing closure returns false.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/trydropwhile"><code>tryDropWhile</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryDropWhile</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>This is a variant of the <a href="#reference-dropwhile">dropWhile</a> operator that accepts a closure that can also throw an error.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">tryDrop</span> <span class="p">{</span> <span class="n">upstreamValue</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">upstreamValue</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-prepend">prepend</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that emits all of one publisher’s elements before those from another publisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Both publishers must match on Output and Failure types.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/concatenate"><code>concatenate</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>prepend</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-prepend">prepend</a> operator will act as a merging of two pipelines.
Also known as <code>Publishers.Concatenate</code>, it accepts all values from one publisher, publishing them to subscribers.
Once the first publisher is complete, the second publisher is used to provide values until it is complete.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The most general form of this can be invoked directly as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kt">Publishers</span><span class="o">.</span><span class="kt">Concatenate</span><span class="p">(</span><span class="nv">prefix</span><span class="p">:</span> <span class="n">firstPublisher</span><span class="p">,</span> <span class="nv">suffix</span><span class="p">:</span> <span class="n">secondPublisher</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is equivalent to the form directly in a pipeline:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">secondPublisher</span>
<span class="o">.</span><span class="nf">prepend</span><span class="p">(</span><span class="n">firstPublisher</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="#reference-prepend">prepend</a> operator is often used with single or sequence values that have a failure type of <code>&lt;Never&gt;</code>.
If the publishers do accept a failure type, then all values will be published from the prefix publisher even if the suffix publisher receives a <code>.failure</code> completion before it is complete.
Once the prefix publisher completes, the error will be propagated.</p>
</div>
<div class="paragraph">
<p>The <a href="#reference-prepend">prepend</a> operator also has convenience operators to send a sequence.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">secondPublisher</span>
<span class="o">.</span><span class="nf">prepend</span><span class="p">([</span><span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">])</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The sequence values will be published immediately on a subscriber requesting demand.
Further demand will be propagated upward to <code>secondPublisher</code>.
Values produced from <code>secondPublisher</code> will then be published until it completes.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another convenience operator exists to send a single value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">secondPublisher</span>
<span class="o">.</span><span class="nf">prepend</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The value will be published immediately on a subscriber requesting demand.
Further demand will be propagated upward to <code>secondPublisher</code>.
Values produced from <code>secondPublisher</code> will then be published until it completes.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-drop">drop</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that omits a specified number of elements before republishing later elements.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/drop"><code>drop</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>drop</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The simplest form of the <a href="#reference-drop">drop</a> operator drops a single value and then allows all further values to propagate through the pipeline.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">dropFirst</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A variant of this operator allows a count of values to be specified:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">dropFirst</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Drops the first three values received from the upstream publisher before propagating any further values published to downstream subscribers.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-prefixuntiloutput">prefixUntilOutput</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Republishes elements until another publisher emits an element. After the second publisher publishes an element, the publisher returned by this method finishes.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/prefixuntiloutput"><code>prefixUntilOutput</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>prefixUntilOutput</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-prefixuntiloutput">prefixUntilOutput</a> will propagate values from an upstream publisher until a second publisher is used as a trigger.
Once the trigger is activated by receiving a value, the operator will terminate the stream.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="nv">untilOutputFrom</span><span class="p">:</span> <span class="n">secondPublisher</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-prefixwhile">prefixWhile</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that republishes elements while a predicate closure indicates publishing should continue.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/prefixwhile"><code>prefixWhile</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>prefixWhile</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-prefixwhile">prefixWhile</a> operator takes a single closure, with an input matching the output type defined by the upstream publisher, returning a boolean.
This closure is evaluated on the data from the upstream publisher.
While it returns <code>true</code> the values are propagated to the subscriber.
Once the value returns <code>false</code>, the operator terminates the stream with a <code>.finished</code> completion.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="k">prefix</span> <span class="p">{</span> <span class="n">upstreamValue</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">upstreamValue</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-tryprefixwhile">tryPrefixWhile</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that republishes elements while an error-throwing predicate closure indicates publishing should continue.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/tryprefixwhile"><code>tryPrefixWhile</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>tryPrefixWhile</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-tryprefixwhile">tryPrefixWhile</a> operator is a variant of the <a href="#reference-prefixwhile">prefixWhile</a> operator that accepts a closure and may also throw an error.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="k">prefix</span> <span class="p">{</span> <span class="n">upstreamValue</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">upstreamValue</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-output">output</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that publishes elements specified by a range in the sequence of published elements.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/output"><code>output</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>output</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SequentialOperatorTests.swift"><code>UsingCombineTests/SequentialOperatorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <a href="#reference-output">output</a> operator takes a single parameter, either an integer or a swift range.
This value is used to select a specific value, or sequence of values, from an upstream publisher to send to subscribers.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><a href="#reference-output">output</a> is choosing values from the middle of the stream.
If the upstream publisher completes before the values is received, the <code>.finished</code> completion will be propagated to the subscriber.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">output</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The selection is 0 indexed (meaning the count starts at 0).
This will select the fourth item published from the upstream publisher to propagate.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The alternate form takes a swift range descriptor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">output</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="mi">2</span><span class="o">...</span><span class="mi">3</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The selection is 0 indexed (the count starts at 0).
This will select the third and fourth item published from the upstream publisher to propagate.</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-combinepublishers">Mixing elements from multiple publishers</h4>
<div class="sect4">
<h5 id="reference-combinelatest">combineLatest</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>CombineLatest</code> merges two pipelines into a single output, converting the output type to a tuple of values from the upstream pipelines, and providing an update when any of the upstream publishers provide a new value.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publishers</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All upstream publishers must have the same failure type.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/combinelatest"><code>combineLatest</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/combinelatest3"><code>combineLatest3</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/combinelatest4"><code>combineLatest4</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-merging-streams-interface">Merging multiple pipelines to update UI elements</a></p>
</li>
<li>
<p>unit tests illustrating using <code>combineLatest</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MergingPipelineTests.swift"><code>UsingCombineTests/MergingPipelineTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>CombineLatest, and its variants of <code>combineLatest3</code> and <code>combineLatest4</code>, take multiple upstream publishers and create a single output stream, merging the streams together.
<code>CombineLatest</code> merges two upstream publishers.
<code>ComineLatest3</code> merges three upstream publishers and <code>combineLatest4</code> merges four upstream publishers.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The output type of the operator is a tuple of the output types of each of the publishers.
For example, if combineLatest was used to merge a publisher with the output type of <code>&lt;String&gt;</code> and another with the output type of <code>&lt;Int&gt;</code>, the resulting output type would be a tuple of <code>(&lt;String, Int&gt;)</code>.</p>
</div>
<div class="paragraph">
<p><code>CombineLatest</code> is most often used with continual publishers, and remembering the last output value provided from each publisher.
In turn, when any of the upstream publishers sends an updated value, the operator makes a new combined tuple of all previous "current" values, adds in the new value in the correct place, and sends that new combined value down the pipeline.</p>
</div>
<div class="paragraph">
<p>The <code>CombineLatest</code> operator requires the failure types of all three upstream publishers to be identical.
For example, you can not have one publisher that has a failure type of <code>Error</code> and another (or more) that have a failure type of <code>Never</code>.
If the <code>combineLatest</code> operator does receive a failure from any of the upstream publishers, then the operator (and the rest of the pipeline) is cancelled after propagating that failure.</p>
</div>
<div class="paragraph">
<p>If any of the upstream publishers finish normally (that is, they send a <code>.finished</code> completion), the <code>combineLatest</code> operator will continue operating and processing any messages from any of the other publishers that has additional data to send.</p>
</div>
<div class="paragraph">
<p>Other operators that merge multiple upstream pipelines include <a href="#reference-merge">merge</a> and <a href="#reference-zip">zip</a>.
If your upstream publishers have the same type and you want a stream of single values as opposed to tuples, use the <a href="#reference-merge">merge</a> operator.
If you want to wait on values from all upstream provides before providing an updated value, use the <a href="#reference-zip">zip</a> operator.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-merge">merge</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Merge</code> takes two upstream publishers and mixes the elements published into a single pipeline as they are received.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publishers</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All upstream publishers must have the same output type.</p>
</li>
<li>
<p>All upstream publishers must have the same failure type.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/merge"><code>merge</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/merge3"><code>merge3</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/merge4"><code>merge4</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/merge5"><code>merge5</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/merge6"><code>merge6</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/merge7"><code>merge7</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/merge8"><code>merge8</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>merge</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MergingPipelineTests.swift"><code>UsingCombineTests/MergingPipelineTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Merge</code> subscribers to two upstream publishers, and as they provide data for the subscriber it interleaves them into a single pipeline.
<code>Merge3</code> accepts three upstream publishers, <code>merge4</code> accepts four upstream publishers, and so forth - through <code>merge8</code> accepting eight upstream publishers.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>In all cases, the upstreams publishers are required to have the same output type, as well as the same failure type.</p>
</div>
<div class="paragraph">
<p>As with <a href="#reference-combinelatest">combineLatest</a>, if an error is propagated down any of the upstream publishers, the cancellation from the subscriber will terminate this operator and will propagate cancel to all upstream publishers as well.</p>
</div>
<div class="paragraph">
<p>If an upstream publisher completes with a normal finish, the <code>merge</code> operator continues interleaving and forwarding from any values other upstream publishers.</p>
</div>
<div class="paragraph">
<p>In the unlikely event that two values are provided at the same time from upstream publishers, the <code>merge</code> operator will interleave the values in the order upstream publishers are specified when the operator is initialized.</p>
</div>
<div class="paragraph">
<p>If you want to mix different upstream publisher types into a single stream, then you likely want to use either <a href="#reference-combinelatest">combineLatest</a> or <a href="#reference-zip">zip</a>, depending on how you want the timing of values to be handled.</p>
</div>
<div class="paragraph">
<p>If your upstream publishers have different types, but you want interleaved values to be propagated as they are available, use <a href="#reference-combinelatest">combineLatest</a>.
If you want to wait on values from all upstream provides before providing an updated value, then use the <a href="#reference-zip">zip</a> operator.</p>
</div>
</div>
<div class="sect4 MergeMany">
<h5 id="reference-Publishers">MergeMany</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>The <code>MergeMany</code> publisher takes multiple upstream publishers and mixes the published elements into a single pipeline as they are received. The upstream publisher can be of any type.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publishers</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All upstream publishers must have the same output type.</p>
</li>
<li>
<p>All upstream publishers must have the same failure type.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/mergemany"><code>Publishers.MergeMany</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Unit tests illustrating using <code>MergeMany</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MergeManyPublisherTests.swift"><code>UsingCombineTests/MergeManyPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>When you went to mix together data from multiple sources as the data arrives, <code>MergeMany</code> provides a common solution for a wide number of publishers.
It is an evolution of the Merge3, Merge4, etc sequence of publishers that came about as the Swift language enabled variadic parameters.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Like <a href="#reference-merge">merge</a>, it publishes values until all publishers send a finished completion, or cancels entirely if any of the publishers sends a cancellation completion.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-zip">zip</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Zip</code> takes two upstream publishers and mixes the elements published into a single pipeline, waiting until values are paired up from each upstream publisher before forwarding the pair as a tuple.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publishers</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All upstream publishers must have the same failure type.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/zip"><code>zip</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/zip3"><code>zip3</code></a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/publishers/zip4"><code>zip4</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>zip</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MergingPipelineTests.swift"><code>UsingCombineTests/MergingPipelineTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Zip</code> works very similarly to <a href="#reference-combinelatest">combineLatest</a>, connecting two upstream publishers and providing the output of those publishers as a single pipeline with a tuple output type composed of the types of the upstream publishers.
<code>Zip3</code> supports connecting three upstream publishers, and <code>zip4</code> supports connecting four upstream publishers.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The notable difference from <a href="#reference-combinelatest">combineLatest</a> is that <code>zip</code> waits for values to arrive from the upstream publishers, and will only publish a single new tuple when new values have been provided from all upstream publishers.</p>
</div>
<div class="paragraph">
<p>One example of using this is to wait until all streams have provided a single value to provide a synchronization point.
For example, if you have two independent network requests and require them to both be complete before continuing to process the results, you can use <code>zip</code> to wait until both publishers are complete before forwarding the combined tuples.</p>
</div>
<div class="paragraph">
<p>Other operators that merge multiple upstream pipelines include <a href="#reference-combinelatest">combineLatest</a> and <a href="#reference-merge">merge</a>.
If your upstream publishers have different types, but you want interleaved values to be propagated as they are available, use <a href="#reference-combinelatest">combineLatest</a>.
If your upstream publishers have the same type and you want a stream of single values, as opposed to tuples, then you probably want to use the <a href="#reference-merge">merge</a> operator.</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-handlingerrors">Error Handling</h4>
<div class="paragraph">
<p>See <a href="#patterns-general-error-handling">Error Handling</a> for more detail on how you can design error handling.</p>
</div>
<div class="sect4">
<h5 id="reference-catch">catch</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>The operator <code>catch</code> handles errors (completion messages of type <code>.failure</code>) from an upstream publisher by replacing the failed publisher with another publisher.
The <code>catch</code> operator also transforms the Failure type to <code>&lt;Never&gt;</code>.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> Documentation reference</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/catch"><code>Publishers.Catch</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-oneshot-error-handling">Using catch to handle errors in a one-shot pipeline</a> shows an example of using <code>catch</code> to handle errors with a one-shot publisher.</p>
</li>
<li>
<p><a href="#patterns-continual-error-handling">Using flatMap with catch to handle errors</a> shows an example of using <code>catch</code> with <code>flatMap</code> to handle errors with a continual publisher.</p>
</li>
<li>
<p><a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Once <code>catch</code> receives a <code>.failure</code> completion, it won&#8217;t send any further incoming values from the original upstream publisher.
You can also view <code>catch</code> as a switch that only toggles in one direction: to using a new publisher that you define, but only when the original publisher to which it is subscribed sends an error.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This is illustrated with the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">enum</span> <span class="kt">TestFailureCondition</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">invalidServerResponse</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">simplePublisher</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">()</span>

<span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">simplePublisher</span>
    <span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span>
        <span class="c1">// must return a Publisher</span>
        <span class="k">return</span> <span class="kt">Just</span><span class="p">(</span><span class="s">"replacement value"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">fini</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received the completion:"</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">fini</span><span class="p">))</span>
    <span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">stringValue</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received </span><span class="se">\(</span><span class="n">stringValue</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">})</span>

<span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="s">"oneValue"</span><span class="p">)</span>
<span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="s">"twoValue"</span><span class="p">)</span>
<span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">invalidServerResponse</span><span class="p">))</span>
<span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="s">"redValue"</span><span class="p">)</span>
<span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="s">"blueValue"</span><span class="p">)</span>
<span class="n">simplePublisher</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="o">.</span><span class="n">finished</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we are using a <code>PassthroughSubject</code> so that we can control when and what gets sent from the publisher.
In the above code, we are sending two good values, then a failure, then attempting to send two more good values.
The values you would see printed from our <code>.sink()</code> closures are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>.sink() received oneValue
.sink() received twoValue
.sink() received replacement value
.sink() received the completion: finished</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the failure was sent through the pipeline, catch intercepts it and returns a replacement value.
The replacement publisher it used (<code>Just</code>) sends a single value and then a completion.
If we want the pipeline to remain active, we need to change how we handle the errors.
See the pattern <a href="#patterns-continual-error-handling">Using flatMap with catch to handle errors</a> for an example of how that can be achieved.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-trycatch">tryCatch</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A variant of the <a href="#reference-catch">catch</a> operator that also allows an <code>&lt;Error&gt;</code> failure type, and doesn&#8217;t convert the failure type to <code>&lt;Never&gt;</code>.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/trycatch"><code>tryCatch</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-constrained-network">Requesting data from an alternate URL when the network is constrained</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>tryCatch</code> is a variant of <a href="#reference-catch">catch</a> that has a failure type of <code>&lt;Error&gt;</code> rather than catch&#8217;s failure type of <code>&lt;Never&gt;</code>.
This allows it to be used where you want to immediately react to an error by creating another publisher that may also produce a failure type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="reference-assertnofailure">assertNoFailure</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Raises a fatal error when its upstream publisher fails, and otherwise republishes all received input and converts failure type to <code>&lt;Never&gt;</code>.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/assertnofailure" class="bare">https://developer.apple.com/documentation/combine/publishers/assertnofailure</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-assertnofailure">Verifying a failure hasn&#8217;t happened using assertNoFailure</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>If you need to verify that no error has occurred (treating the error output as an invariant), this is the operator to use.
Like its namesakes, it will cause the program to terminate if the assert is violated.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Adding it into the pipeline requires no additional parameters, but you can include a string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">assertNoFailure</span><span class="p">()</span>
<span class="c1">// OR</span>
<span class="o">.</span><span class="nf">assertNoFailure</span><span class="p">(</span><span class="s">"What could possibly go wrong?"</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>I&#8217;m not entirely clear on where that string would appear if you did include it.</p>
</div>
<div class="paragraph">
<p>When trying out this code in unit tests, the tests invariably drop into a debugger at the assertion point when a .failure is processed through the pipeline.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to convert an failure type output of <code>&lt;Error&gt;</code> to <code>&lt;Never&gt;</code>, you probably want to look at the <a href="#reference-catch">catch</a> operator.</p>
</div>
<div class="paragraph">
<p>Apple asserts this function should be primarily used for testing and verifying <em>internal sanity checks that are active during testing</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-retry">retry</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>The <code>retry</code> operator is used to repeat requests to a previous publisher in the event of an error.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>failure type must be <code>&lt;Error&gt;</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/retry" class="bare">https://developer.apple.com/documentation/combine/publishers/retry</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-retry">Retrying in the event of a temporary failure</a></p>
</li>
<li>
<p>unit tests illustrating using <code>retry</code> with dataTaskPublisher: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift"><code>UsingCombineTests/DataTaskPublisherTests.swift</code></a></p>
</li>
<li>
<p>unit tests illustrating <code>retry</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/RetryPublisherTests.swift"><code>UsingCombineTests/RetryPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>When you specify this operator in a pipeline and it receives a subscription, it first tries to request a subscription from its upstream publisher.
If the response to that subscription fails, then it will retry the subscription to the same publisher.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The retry operator accepts a single parameter that specifies a number of retries to attempt.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Using <code>retry</code> with a high count can result in your pipeline not resolving any data or completions for quite a while, depending on how long each attempt takes.
You may also want to consider also using the <a href="#reference-timeout">timeout</a> operator to force a completion from the pipeline.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the number of retries is specified and all requests fail, then the <code>.failure</code> completion is passed down to the subscriber of this operator.</p>
</div>
<div class="paragraph">
<p>In practice, this is mostly commonly desired when attempting to request network resources with an unstable connection.
If you use a <code>retry</code> operator, you should add a specific number of retries so that the subscription doesn&#8217;t effectively get into an infinite loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">IPInfo</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="c1">// matching the data structure returned from ip.jsontest.com</span>
    <span class="k">var</span> <span class="nv">ip</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">myURL</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"http://ip.jsontest.com"</span><span class="p">)</span>
<span class="c1">// NOTE(heckj): you'll need to enable insecure downloads</span>
<span class="c1">// in your  Info.plist for this example</span>
<span class="c1">// because the URL scheme is 'http'</span>

<span class="k">let</span> <span class="nv">remoteDataPublisher</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">myURL</span><span class="o">!</span><span class="p">)</span>
    <span class="c1">// the dataTaskPublisher output combination is</span>
    <span class="c1">// (data: Data, response: URLResponse)</span>
    <span class="o">.</span><span class="nf">retry</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1">// if the URLSession returns a .failure completion,</span>
    <span class="c1">// retry at most 3 times to get a successful response</span>
    <span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="p">(</span><span class="n">inputTuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="k">in</span>
        <span class="k">return</span> <span class="n">inputTuple</span><span class="o">.</span><span class="n">data</span>
    <span class="p">})</span>
    <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">IPInfo</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">JSONDecoder</span><span class="p">())</span>
    <span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span>
        <span class="k">return</span> <span class="kt">Publishers</span><span class="o">.</span><span class="kt">Just</span><span class="p">(</span><span class="kt">IPInfo</span><span class="p">(</span><span class="nv">ip</span><span class="p">:</span> <span class="s">"8.8.8.8"</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-maperror">mapError</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Converts any failure from the upstream publisher into a new error.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Failure type is some instance of <code>Error</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/maperror"><code>mapError</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating <code>mapError</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/ChangingErrorTests.swift"><code>UsingCombineTests/ChangingErrorTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>mapError</code> is an operator that allows you to transform the failure type by providing a closure where you convert errors from upstream publishers into a new type.
<code>mapError</code> is similar to <a href="#reference-replaceerror">replaceError</a>, but <code>replaceError</code> ignores any upstream errors and returns a single kind of error, where this operator lets you construct using the error provided by the upstream publisher.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">mapError</span> <span class="p">{</span> <span class="n">error</span> <span class="o">-&gt;</span> <span class="kt">ChangingErrorTests</span><span class="o">.</span><span class="kt">APIError</span> <span class="k">in</span>
    <span class="c1">// if it's our kind of error already, we can return it directly</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="k">as?</span> <span class="kt">APIError</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">error</span>
    <span class="p">}</span>
    <span class="c1">// if it is a URLError, we can convert it into our more general error kind</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">urlerror</span> <span class="o">=</span> <span class="n">error</span> <span class="k">as?</span> <span class="kt">URLError</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">APIError</span><span class="o">.</span><span class="nf">networkError</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">urlerror</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// if all else fails, return the unknown error condition</span>
    <span class="k">return</span> <span class="kt">APIError</span><span class="o">.</span><span class="n">unknown</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-adaptingtypes">Adapting publisher types</h4>
<div class="sect4">
<h5 id="reference-switchtolatest">switchToLatest</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher that flattens any nested publishers, using the most recent provided publisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/switchtolatest"><code>switchToLatest</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
<li>
<p>unit tests illustrating <code>switchToLatest</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SwitchAndFlatMapPublisherTests.swift"><code>UsingCombineTests/SwitchAndFlatMapPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>switchToLatest</code> operates similarly to <a href="#reference-flatmap">flatMap</a>, taking in a publisher instance and returning its value (or values).
Where <a href="#reference-flatmap">flatMap</a> operates over the values it is provided, <code>switchToLatest</code> operates on whatever publisher it is provided.
The primary difference is in where it gets the publisher.
In flatMap, the publisher is returned within the closure provided to flatMap, and the operator works upon that to subscribe and provide the relevant value down the pipeline.
In <code>switchToLatest</code>, the publisher instance is provided <strong>as the output type</strong> from a previous publisher or operator.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The most common form of using this is with a one-shot publisher such as <a href="#reference-just">Just</a> getting its value as a result of a <a href="#reference-map">map</a> transform.</p>
</div>
<div class="paragraph">
<p>It is also commonly used when working with an API that provides a publisher.
<code>switchToLatest</code> assists in taking the result of the publisher and sending that down the pipeline rather than sending the publisher as the output type.</p>
</div>
<div class="paragraph">
<p>The following snippet is part of the larger example <a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">username</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">GithubAPIUser</span><span class="p">],</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="k">in</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">return</span> <span class="kt">GithubAPI</span><span class="o">.</span><span class="nf">retrieveGithubUser</span><span class="p">(</span><span class="nv">username</span><span class="p">:</span> <span class="n">username</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">}</span>
<span class="c1">// ^^ type returned in the pipeline is a Publisher, so we use</span>
<span class="c1">// switchToLatest to flatten the values out of that</span>
<span class="c1">// pipeline to return down the chain, rather than returning a</span>
<span class="c1">// publisher down the pipeline.</span>
<span class="o">.</span><span class="nf">switchToLatest</span><span class="p">()</span> <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In this example, an API instance (GithubAPI) has a function that returns a publisher.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="#reference-map">map</a> takes an earlier <code>String</code> output type, returning a publisher instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We want to use the value from that publisher, not the publisher itself, which is exactly what <code>switchToLatest</code> provides.</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-timing">Controlling timing</h4>
<div class="sect4">
<h5 id="reference-debounce">debounce</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>debounce collapses multiple values within a specified time window into a single value</p>
</dd>
</dl>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/debounce.svg" alt="tryscan operator">
</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/debounce_break.svg" alt="tryscan operator">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/debounce">'debounce'</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>debounce</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift"><code>UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The operator takes a minimum of two parameters, an amount of time over which to <code>debounce</code> the signal and a scheduler on which to apply the operations.
The operator will collapse any values received within the timeframe provided to a single, last value received from the upstream publisher within the time window.
If any value is received within the specified time window, it will collapse it.
It will  not return a result until the entire time window has elapsed with no additional values appearing.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This operator is frequently used with <a href="#reference-removeduplicates">removeDuplicates</a> when the publishing source is bound to UI interactions, primarily to prevent an "edit and revert" style of interaction from triggering unnecessary work.</p>
</div>
<div class="paragraph">
<p>If you wish to control the value returned within the time window, or if you want to simply control the volume of events by time, you may prefer to use <a href="#reference-throttle">throttle</a>, which allows you to choose the first or last value provided.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-delay">delay</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Delays delivery of all output to the downstream receiver by a specified amount of time on a particular scheduler.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/delay"><code>delay</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-delegate-publisher-subject">Creating a repeating publisher by wrapping a delegate based API</a></p>
</li>
<li>
<p><a href="#patterns-retry">Retrying in the event of a temporary failure</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <code>delay</code> operator passes through the data after a delay defined to the operator.
The <code>delay</code> operator also requires a scheduler, where the delay is explicitly invoked.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">delay</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">headingBackgroundQueue</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-measureinterval">measureInterval</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>measureInterval</code> measures and emits the time interval between events received from an upstream publisher, in turn publishing a value of <code>SchedulerTimeType.Stride</code> (which includes a magnitude and interval since the last value).
The specific upstream value is ignored beyond the detail of the time at which it was received.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/measureinterval"><code>measureInterval</code></a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Output types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/schedulertimetype/stride">DispatchQueue.SchedulerTimeType.Stride</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/foundation/operationqueue/schedulertimetype/stride">OperationQueue.SchedulerTimeType.Stride</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/foundation/runloop/schedulertimetype/stride">RunLoop.SchedulerTimeType.Stride</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/combine/immediatescheduler/schedulertimetype/stride">Immediate.SchedulerTimeType.Stride</a></p>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using throttle: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MeasureIntervalTests.swift"><code>UsingCombineTests/MeasureIntervalTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The operator takes a single parameter, the scheduler to be used.
The output type is the type <code>SchedulerTimeType.Stride</code> for the scheduler you designate.</p>
</dd>
</dl>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">measureInterval</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="n">q</span><span class="p">)</span> <span class="c1">// Output type is DispatchQueue.SchedulerTimeType.Stride</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>magnitude</code> (an Int) the stride is the number of nanoseconds since the last value, which is generally in nanoseconds.
You can also use the <code>interval</code> (a <a href="https://developer.apple.com/documentation/dispatch/dispatchtimeinterval"><code>DispatchTimeInterval</code></a>) which carries with it the specific units of the interval.</p>
</div>
<div class="paragraph">
<p>These values are not guaranteed on a high resolution timer, so use the resulting values judiciously.</p>
</div>
</div>
<div class="sect4">
<h5 id="reference-throttle">throttle</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Throttle</code> constrains the stream to publishing zero or one value within a specified time window, independent of the number of elements provided by the publisher.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Timing diagram with latest set to <code>true</code>:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/throttle_true.svg" alt="tryscan operator">
</div>
</div>
<div class="paragraph">
<p>Timing diagram with latest set to <code>false</code>:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/diagrams/throttle_false.svg" alt="tryscan operator">
</div>
</div>
<div class="paragraph">
<p>The timing examples in the marble diagrams are from the unit tests running under iOS 13.3.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/throttle"><code>throttle</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>throttle</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift"><code>UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Throttle</code> is akin to the <a href="#reference-debounce">debounce</a> operator in that it collapses values.
The primary difference is that <code>debounce</code> will wait for no further values, where <code>throttle</code> will last for a specific time window and then publish a result.
The operator will collapse any values received within the timeframe provided to a single value received from the upstream publisher within the time window.
The value chosen within the time window is influenced by the parameter <code>latest</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If values are received very close to the edges of the time window, the results can be a little unexpected.</p>
</div>
<div class="paragraph">
<p>The operator takes a minimum of three parameters, <code>for</code>: an amount of time over which to collapse the values received, <code>scheduler</code>: a scheduler on which to apply the operations, and <code>latest</code>: a boolean indicating if the first value or last value should be chosen.</p>
</div>
<div class="paragraph">
<p>This operator is often used with <a href="#reference-removeduplicates">removeDuplicates</a> when the publishing source is bound to UI interactions, primarily to prevent an "edit and revert" style of interaction from triggering unnecessary work.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">throttle</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">,</span> <span class="nv">latest</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In iOS 13.2 the behavior for setting <code>latest</code> to false appears to have changed from previous releases.
This was reported to apple as Feedback FB7424221.
This behavior changed again in Xcode 11.3 (iOS 13.3), most notably in changes when the upstream publisher starts with an initial value (such as @Published).
This results in extraneous early results (in iOS 13.3).
After the initial sliding window expires the results get far more consistent.</p>
</div>
<div class="paragraph">
<p>If you are relying on specific timing for some of your functions, double check you systems with tests to verify the behavior.
The outputs for timing scenarios are detailed in comments within the <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DebounceAndRemoveDuplicatesPublisherTests.swift">throttle unit tests</a> written for this book.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-timeout">timeout</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Terminates publishing if the upstream publisher exceeds the specified time interval without producing an element.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Requires the failure type to be <code>&lt;Never&gt;</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/timeout" class="bare">https://developer.apple.com/documentation/combine/publishers/timeout</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>retry</code> and <code>timeout</code> with <code>dataTaskPublisher</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift"><code>UsingCombineTests/DataTaskPublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Timeout</code> will force a resolution to a pipeline after a given amount of time, but does not guarantee either data or errors, only a completion.
If a <code>timeout</code> does trigger and force a completion, it will not generate an failure completion with an error.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>Timeout</code> is specified with two parameters: <code>time</code> and <code>scheduler</code>.</p>
</div>
<div class="paragraph">
<p>If you are using a specific background thread (for example, with the <a href="#reference-subscribe">subscribe</a> operator), then timeout should likely be using the same scheduler.</p>
</div>
<div class="paragraph">
<p>The time period specified will take a literal integer, but otherwise needs to conform to the protocol <a href="https://developer.apple.com/documentation/combine/schedulertimeintervalconvertible">SchedulerTimeIntervalConvertible</a>.
If you want to set a number from a <code>Float</code> or <code>Int</code>, you need to create the relevant structure, as <code>Int</code> or <code>Float</code> does not conform to <code>SchedulerTimeIntervalConvertible</code>.
For example, while using a <code>DispatchQueue</code>, you could use <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/schedulertimetype/stride">DispatchQueue.SchedulerTimeType.Stride</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">remoteDataPublisher</span> <span class="o">=</span> <span class="n">urlSession</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">mockURL</span><span class="o">!</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">delay</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">backgroundQueue</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">retry</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// 5 retries, 2 seconds each ~ 10 seconds for this to fall through</span>
    <span class="o">.</span><span class="nf">timeout</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nv">scheduler</span><span class="p">:</span> <span class="n">backgroundQueue</span><span class="p">)</span> <span class="c1">// max time of 5 seconds before failing</span>
    <span class="o">.</span><span class="n">tryMap</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span> <span class="o">-&gt;</span> <span class="kt">Data</span> <span class="k">in</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">httpResponse</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span><span class="p">,</span>
            <span class="n">httpResponse</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">200</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">TestFailureCondition</span><span class="o">.</span><span class="n">invalidServerResponse</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">JSONDecoder</span><span class="p">())</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="n">backgroundQueue</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span></code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-coding">Encoding and decoding</h4>
<div class="sect4">
<h5 id="reference-encode">encode</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Encode</code> converts the output from upstream Encodable object using a specified TopLevelEncoder. For example, use <code>JSONEncoder</code> or <code>PropertyListEncoder</code>..</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Available when the output type conforms to <code>Encodable</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/encode" class="bare">https://developer.apple.com/documentation/combine/publishers/encode</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>encode</code> and <code>decode</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EncodeDecodeTests.swift"><code>UsingCombineTests/EncodeDecodeTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <code>encode</code> operator takes a single parameter: <code>encoder</code>
This is an instance of an object conforming to <a href="https://developer.apple.com/documentation/combine/toplevelencoder">TopLevelEncoder</a>. Frequently it is an instance of <a href="https://developer.apple.com/documentation/foundation/jsonencoder">JSONEncoder</a> or <a href="https://developer.apple.com/documentation/foundation/propertylistencoder">PropertyListEncoder</a>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">fileprivate</span> <span class="kd">struct</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">valid</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">dataProvider</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="nv">encoder</span><span class="p">:</span> <span class="kt">JSONEncoder</span><span class="p">())</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">data</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">".sink() data received </span><span class="se">\(</span><span class="n">data</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">stringRepresentation</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">encoding</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">stringRepresentation</span><span class="p">)</span>
    <span class="p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Like the <a href="#reference-decode">decode</a> operator, the encode process can also fail and throw an error.
Therefore it also returns a failure type of <code>&lt;Error&gt;</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A common issue is if you try to pass an optional type to the <code>encode</code> operator.
This results in a error from the compiler.
In these cases, either you can change the type from optional to a concrete type with the <a href="#reference-trymap">tryMap</a> operator, or use an operator such as <a href="#reference-replacenil">replaceNil</a> to provide concrete values.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-decode">decode</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A commonly desired operation is to decode some provided data, so Combine provides the <code>decode</code> operator suited to that task.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Available when the output type conforms to <code>Decodable</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/decode" class="bare">https://developer.apple.com/documentation/combine/publishers/decode</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-datataskpublisher-decode">Making a network request with dataTaskPublisher</a></p>
</li>
<li>
<p><a href="#patterns-datataskpublisher-trymap">Stricter request processing with dataTaskPublisher</a></p>
</li>
<li>
<p><a href="#patterns-oneshot-error-handling">Using catch to handle errors in a one-shot pipeline</a></p>
</li>
<li>
<p><a href="#patterns-retry">Retrying in the event of a temporary failure</a></p>
</li>
<li>
<p>unit tests illustrating using <code>encode</code> and <code>decode</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EncodeDecodeTests.swift"><code>UsingCombineTests/EncodeDecodeTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <code>decode</code> operator takes two parameters:</p>
<div class="ulist">
<ul>
<li>
<p><code>type</code> which is typically a reference to a struct you defined</p>
</li>
<li>
<p><code>decoder</code> an instance of an object conforming to <a href="https://developer.apple.com/documentation/combine/topleveldecoder">TopLevelDecoder</a>, frequently an instance of <a href="https://developer.apple.com/documentation/foundation/jsondecoder">JSONDecoder</a> or <a href="https://developer.apple.com/documentation/foundation/propertylistdecoder">PropertyListDecoder</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Since decoding can fail, the operator returns a failure type of <code>Error</code>.
The data type returned by the operator is defined by the type you provided to decode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">testUrlString</span> <span class="o">=</span> <span class="s">"https://postman-echo.com/time/valid?timestamp=2016-10-10"</span>
<span class="c1">// checks the validity of a timestamp - this one should return {"valid":true}</span>
<span class="c1">// matching the data structure returned from https://postman-echo.com/time/valid</span>
<span class="kd">fileprivate</span> <span class="kd">struct</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="p">:</span> <span class="kt">Decodable</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">valid</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">remoteDataPublisher</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="n">testUrlString</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
    <span class="c1">// the dataTaskPublisher output combination is (data: Data, response: URLResponse)</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">data</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">PostmanEchoTimeStampCheckResponse</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">JSONDecoder</span><span class="p">())</span></code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-multiplesubscribers">Working with multiple subscribers</h4>
<div class="sect4">
<h5 id="reference-share">share</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>A publisher implemented as a class, which otherwise behaves like its upstream publisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/share" class="bare">https://developer.apple.com/documentation/combine/publishers/share</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>share</code> and <code>MulticastPublisher</code> are illustrated in the unit tests <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MulticastSharePublisherTests.swift"><code>UsingCombineTests/MulticastSharePublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>A publisher is often a struct within swift, following value semantics.
<code>share</code> is used when you want to create a publisher as a class to take advantage of reference semantics.
This is most frequently employed when creating a publisher that does expensive work so that you can isolate the expensive work and use it from multiple subscribers.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Very often, you will see <code>share</code> used to provide <a href="#reference-multicast">multicast</a> - to create a shared instance of a publisher and have multiple subscribers connected to that single publisher.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">expensivePublisher</span> <span class="o">=</span> <span class="n">somepublisher</span>
    <span class="o">.</span><span class="nf">share</span><span class="p">()</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-multicast">multicast</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Use a multicast publisher when you have multiple downstream subscribers, but you want upstream publishers to only process one receive(_:) call per event.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/multicast" class="bare">https://developer.apple.com/documentation/combine/publishers/multicast</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>share</code> and <code>MulticastPublisher</code> are illustrated in the unit tests <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/MulticastSharePublisherTests.swift"><code>UsingCombineTests/MulticastSharePublisherTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>A multicast publisher provides a means of consolidating the requests of data from a publisher into a single request.
A multicast publisher does not change data or types within a pipeline.
It does provide a bastion for subscriptions so that when demand is created from one subscriber, multiple subscribers can benefit from it.
It effectively allows one value to go to multiple subscribers.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Multicast is often created after using <a href="#reference-share">share</a> on a publisher to create a reference object as a publisher.
This allows you to consolidate expensive queries, such as external network requests, and provide the data to multiple consumers.</p>
</div>
<div class="paragraph">
<p>When creating using multicast, you either provide a <a href="#reference-subjects">Subjects</a> (with the parameter `subject) or create a <a href="#reference-subjects">Subjects</a> inline in a closure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">pipelineFork</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">multicastPublisher</span> <span class="o">=</span> <span class="n">somepublisher</span><span class="o">.</span><span class="nf">multicast</span><span class="p">(</span><span class="nv">subject</span><span class="p">:</span> <span class="n">pipelineFork</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">multicastPublisher</span> <span class="o">=</span> <span class="n">somepublisher</span>
    <span class="o">.</span><span class="n">multicast</span> <span class="p">{</span>
        <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A multicast publisher does not cache or maintain the history of a value.
If a multicast publisher is already making a request and another subscriber is added after the data has been returned to previously connected subscribers, new subscribers may only get a completion.
For this reason, multicast returns a <a href="#reference-makeconnectable">connectable publisher</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When making a multicast publisher, make sure you explicitly connect the publishers or you will see no data flow through your pipeline.
Do this either using <code>connect()</code> on your publisher after all subscribers have been connected, or by using <code>autoconnect()</code> to enable the connection on the first subscription..</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reference-operators-debugging">Debugging</h4>
<div class="sect4">
<h5 id="reference-breakpoint">breakpoint</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>The <code>breakpoint</code> operator raises a debugger signal when a provided closure identifies the need to stop the process in the debugger.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/breakpoint" class="bare">https://developer.apple.com/documentation/combine/publishers/breakpoint</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-debugging-breakpoint">Debugging pipelines with the debugger</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>When any of the provided closures returns true, this publisher raises a <code>SIGTRAP</code> signal to stop the process in the debugger. Otherwise, this publisher passes through values and completions.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The operator takes 3 optional closures as parameters, used to trigger when to raise a <code>SIGTRAP</code> signal:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>receiveSubscription</code></p>
</li>
<li>
<p><code>receiveOutput</code></p>
</li>
<li>
<p><code>receiveCompletion</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">breakpoint</span><span class="p">(</span><span class="nv">receiveSubscription</span><span class="p">:</span> <span class="p">{</span> <span class="n">subscription</span> <span class="k">in</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// return true to throw SIGTRAP and invoke the debugger</span>
<span class="p">},</span> <span class="nv">receiveOutput</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// return true to throw SIGTRAP and invoke the debugger</span>
<span class="p">},</span> <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
    <span class="k">return</span> <span class="kc">false</span> <span class="c1">// return true to throw SIGTRAP and invoke the debugger</span>
<span class="p">})</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-breakpointonerror">breakpointOnError</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Raises a debugger signal upon receiving a failure.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/breakpoint/3205192-breakpointonerror" class="bare">https://developer.apple.com/documentation/combine/publishers/breakpoint/3205192-breakpointonerror</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-debugging-breakpoint">Debugging pipelines with the debugger</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>breakpointOnError</code> is a convenience method used to raise a <code>SIGTRAP</code> signal when an error is propagated through it within a pipeline.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">breakpointOnError</span><span class="p">()</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-handleevents">handleEvents</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>handleEvents</code> is an all purpose operator that allow you to specify closures be invoked when publisher events occur.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/handleevents" class="bare">https://developer.apple.com/documentation/combine/publishers/handleevents</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>handleEvents</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/HandleEventsPublisherTests.swift"><code>UsingCombineTests/HandleEventsPublisherTests.swift</code></a></p>
</li>
<li>
<p><a href="#patterns-debugging-handleevents">Debugging pipelines with the handleEvents operator</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>handleEvents</code> does not require any parameters, allowing you to specify a response to specific publisher events.
Optional closures can be provided for the following events:</p>
<div class="ulist">
<ul>
<li>
<p><code>receiveSubscription</code></p>
</li>
<li>
<p><code>receiveOutput</code></p>
</li>
<li>
<p><code>receiveCompletion</code></p>
</li>
<li>
<p><code>receiveCancel</code></p>
</li>
<li>
<p><code>receiveRequest</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>All of the closures are expected to return <code>Void</code>, which makes <code>handleEvents</code> useful for intentionally creating side effects based on what is happening in the pipeline.</p>
</div>
<div class="paragraph">
<p>You could, for example, use <code>handleEvents</code> to update an activityIndicator UI element, triggering it on with the receipt of the subscription, and terminating with the receipt of either cancel or completion.</p>
</div>
<div class="paragraph">
<p>If you only want to view the information flowing through the pipeline, you might consider using the <a href="#reference-print">print</a> operator instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">handleEvents</span><span class="p">(</span><span class="nv">receiveSubscription</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">startAnimating</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">stopAnimating</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="nv">receiveCancel</span><span class="p">:</span> <span class="p">{</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">activityIndicator</span><span class="o">.</span><span class="nf">stopAnimating</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">})</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-print">print</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>Prints log messages for all publishing events.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publishers/print" class="bare">https://developer.apple.com/documentation/combine/publishers/print</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>unit tests illustrating using <code>print</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift"><code>UsingCombineTests/PublisherTests.swift</code></a></p>
</li>
<li>
<p><a href="#patterns-debugging-print">Debugging pipelines with the print operator</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>The <code>print</code> operator does not require a parameter, but if provided will prepend it to any console output.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>Print</code> is incredibly useful to see "what&#8217;s happening" within a pipeline, and can be used as <em>printf debugging</em> within the pipeline.</p>
</div>
<div class="paragraph">
<p>Most of the example tests illustrating the operators within this reference use a <code>print</code> operator to provide additional text output to illustrate lifecycle events.</p>
</div>
<div class="paragraph">
<p>The <code>print</code> operator is not directly integrated with Apple&#8217;s unified logging, although there is an optional <code>to</code> parameter that lets you specific an instance conforming to <a href="https://developer.apple.com/documentation/swift/textoutputstream">TextOutputStream</a> to which it will send the output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="err">$</span><span class="n">username</span>
    <span class="o">.</span><span class="nf">print</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">debugDescription</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">tryMap</span><span class="p">({</span> <span class="n">myValue</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">in</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">myValue</span> <span class="o">==</span> <span class="s">"boom"</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">FailureCondition</span><span class="o">.</span><span class="n">selfDestruct</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="s">"mappedValue"</span>
    <span class="p">})</span></code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="scheduler-and-thread-handling-operators">Scheduler and Thread handling operators</h4>
<div class="sect4">
<h5 id="reference-receive">receive</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Receive</code> defines the scheduler on which to receive elements from the publisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/publisher/3204743-receive"><code>receive</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-assign-subscriber">使用 assign 创建一个订阅者</a> shows an example of using <code>receive</code> with <code>assign</code> to set an a boolean property on a UI element.</p>
</li>
<li>
<p>unit tests illustrating using <code>assign</code> with a <code>dataTaskPublisher</code>, as well as <code>subscribe</code> and <code>receive</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SubscribeReceiveAssignTests.swift"><code>UsingCombineTests/SubscribeReceiveAssignTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Receive</code> takes a single required parameter (<code>on:</code>) which accepts a scheduler, and an optional parameter (<code>optional:</code>) which can accept <code>SchedulerOptions</code>.
<a href="https://developer.apple.com/documentation/combine/scheduler">Scheduler</a> is a protocol in Combine, with the conforming types that are commonly used of <a href="https://developer.apple.com/documentation/foundation/runloop">RunLoop</a>, <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue">DispatchQueue</a> and <a href="https://developer.apple.com/documentation/foundation/operationqueue">OperationQueue</a>.
<code>Receive</code> is frequently used with <a href="#reference-assign">assign</a> to make sure any following pipeline invocations happen on a specific thread, such as <code>RunLoop.main</code> when updating user interface objects.
<code>Receive</code> effects itself and any operators chained after it, but not previous operators.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If you want to influence a previously chained publishers (or operators) for where to run, you may want to look at the <a href="#reference-subscribe">subscribe</a> operator.
Alternately, you may also want to put a <code>receive</code> operator earlier in the pipeline.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">examplePublisher</span><span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reference-subscribe">subscribe</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Subscribe</code> defines the scheduler on which to run a publisher in a pipeline.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/anypublisher/3204260-subscribe"><code>subscribe</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-assign-subscriber">Creating a subscriber with assign</a> shows an example of using assign to set an a boolean property on a UI element.</p>
</li>
<li>
<p>unit tests illustrating using an <code>assign</code> subscriber in a pipeline from a <code>dataTaskPublisher</code> with <code>subscribe</code> and <code>receive</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SubscribeReceiveAssignTests.swift"><code>UsingCombineTests/SubscribeReceiveAssignTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Subscribe</code> assigns a scheduler to the preceding pipeline invocation.
It is relatively infrequently used, specifically to encourage a publisher such as <a href="#reference-just">Just</a> or <a href="#reference-deferred">Deferred</a> to run on a specific queue.
If you want to control which queue operators run on, then it is more common to use the <a href="#reference-receive">receive</a> operator, which effects all following operators and subscribers.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>Subscribe</code> takes a single required parameter (<code>on:</code>) which accepts a scheduler, and an optional parameter (<code>optional:</code>) which can accept <code>SchedulerOptions</code>.
<a href="https://developer.apple.com/documentation/combine/scheduler">Scheduler</a> is a protocol in Combine, with the conforming types that are commonly used of <a href="https://developer.apple.com/documentation/foundation/runloop">RunLoop</a>, <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue">DispatchQueue</a> and <a href="https://developer.apple.com/documentation/foundation/operationqueue">OperationQueue</a>.</p>
</div>
<div class="paragraph">
<p><code>Subscribe</code> effects a subset of the functions, and does not guarantee that a publisher will run on that queue.
In particular, it effects a publishers <code>receive</code> function, the subscribers <code>request</code> function, and the <code>cancel</code> function.
Some publishers (such as <a href="#reference-datataskpublisher">URLSession.dataTaskPublisher</a>) have complex internals that will run on alternative queues based on their configuration, and will be relatively unaffected by <code>subscribe</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">networkDataPublisher</span>
    <span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="n">backgroundQueue</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">yourLabel</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the <code>subscribe</code> call requests the publisher (and any pipeline invocations before this in a chain) be invoked on the backgroundQueue.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the <code>receive</code> call transfers the data to the main runloop, suitable for updating user interface elements</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>the <code>assign</code> call uses the <a href="#reference-assign">assign</a> subscriber to update the property <code>text</code> on a KVO compliant object, in this case <code>yourLabel</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When creating a <code>DispatchQueue</code> to use with Combine publishers on background threads, it is recommended that you use a regular serial queue rather than a concurrent queue <a href="https://forums.swift.org/t/runloop-main-or-dispatchqueue-main-when-using-combine-scheduler/26635/4">to allow Combine to adhere to its contracts</a>.
That is: <strong>do not</strong> create the queue with <code>attributes: .concurrent</code>.</p>
</div>
<div class="paragraph">
<p>This is not enforced by the compiler or any internal framework constraints.</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="type-erasure-operators">Type erasure operators</h4>
<div class="sect4">
<h5 id="reference-erasetoanypublisher">eraseToAnyPublisher</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>The <code>eraseToAnyPublisher</code> operator takes a publisher and provides a type erased instance of AnyPublisher.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/anypublisher" class="bare">https://developer.apple.com/documentation/combine/anypublisher</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-future">Wrapping an asynchronous call with a Future to create a one-shot publisher</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading multiple UI updates, including a network request</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>When chaining operators together, the resulting type signature accumulates all the various types.
This can get complicated quite quickly, and can provide an unnecessarily complex signature for an API.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>eraseToAnyPublisher</code> takes the signature and "erases" the type back to the common type of <code>AnyPublisher</code>.
This provides a cleaner type for external declarations.
Combine was created prior to Swift 5 inclusion of opaque types, which may have been an alternative.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>eraseToAnyPublisher</code> is often at the end of chains of operators, cleaning up the signature of the returned property.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="reference-anysubscriber">AnySubscriber</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p>The <code>AnySubscriber</code> provides a type erased instance of AnySubscriber.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/anysubscriber" class="bare">https://developer.apple.com/documentation/combine/anysubscriber</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>Use an <code>AnySubscriber</code> to wrap an existing subscriber whose details you don’t want to expose.
You can also use <code>AnySubscriber</code> to create a custom subscriber by providing closures for the methods defined in <code>Subscriber</code>, rather than implementing <code>Subscriber</code> directly.</p>
</dd>
</dl>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reference-subjects">Subjects</h3>
<div class="paragraph">
<p>General information on <a href="#coreconcepts-subjects">Subjects</a> can be found in the Core Concepts section.</p>
</div>
<div class="sect3">
<h4 id="reference-currentvaluesubject">currentValueSubject</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>CurrentValueSubject</code> creates an object that can be used to integrate imperative code into a pipeline, starting with an initial value.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/currentvaluesubject"><code>CurrentValueSubject</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>currentValueSubject</code> creates an instance to which you can attach multiple subscribers.
When creating a <code>currentValueSubject</code>, you do so with an initial value of the relevant output type for the Subject.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>CurrentValueSubject</code> remembers the current value so that when a subscriber is attached, it immediately receives the current value.
When a subscriber is connected and requests data, the initial value is sent.
Further calls to <code>.send()</code> afterwards will then pass through values to any subscribers.</p>
</div>
</div>
<div class="sect3">
<h4 id="reference-passthroughsubject">PassthroughSubject</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>PassthroughSubject</code> creates an object that can be used to integrate imperative code into a Combine pipeline.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/passthroughsubject"><code>PassthroughSubject</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>PassthroughSubject</code> creates an instance to which you can attach multiple subscribers.
When it is created, only the types are defined.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>When a subscriber is connected and requests data, it will not receive any values until a <code>.send()</code> call is invoked.
<code>PassthroughSubject</code> doesn&#8217;t maintain any state, it only passes through provided values.
Calls to <code>.send()</code> will then send values to any subscribers.</p>
</div>
<div class="paragraph">
<p><code>PassthroughSubject</code> is commonly used in scenarios where you want to create a publisher from imperative code.
One example of this might be a publisher from a delegate callback structure, common in Apple&#8217;s APIs.
Another common use is to test subscribers and pipelines, providing you with imperative control of when events are sent within a pipeline.</p>
</div>
<div class="paragraph">
<p>This is very useful when creating tests, as you can put when data is sent to a pipeline under test control.</p>
</div>
<div style="page-break-after: always;"></div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="reference-subscribers">Subscribers</h3>
<div class="paragraph">
<p>For general information about subscribers and how they fit with publishers and operators, see <a href="#coreconcepts-subscribers">Subscribers</a>.</p>
</div>
<div class="sect3">
<h4 id="reference-assign">assign</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Assign</code> creates a subscriber used to update a property on a KVO compliant object.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Failure type must be <code>&lt;Never&gt;</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/subscribers/assign"><code>assign</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-assign-subscriber">Creating a subscriber with assign</a> shows an example of using <code>assign</code> to set an a boolean property on a UI element.</p>
</li>
<li>
<p>unit tests illustrating using an <code>assign</code> subscriber in a pipeline from a <code>dataTaskPublisher</code> with <code>subscribe</code> and <code>receive</code>: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SubscribeReceiveAssignTests.swift"><code>UsingCombineTests/SubscribeReceiveAssignTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>Assign</code> only handles data, and expects all errors or failures to be handled in the pipeline before it is invoked.
The return value from setting up <code>assign</code> can be cancelled, and is frequently used when disabling the pipeline, such as when a viewController is disabled or deallocated.
<code>Assign</code> is frequently used in conjunction with the <a href="#reference-receive">receive</a> operator to receive values on a specific scheduler, typically <code>RunLoop.main</code> when updating UI objects.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The type of <code>KeyPath</code> required for the <code>assign</code> operator is important.
It requires a <code>ReferenceWritableKeyPath</code>, which is different from both <code>WritableKeyPath</code> and <code>KeyPath</code>.
In particular, <code>ReferenceWritableKeyPath</code> requires that the object you&#8217;re writing to is a reference type (an instance of a class), as well as being publicly writable.
A <code>WritableKeyPath</code> is one that&#8217;s a mutable value reference (a mutable struct), and <code>KeyPath</code> reflects that the object is simply readable by keypath, but not mutable.</p>
</div>
<div class="paragraph">
<p>It is not always clear (for example, while using code-completion from the editor) what a property may reflect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="n">examplePublisher</span>
    <span class="o">.</span><span class="nf">receive</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="kt">RunLoop</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="n">yourLabel</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An error you may see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Cannot convert value of type 'KeyPath&lt;SomeObject, Bool&gt;' to specified type 'ReferenceWritableKeyPath&lt;SomeObject, Bool&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>This happens when you are attempting to assign to a property that is read-only.
An example of this is <code>UIActivityIndicator&#8217;s `isAnimating</code> property.</p>
</div>
<div class="paragraph">
<p>Another error you might see on using the <code>assign</code> operator is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Type of expression is ambiguous without more context</code></pre>
</div>
</div>
<div class="paragraph">
<p>Xcode 11.7 supplies improved swift compiler diagnostics, which enable an easier to understand error message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Key path value type 'UIImage?' cannot be converted to contextual type 'UIImage'</code></pre>
</div>
</div>
<div class="paragraph">
<p>This error can occur when you are attempting to assign a non-optional type to a keypath that expects has an optional type.
For example, <code>UIImageView.image</code> is of type <code>UIImage?</code>, so attempting to assign an output type of <code>UIImage</code> from a previous operator would result in this error message.</p>
</div>
<div class="paragraph">
<p>The solution is to either use <a href="#reference-sink">sink</a>, or to include a <code>map</code> operator prior to assignment that changes the output type to match.
For example, to convert the type <code>UIImage</code> to <code>UIImage?</code> you could use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">image</span> <span class="o">-&gt;</span> <span class="kt">UIImage</span><span class="p">?</span> <span class="k">in</span>
    <span class="n">image</span>
<span class="p">}</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="reference-sink">sink</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>Sink</code> creates an all-purpose subscriber.
At a minimum, you provide a closure to receive values, and optionally a closure that receives completions.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><em>none</em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/subscribers/sink"><code>sink</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-sink-subscriber">Creating a subscriber with sink</a> shows an example of creating a <code>sink</code> that receives both completion messages as well as data from the publisher.</p>
</li>
<li>
<p>unit tests illustrating a <code>sink</code> subscriber and how it works: <a href="https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SinkSubscriberTests.swift"><code>UsingCombineTests/SinkSubscriberTests.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>There are two forms of the <code>sink</code> operator.
The first is the simplest form, taking a single closure, receiving only the values from the pipeline (if and when provided by the publisher).
Using the simpler version comes with a constraint: the failure type of the pipeline must be <code>&lt;Never&gt;</code>.
If you are working with a pipeline that has a failure type other than <code>&lt;Never&gt;</code> you need to use the two closure version or add error handling into the pipeline itself.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>An example of the simple form of <code>sink</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">examplePublisher</span> <span class="o">=</span> <span class="kt">Just</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">examplePublisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Be aware that the closure may be called repeatedly.
How often it is called depends on the pipeline to which it is subscribing.
The closure you provide is invoked for every update that the publisher provides, up until the completion, and prior to any cancellation.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It may be tempting to ignore the cancellable you get returned from <code>sink</code>.
For example, the code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">examplePublisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this has the side effect that as soon as the function returns, the ignored variable is deallocated, causing the pipeline to be cancelled.
If you want the pipeline to operate beyond the scope of the function (you probably do), then assign it to a longer lived variable that doesn&#8217;t get deallocated until much later.
Simply including a variable declaration in the enclosing object is often a good solution.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The second form of <code>sink</code> takes two closures, the first of which receives the data from the pipeline, and the second receives pipeline completion messages.
The closure parameters are <code>receiveCompletion</code> and <code>receiveValue</code>:
A <code>.failure</code> completion may also encapsulate an error.</p>
</div>
<div class="paragraph">
<p>An example of the two-closure <code>sink</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">examplePublisher</span> <span class="o">=</span> <span class="kt">Just</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">examplePublisher</span><span class="o">.</span><span class="nf">sink</span><span class="p">(</span><span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received the completion"</span><span class="p">,</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">err</span><span class="p">))</span>
<span class="p">},</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">".sink() received </span><span class="se">\(</span><span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The type that is passed into <code>receiveCompletion</code> is the enum <a href="https://developer.apple.com/documentation/combine/subscribers/completion"><code>Subscribers.Completion</code></a>.
The completion <code>.failure</code> includes an <code>Error</code> wrapped within it, providing access to the underlying cause of the failure.
To get to the error within the <code>.failure</code> completion, <code>switch</code> on the returned completion to determine if it is <code>.finished</code> or <code>.failure</code>, and then pull out the error.</p>
</div>
<div class="paragraph">
<p>When you chain a <code>.sink</code> subscriber onto a publisher (or pipeline), the result is cancellable.
At any time before the publisher sends a completion, the subscriber can send a cancellation and invalidate the pipeline.
After a cancel is sent, no further values will be received.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">let</span> <span class="nv">simplePublisher</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">cancellablePipeline</span> <span class="o">=</span> <span class="n">simplePublisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">data</span> <span class="k">in</span>
  <span class="c1">// do what you need with the data...</span>
<span class="p">}</span>

<span class="n">cancellablePublisher</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span> <span class="c1">// when invoked, this invalidates the pipeline</span>
<span class="c1">// no further data will be received by the sink</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>similar to publishers having a type-erased struct <a href="#reference-erasetoanypublisher">AnyPublisher</a> to expose publishers through an API, subscribers have an equivalent: <a href="#reference-anycancellable">AnyCancellable</a>. This is often used with <code>sink</code> to convert the resulting type into <code>AnyCancellable</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="reference-onreceive">onReceive</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>onReceive</code> is a subscriber built into SwiftUI that allows publishers to be linked into local views to trigger relevant state changes.</p>
</dd>
<dt class="hdlist1"><em>Constraints on connected publisher</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Failure type must be <code>&lt;Never&gt;</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/swiftui/tupleview/3365870-onreceive"><code>onReceive</code></a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The SwiftUI example code at <a href="https://github.com/heckj/swiftui-notes/blob/master/SwiftUI-Notes/HeadingView.swift"><code>SwiftUI-Notes/HeadingView.swift</code></a></p>
</li>
<li>
<p>The SwiftUI example code at <a href="https://github.com/heckj/swiftui-notes/blob/master/SwiftUI-Notes/ReactiveForm.swift"><code>SwiftUI-Notes/ReactiveForm.swift</code></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p><code>onReceive</code> is a subscriber, taking a reference to a publisher, a closure which is invoked when the publisher provided to <code>onReceive</code> receives data.
This acts very similarly to the sink subscriber with a single closure, including requiring that the failure type of the publisher be <code>&lt;Never&gt;</code>.
<code>onReceive</code> does not automatically invalidate the view, but allows the developers to react to the published data in whatever way is appropriate - this could be updating some local view property (<code>@State</code>) with the value directly, or first transforming the data in some fashion.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A common example of this with SwiftUI is hooking up a publisher created from a <code>Timer</code>, which generates a <code>Date</code> reference, and using that to trigger an update to a view from a timer.</p>
</div>
</div>
<div class="sect3">
<h4 id="reference-anycancellable">AnyCancellable</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>Summary</em></dt>
<dd>
<p><code>AnyCancellable</code> type erases a subscriber to the general form of <a href="https://developer.apple.com/documentation/combine/cancellable">Cancellable</a>.</p>
</dd>
<dt class="hdlist1"><em><span class="icon"><i class="fa fa-apple"></i></span> docs</em></dt>
<dd>
<p><a href="https://developer.apple.com/documentation/combine/anycancellable" class="bare">https://developer.apple.com/documentation/combine/anycancellable</a></p>
</dd>
<dt class="hdlist1"><em>Usage</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#patterns-update-interface-userinput">Declarative UI updates from user input</a></p>
</li>
<li>
<p><a href="#patterns-cascading-update-interface">Cascading UI updates including a network request</a></p>
</li>
<li>
<p><a href="#patterns-delegate-publisher-subject">Creating a repeating publisher by wrapping a delegate based API</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><em>Details</em></dt>
<dd>
<p>This is used to provide a reference to a subscriber that allows the use of <code>cancel</code> without access to the subscription itself to request items.
This is most typically used when you want a reference to a subscriber to clean it up on deallocation.
Since the <a href="#reference-assign">assign</a> returns an <code>AnyCancellable</code>, this is often used when you want to save the reference to a <a href="#reference-sink">sink</a> an <code>AnyCancellable</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="k">var</span> <span class="nv">mySubscriber</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>

<span class="k">let</span> <span class="nv">mySinkSubscriber</span> <span class="o">=</span> <span class="n">remotePublisher</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">data</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"received "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">}</span>
<span class="n">mySubscriber</span> <span class="o">=</span> <span class="kt">AnyCancellable</span><span class="p">(</span><span class="n">mySinkSubscriber</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A pattern that is supported with Combine is collecting <code>AnyCancellable</code> references into a set and then saving references to the cancellable subscribers with a <code>store</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">private</span> <span class="k">var</span> <span class="nv">cancellableSet</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">AnyCancellable</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">let</span> <span class="nv">mySinkSubscriber</span> <span class="o">=</span> <span class="n">remotePublisher</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">data</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"received "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">store</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">cancellableSet</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.2.1<br>
Last updated 2022-04-10 16:25:09 UTC
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-898243-5','auto');
ga('send','pageview');
</script>
</body>
</html>